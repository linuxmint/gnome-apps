/* number.c generated by valac 0.20.1, the Vala compiler
 * generated from number.vala, do not modify */

/*
 * Copyright (C) 1987-2008 Sun Microsystems, Inc. All Rights Reserved.
 * Copyright (C) 2008-2012 Robert Ancell
 *
 * This program is free software: you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 2 of the License, or (at your option) any later
 * version. See http://www.gnu.org/copyleft/gpl.html the full text of the
 * license.
 */
/*  This maths library is based on the MP multi-precision floating-point
 *  arithmetic package originally written in FORTRAN by Richard Brent,
 *  Computer Centre, Australian National University in the 1970's.
 *
 *  It has been converted from FORTRAN into C using the freely available
 *  f2c translator, available via netlib on research.att.com.
 *
 *  The subsequently converted C code has then been tidied up, mainly to
 *  remove any dependencies on the libI77 and libF77 support libraries.
 *
 *  FOR A GENERAL DESCRIPTION OF THE PHILOSOPHY AND DESIGN OF MP,
 *  SEE - R. P. BRENT, A FORTRAN MULTIPLE-PRECISION ARITHMETIC
 *  PACKAGE, ACM TRANS. MATH. SOFTWARE 4 (MARCH 1978), 57-70.
 *  SOME ADDITIONAL DETAILS ARE GIVEN IN THE SAME ISSUE, 71-81.
 *  FOR DETAILS OF THE IMPLEMENTATION, CALLING SEQUENCES ETC. SEE
 *  THE MP USERS GUIDE.
 */
/* Size of the multiple precision values */

#include <glib.h>
#include <glib-object.h>
#include <float.h>
#include <math.h>
#include <stdlib.h>
#include <string.h>
#include <glib/gi18n-lib.h>
#include <gobject/gvaluecollector.h>


#define TYPE_ANGLE_UNIT (angle_unit_get_type ())

#define TYPE_NUMBER (number_get_type ())
#define NUMBER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_NUMBER, Number))
#define NUMBER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_NUMBER, NumberClass))
#define IS_NUMBER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_NUMBER))
#define IS_NUMBER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_NUMBER))
#define NUMBER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_NUMBER, NumberClass))

typedef struct _Number Number;
typedef struct _NumberClass NumberClass;
typedef struct _NumberPrivate NumberPrivate;
#define _number_unref0(var) ((var == NULL) ? NULL : (var = (number_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define __g_list_free__number_unref0_0(var) ((var == NULL) ? NULL : (var = (_g_list_free__number_unref0_ (var), NULL)))

#define TYPE_DISPLAY_FORMAT (display_format_get_type ())

#define TYPE_SERIALIZER (serializer_get_type ())
#define SERIALIZER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SERIALIZER, Serializer))
#define SERIALIZER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SERIALIZER, SerializerClass))
#define IS_SERIALIZER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SERIALIZER))
#define IS_SERIALIZER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SERIALIZER))
#define SERIALIZER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SERIALIZER, SerializerClass))

typedef struct _Serializer Serializer;
typedef struct _SerializerClass SerializerClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
typedef struct _ParamSpecNumber ParamSpecNumber;

typedef gint (*BitwiseFunc) (gint v1, gint v2, void* user_data);
typedef enum  {
	ANGLE_UNIT_RADIANS,
	ANGLE_UNIT_DEGREES,
	ANGLE_UNIT_GRADIANS
} AngleUnit;

struct _Number {
	GTypeInstance parent_instance;
	volatile int ref_count;
	NumberPrivate * priv;
	gint re_sign;
	gint im_sign;
	gint re_exponent;
	gint im_exponent;
	gint re_fraction[1000];
	gint im_fraction[1000];
};

struct _NumberClass {
	GTypeClass parent_class;
	void (*finalize) (Number *self);
};

typedef enum  {
	DISPLAY_FORMAT_AUTOMATIC,
	DISPLAY_FORMAT_FIXED,
	DISPLAY_FORMAT_SCIENTIFIC,
	DISPLAY_FORMAT_ENGINEERING
} DisplayFormat;

struct _ParamSpecNumber {
	GParamSpec parent_instance;
};


static gpointer number_parent_class = NULL;
extern gchar* mp_error;
gchar* mp_error = NULL;

#define SIZE 1000
#define BASE 10000
#define T 100
GType angle_unit_get_type (void) G_GNUC_CONST;
gpointer number_ref (gpointer instance);
void number_unref (gpointer instance);
GParamSpec* param_spec_number (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_number (GValue* value, gpointer v_object);
void value_take_number (GValue* value, gpointer v_object);
gpointer value_get_number (const GValue* value);
GType number_get_type (void) G_GNUC_CONST;
enum  {
	NUMBER_DUMMY_PROPERTY
};
Number* number_new_integer (gint64 value);
Number* number_construct_integer (GType object_type, gint64 value);
Number* number_new_unsigned_integer (guint64 x);
Number* number_construct_unsigned_integer (GType object_type, guint64 x);
Number* number_new_fraction (gint64 numerator, gint64 denominator);
Number* number_construct_fraction (GType object_type, gint64 numerator, gint64 denominator);
void mp_gcd (gint64* k, gint64* l);
Number* number_divide_integer (Number* self, gint64 y);
Number* number_new_float (gfloat value);
Number* number_construct_float (GType object_type, gfloat value);
void mp_normalize (Number** x);
Number* number_multiply_integer (Number* self, gint64 y);
Number* number_new_double (gdouble value);
Number* number_construct_double (GType object_type, gdouble value);
Number* number_new_complex (Number* x, Number* y);
Number* number_construct_complex (GType object_type, Number* x, Number* y);
Number* number_new_polar (Number* r, Number* theta, AngleUnit unit);
Number* number_construct_polar (GType object_type, Number* r, Number* theta, AngleUnit unit);
Number* number_cos (Number* self, AngleUnit unit);
Number* number_sin (Number* self, AngleUnit unit);
Number* number_multiply (Number* self, Number* y);
Number* number_new_eulers (void);
Number* number_construct_eulers (GType object_type);
Number* number_epowy (Number* self);
Number* number_new_i (void);
Number* number_construct_i (GType object_type);
Number* number_new_pi (void);
Number* number_construct_pi (GType object_type);
Number* number_new_random (void);
Number* number_construct_random (GType object_type);
gint64 number_to_integer (Number* self);
guint64 number_to_unsigned_integer (Number* self);
gfloat number_to_float (Number* self);
gboolean number_is_zero (Number* self);
gdouble number_to_double (Number* self);
gboolean number_is_negative (Number* self);
gboolean number_is_integer (Number* self);
gboolean number_is_complex (Number* self);
Number* number_divide (Number* self, Number* y);
Number* number_floor (Number* self);
gboolean number_equals (Number* self, Number* y);
gboolean number_is_positive_integer (Number* self);
gboolean number_is_natural (Number* self);
gint number_compare (Number* self, Number* y);
Number* number_sgn (Number* self);
Number* number_invert_sign (Number* self);
static Number* number_copy (Number* self);
Number* number_abs (Number* self);
Number* number_real_component (Number* self);
Number* number_imaginary_component (Number* self);
Number* number_add (Number* self, Number* y);
Number* number_root (Number* self, gint64 n);
Number* number_arg (Number* self, AngleUnit unit);
void mperr (const gchar* text);
Number* number_atan (Number* self, AngleUnit unit);
Number* number_subtract (Number* self, Number* y);
static Number* number_from_radians (Number* self, AngleUnit unit);
Number* number_conjugate (Number* self);
Number* number_new (void);
Number* number_construct (GType object_type);
Number* number_integer_component (Number* self);
Number* number_fractional_component (Number* self);
Number* number_fractional_part (Number* self);
Number* number_ceiling (Number* self);
Number* number_round (Number* self);
Number* number_reciprocal (Number* self);
static Number* number_reciprocal_real (Number* self);
static Number* number_epowy_real (Number* self);
Number* number_xpowy (Number* self, Number* y);
Number* number_xpowy_integer (Number* self, gint64 n);
static Number* number_pwr (Number* self, Number* y);
static Number* number_root_real (Number* self, gint64 n);
Number* number_sqrt (Number* self);
static Number* number_ext (Number* self, gint i, gint j);
Number* number_ln (Number* self);
static Number* number_ln_real (Number* self);
Number* number_logarithm (Number* self, gint64 n);
Number* number_factorial (Number* self);
static Number* number_add_with_sign (Number* self, gint y_sign, Number* y);
static Number* number_multiply_real (Number* self, Number* y);
static Number* number_multiply_integer_real (Number* self, gint64 y);
static Number* number_divide_integer_real (Number* self, gint64 y);
Number* number_modulus_divide (Number* self, Number* y);
static Number* number_sin_real (Number* self, AngleUnit unit);
Number* number_cosh (Number* self);
static Number* number_cos_real (Number* self, AngleUnit unit);
Number* number_sinh (Number* self);
Number* number_tan (Number* self, AngleUnit unit);
Number* number_asin (Number* self, AngleUnit unit);
Number* number_acos (Number* self, AngleUnit unit);
Number* number_tanh (Number* self);
Number* number_asinh (Number* self);
Number* number_acosh (Number* self);
Number* number_atanh (Number* self);
Number* number_and (Number* self, Number* y);
static Number* number_bitwise (Number* self, Number* y, BitwiseFunc bitwise_operator, void* bitwise_operator_target, gint wordlen);
static gint __lambda2_ (Number* self, gint v1, gint v2);
static gint ___lambda2__bitwise_func (gint v1, gint v2, gpointer self);
Number* number_or (Number* self, Number* y);
static gint __lambda3_ (Number* self, gint v1, gint v2);
static gint ___lambda3__bitwise_func (gint v1, gint v2, gpointer self);
Number* number_xor (Number* self, Number* y);
static gint __lambda4_ (Number* self, gint v1, gint v2);
static gint ___lambda4__bitwise_func (gint v1, gint v2, gpointer self);
Number* number_not (Number* self, gint wordlen);
static gint __lambda5_ (Number* self, gint v1, gint v2);
static gint ___lambda5__bitwise_func (gint v1, gint v2, gpointer self);
Number* number_mask (Number* self, Number* x, gint wordlen);
static gchar* number_to_hex_string (Number* self);
Number* mp_set_from_string (const gchar* str, gint default_base);
Number* number_shift (Number* self, gint count);
Number* number_ones_complement (Number* self, gint wordlen);
static gint __lambda6_ (Number* self, gint v1, gint v2);
static gint ___lambda6__bitwise_func (gint v1, gint v2, gpointer self);
Number* number_twos_complement (Number* self, gint wordlen);
GList* number_factorize (Number* self);
static void _number_unref0_ (gpointer var);
static void _g_list_free__number_unref0_ (GList* self);
static Number* number_add_real (Number* self, gint y_sign, Number* y);
static Number* number_exp (Number* self);
static Number* number_lns (Number* self);
static gfloat number_to_float_old (Number* self);
static gdouble number_mppow_ri (Number* self, gfloat ap, gint bp);
static gint* _vala_array_dup1 (gint* self, int length);
static gint* _vala_array_dup2 (gint* self, int length);
static gint* _vala_array_dup3 (gint* self, int length);
static gint* _vala_array_dup4 (gint* self, int length);
static Number* number_to_radians (Number* self, AngleUnit unit);
static Number* number_sin1 (Number* self, gboolean do_sin);
static gint number_hex_to_int (Number* self, gchar digit);
GType display_format_get_type (void) G_GNUC_CONST;
Serializer* serializer_new (DisplayFormat format, gint number_base, gint trailing_digits);
Serializer* serializer_construct (GType object_type, DisplayFormat format, gint number_base, gint trailing_digits);
GType serializer_get_type (void) G_GNUC_CONST;
gchar* serializer_to_string (Serializer* self, Number* x);
static void number_finalize (Number* obj);
gchar* mp_get_error (void);
void mp_clear_error (void);
Number* set_from_sexagesimal (const gchar* str);
gint char_val (gunichar c, gint number_base);
gboolean mp_is_overflow (Number* x, gint wordlen);


GType angle_unit_get_type (void) {
	static volatile gsize angle_unit_type_id__volatile = 0;
	if (g_once_init_enter (&angle_unit_type_id__volatile)) {
		static const GEnumValue values[] = {{ANGLE_UNIT_RADIANS, "ANGLE_UNIT_RADIANS", "radians"}, {ANGLE_UNIT_DEGREES, "ANGLE_UNIT_DEGREES", "degrees"}, {ANGLE_UNIT_GRADIANS, "ANGLE_UNIT_GRADIANS", "gradians"}, {0, NULL, NULL}};
		GType angle_unit_type_id;
		angle_unit_type_id = g_enum_register_static ("AngleUnit", values);
		g_once_init_leave (&angle_unit_type_id__volatile, angle_unit_type_id);
	}
	return angle_unit_type_id__volatile;
}


Number* number_construct_integer (GType object_type, gint64 value) {
	Number* self = NULL;
	gint64 _tmp0_;
	self = (Number*) g_type_create_instance (object_type);
	_tmp0_ = value;
	if (_tmp0_ < ((gint64) 0)) {
		gint64 _tmp1_;
		_tmp1_ = value;
		value = -_tmp1_;
		self->re_sign = -1;
	} else {
		gint64 _tmp2_;
		_tmp2_ = value;
		if (_tmp2_ > ((gint64) 0)) {
			self->re_sign = 1;
		} else {
			self->re_sign = 0;
		}
	}
	while (TRUE) {
		gint64 _tmp3_;
		gint _tmp4_;
		gint64 _tmp5_;
		gint _tmp6_;
		gint _tmp7_;
		gint64 _tmp8_;
		_tmp3_ = value;
		if (!(_tmp3_ != ((gint64) 0))) {
			break;
		}
		_tmp4_ = self->re_exponent;
		_tmp5_ = value;
		self->re_fraction[_tmp4_] = (gint) (_tmp5_ % BASE);
		_tmp6_ = self->re_fraction[_tmp4_];
		_tmp7_ = self->re_exponent;
		self->re_exponent = _tmp7_ + 1;
		_tmp8_ = value;
		value = _tmp8_ / BASE;
	}
	{
		gint i;
		i = 0;
		{
			gboolean _tmp9_;
			_tmp9_ = TRUE;
			while (TRUE) {
				gboolean _tmp10_;
				gint _tmp12_;
				gint _tmp13_;
				gint _tmp14_;
				gint _tmp15_;
				gint t;
				gint _tmp16_;
				gint _tmp17_;
				gint _tmp18_;
				gint _tmp19_;
				gint _tmp20_;
				gint _tmp21_;
				gint _tmp22_;
				gint _tmp23_;
				gint _tmp24_;
				_tmp10_ = _tmp9_;
				if (!_tmp10_) {
					gint _tmp11_;
					_tmp11_ = i;
					i = _tmp11_ + 1;
				}
				_tmp9_ = FALSE;
				_tmp12_ = i;
				_tmp13_ = self->re_exponent;
				if (!(_tmp12_ < (_tmp13_ / 2))) {
					break;
				}
				_tmp14_ = i;
				_tmp15_ = self->re_fraction[_tmp14_];
				t = _tmp15_;
				_tmp16_ = i;
				_tmp17_ = self->re_exponent;
				_tmp18_ = i;
				_tmp19_ = self->re_fraction[(_tmp17_ - _tmp18_) - 1];
				self->re_fraction[_tmp16_] = _tmp19_;
				_tmp20_ = self->re_fraction[_tmp16_];
				_tmp21_ = self->re_exponent;
				_tmp22_ = i;
				_tmp23_ = t;
				self->re_fraction[(_tmp21_ - _tmp22_) - 1] = _tmp23_;
				_tmp24_ = self->re_fraction[(_tmp21_ - _tmp22_) - 1];
			}
		}
	}
	return self;
}


Number* number_new_integer (gint64 value) {
	return number_construct_integer (TYPE_NUMBER, value);
}


Number* number_construct_unsigned_integer (GType object_type, guint64 x) {
	Number* self = NULL;
	guint64 _tmp0_;
	self = (Number*) g_type_create_instance (object_type);
	_tmp0_ = x;
	if (_tmp0_ == ((guint64) 0)) {
		self->re_sign = 0;
	} else {
		self->re_sign = 1;
	}
	while (TRUE) {
		guint64 _tmp1_;
		gint _tmp2_;
		guint64 _tmp3_;
		gint _tmp4_;
		guint64 _tmp5_;
		gint _tmp6_;
		_tmp1_ = x;
		if (!(_tmp1_ != ((guint64) 0))) {
			break;
		}
		_tmp2_ = self->re_exponent;
		_tmp3_ = x;
		self->re_fraction[_tmp2_] = (gint) (_tmp3_ % BASE);
		_tmp4_ = self->re_fraction[_tmp2_];
		_tmp5_ = x;
		x = _tmp5_ / BASE;
		_tmp6_ = self->re_exponent;
		self->re_exponent = _tmp6_ + 1;
	}
	{
		gint i;
		i = 0;
		{
			gboolean _tmp7_;
			_tmp7_ = TRUE;
			while (TRUE) {
				gboolean _tmp8_;
				gint _tmp10_;
				gint _tmp11_;
				gint _tmp12_;
				gint _tmp13_;
				gint t;
				gint _tmp14_;
				gint _tmp15_;
				gint _tmp16_;
				gint _tmp17_;
				gint _tmp18_;
				gint _tmp19_;
				gint _tmp20_;
				gint _tmp21_;
				gint _tmp22_;
				_tmp8_ = _tmp7_;
				if (!_tmp8_) {
					gint _tmp9_;
					_tmp9_ = i;
					i = _tmp9_ + 1;
				}
				_tmp7_ = FALSE;
				_tmp10_ = i;
				_tmp11_ = self->re_exponent;
				if (!(_tmp10_ < (_tmp11_ / 2))) {
					break;
				}
				_tmp12_ = i;
				_tmp13_ = self->re_fraction[_tmp12_];
				t = _tmp13_;
				_tmp14_ = i;
				_tmp15_ = self->re_exponent;
				_tmp16_ = i;
				_tmp17_ = self->re_fraction[(_tmp15_ - _tmp16_) - 1];
				self->re_fraction[_tmp14_] = _tmp17_;
				_tmp18_ = self->re_fraction[_tmp14_];
				_tmp19_ = self->re_exponent;
				_tmp20_ = i;
				_tmp21_ = t;
				self->re_fraction[(_tmp19_ - _tmp20_) - 1] = _tmp21_;
				_tmp22_ = self->re_fraction[(_tmp19_ - _tmp20_) - 1];
			}
		}
	}
	return self;
}


Number* number_new_unsigned_integer (guint64 x) {
	return number_construct_unsigned_integer (TYPE_NUMBER, x);
}


Number* number_construct_fraction (GType object_type, gint64 numerator, gint64 denominator) {
	Number* self = NULL;
	gint64 _tmp0_;
	gint64 _tmp3_;
	gint64 _tmp4_;
	mp_gcd (&numerator, &denominator);
	_tmp0_ = denominator;
	if (_tmp0_ < ((gint64) 0)) {
		gint64 _tmp1_;
		gint64 _tmp2_;
		_tmp1_ = numerator;
		numerator = -_tmp1_;
		_tmp2_ = denominator;
		denominator = -_tmp2_;
	}
	_tmp3_ = numerator;
	self = (Number*) number_construct_integer (object_type, _tmp3_);
	_tmp4_ = denominator;
	if (_tmp4_ != ((gint64) 1)) {
		gint64 _tmp5_;
		Number* _tmp6_ = NULL;
		Number* z;
		Number* _tmp7_;
		gint _tmp8_;
		Number* _tmp9_;
		gint _tmp10_;
		Number* _tmp11_;
		gint _tmp12_;
		Number* _tmp13_;
		gint _tmp14_;
		_tmp5_ = denominator;
		_tmp6_ = number_divide_integer (self, _tmp5_);
		z = _tmp6_;
		_tmp7_ = z;
		_tmp8_ = _tmp7_->re_sign;
		self->re_sign = _tmp8_;
		_tmp9_ = z;
		_tmp10_ = _tmp9_->im_sign;
		self->im_sign = _tmp10_;
		_tmp11_ = z;
		_tmp12_ = _tmp11_->re_exponent;
		self->re_exponent = _tmp12_;
		_tmp13_ = z;
		_tmp14_ = _tmp13_->im_exponent;
		self->im_exponent = _tmp14_;
		{
			gint i;
			i = 0;
			{
				gboolean _tmp15_;
				_tmp15_ = TRUE;
				while (TRUE) {
					gboolean _tmp16_;
					gint _tmp18_;
					Number* _tmp19_;
					gint _tmp20_;
					Number* _tmp21_;
					gint _tmp22_;
					gint _tmp23_;
					gint _tmp24_;
					gint _tmp25_;
					Number* _tmp26_;
					gint _tmp27_;
					gint _tmp28_;
					gint _tmp29_;
					_tmp16_ = _tmp15_;
					if (!_tmp16_) {
						gint _tmp17_;
						_tmp17_ = i;
						i = _tmp17_ + 1;
					}
					_tmp15_ = FALSE;
					_tmp18_ = i;
					_tmp19_ = z;
					if (!(_tmp18_ < 1000)) {
						break;
					}
					_tmp20_ = i;
					_tmp21_ = z;
					_tmp22_ = i;
					_tmp23_ = _tmp21_->re_fraction[_tmp22_];
					self->re_fraction[_tmp20_] = _tmp23_;
					_tmp24_ = self->re_fraction[_tmp20_];
					_tmp25_ = i;
					_tmp26_ = z;
					_tmp27_ = i;
					_tmp28_ = _tmp26_->im_fraction[_tmp27_];
					self->im_fraction[_tmp25_] = _tmp28_;
					_tmp29_ = self->im_fraction[_tmp25_];
				}
			}
		}
		_number_unref0 (z);
	}
	return self;
}


Number* number_new_fraction (gint64 numerator, gint64 denominator) {
	return number_construct_fraction (TYPE_NUMBER, numerator, denominator);
}


Number* number_construct_float (GType object_type, gfloat value) {
	Number* self = NULL;
	Number* _tmp0_;
	Number* z;
	gfloat _tmp1_;
	Number* _tmp68_;
	gint _tmp69_;
	Number* _tmp70_;
	gint _tmp71_;
	Number* _tmp72_;
	gint _tmp73_;
	Number* _tmp74_;
	gint _tmp75_;
	self = (Number*) g_type_create_instance (object_type);
	_tmp0_ = number_new_integer ((gint64) 0);
	z = _tmp0_;
	_tmp1_ = value;
	if (_tmp1_ != ((gfloat) 0)) {
		gfloat rj;
		gfloat _tmp2_;
		gint ie;
		Number* _tmp14_;
		gint _tmp28_ = 0;
		gint ib;
		gint tp;
		gint _tmp29_;
		rj = 0.f;
		_tmp2_ = value;
		if (_tmp2_ < 0.0f) {
			Number* _tmp3_;
			gfloat _tmp4_;
			_tmp3_ = z;
			_tmp3_->re_sign = -1;
			_tmp4_ = value;
			rj = -_tmp4_;
		} else {
			gfloat _tmp5_;
			_tmp5_ = value;
			if (_tmp5_ > 0.0f) {
				Number* _tmp6_;
				gfloat _tmp7_;
				_tmp6_ = z;
				_tmp6_->re_sign = 1;
				_tmp7_ = value;
				rj = _tmp7_;
			}
		}
		ie = 0;
		while (TRUE) {
			gfloat _tmp8_;
			gint _tmp9_;
			gfloat _tmp10_;
			_tmp8_ = rj;
			if (!(_tmp8_ >= 1.0f)) {
				break;
			}
			_tmp9_ = ie;
			ie = _tmp9_ + 1;
			_tmp10_ = rj;
			rj = _tmp10_ * 0.0625f;
		}
		while (TRUE) {
			gfloat _tmp11_;
			gint _tmp12_;
			gfloat _tmp13_;
			_tmp11_ = rj;
			if (!(_tmp11_ < 0.0625f)) {
				break;
			}
			_tmp12_ = ie;
			ie = _tmp12_ - 1;
			_tmp13_ = rj;
			rj = _tmp13_ * 16.0f;
		}
		_tmp14_ = z;
		_tmp14_->re_exponent = 0;
		{
			gint i;
			i = 0;
			{
				gboolean _tmp15_;
				_tmp15_ = TRUE;
				while (TRUE) {
					gboolean _tmp16_;
					gint _tmp18_;
					gfloat _tmp19_;
					Number* _tmp20_;
					gint _tmp21_;
					gfloat _tmp22_;
					gint _tmp23_;
					gfloat _tmp24_;
					Number* _tmp25_;
					gint _tmp26_;
					gint _tmp27_;
					_tmp16_ = _tmp15_;
					if (!_tmp16_) {
						gint _tmp17_;
						_tmp17_ = i;
						i = _tmp17_ + 1;
					}
					_tmp15_ = FALSE;
					_tmp18_ = i;
					if (!(_tmp18_ < (T + 4))) {
						break;
					}
					_tmp19_ = rj;
					rj = _tmp19_ * BASE;
					_tmp20_ = z;
					_tmp21_ = i;
					_tmp22_ = rj;
					_tmp20_->re_fraction[_tmp21_] = (gint) _tmp22_;
					_tmp23_ = _tmp20_->re_fraction[_tmp21_];
					_tmp24_ = rj;
					_tmp25_ = z;
					_tmp26_ = i;
					_tmp27_ = _tmp25_->re_fraction[_tmp26_];
					rj = _tmp24_ - _tmp27_;
				}
			}
		}
		mp_normalize (&z);
		_tmp28_ = MAX ((BASE * 7) * BASE, 32767);
		ib = _tmp28_ / 16;
		tp = 1;
		_tmp29_ = ie;
		if (_tmp29_ < 0) {
			gint _tmp30_;
			gint k;
			_tmp30_ = ie;
			k = -_tmp30_;
			{
				gint i;
				i = 1;
				{
					gboolean _tmp31_;
					_tmp31_ = TRUE;
					while (TRUE) {
						gboolean _tmp32_;
						gint _tmp34_;
						gint _tmp35_;
						gint _tmp36_;
						gboolean _tmp37_ = FALSE;
						gboolean _tmp38_ = FALSE;
						gint _tmp39_;
						gint _tmp40_;
						gboolean _tmp42_;
						gboolean _tmp45_;
						Number* _tmp46_;
						gint _tmp47_;
						Number* _tmp48_ = NULL;
						_tmp32_ = _tmp31_;
						if (!_tmp32_) {
							gint _tmp33_;
							_tmp33_ = i;
							i = _tmp33_ + 1;
						}
						_tmp31_ = FALSE;
						_tmp34_ = i;
						_tmp35_ = k;
						if (!(_tmp34_ <= _tmp35_)) {
							break;
						}
						_tmp36_ = tp;
						tp = _tmp36_ << 4;
						_tmp39_ = tp;
						_tmp40_ = ib;
						if (_tmp39_ <= _tmp40_) {
							gint _tmp41_;
							_tmp41_ = tp;
							_tmp38_ = _tmp41_ != BASE;
						} else {
							_tmp38_ = FALSE;
						}
						_tmp42_ = _tmp38_;
						if (_tmp42_) {
							gint _tmp43_;
							gint _tmp44_;
							_tmp43_ = i;
							_tmp44_ = k;
							_tmp37_ = _tmp43_ < _tmp44_;
						} else {
							_tmp37_ = FALSE;
						}
						_tmp45_ = _tmp37_;
						if (_tmp45_) {
							continue;
						}
						_tmp46_ = z;
						_tmp47_ = tp;
						_tmp48_ = number_divide_integer (_tmp46_, (gint64) _tmp47_);
						_number_unref0 (z);
						z = _tmp48_;
						tp = 1;
					}
				}
			}
		} else {
			gint _tmp49_;
			_tmp49_ = ie;
			if (_tmp49_ > 0) {
				{
					gint i;
					i = 1;
					{
						gboolean _tmp50_;
						_tmp50_ = TRUE;
						while (TRUE) {
							gboolean _tmp51_;
							gint _tmp53_;
							gint _tmp54_;
							gint _tmp55_;
							gboolean _tmp56_ = FALSE;
							gboolean _tmp57_ = FALSE;
							gint _tmp58_;
							gint _tmp59_;
							gboolean _tmp61_;
							gboolean _tmp64_;
							Number* _tmp65_;
							gint _tmp66_;
							Number* _tmp67_ = NULL;
							_tmp51_ = _tmp50_;
							if (!_tmp51_) {
								gint _tmp52_;
								_tmp52_ = i;
								i = _tmp52_ + 1;
							}
							_tmp50_ = FALSE;
							_tmp53_ = i;
							_tmp54_ = ie;
							if (!(_tmp53_ <= _tmp54_)) {
								break;
							}
							_tmp55_ = tp;
							tp = _tmp55_ << 4;
							_tmp58_ = tp;
							_tmp59_ = ib;
							if (_tmp58_ <= _tmp59_) {
								gint _tmp60_;
								_tmp60_ = tp;
								_tmp57_ = _tmp60_ != BASE;
							} else {
								_tmp57_ = FALSE;
							}
							_tmp61_ = _tmp57_;
							if (_tmp61_) {
								gint _tmp62_;
								gint _tmp63_;
								_tmp62_ = i;
								_tmp63_ = ie;
								_tmp56_ = _tmp62_ < _tmp63_;
							} else {
								_tmp56_ = FALSE;
							}
							_tmp64_ = _tmp56_;
							if (_tmp64_) {
								continue;
							}
							_tmp65_ = z;
							_tmp66_ = tp;
							_tmp67_ = number_multiply_integer (_tmp65_, (gint64) _tmp66_);
							_number_unref0 (z);
							z = _tmp67_;
							tp = 1;
						}
					}
				}
			}
		}
	}
	_tmp68_ = z;
	_tmp69_ = _tmp68_->re_sign;
	self->re_sign = _tmp69_;
	_tmp70_ = z;
	_tmp71_ = _tmp70_->im_sign;
	self->im_sign = _tmp71_;
	_tmp72_ = z;
	_tmp73_ = _tmp72_->re_exponent;
	self->re_exponent = _tmp73_;
	_tmp74_ = z;
	_tmp75_ = _tmp74_->im_exponent;
	self->im_exponent = _tmp75_;
	{
		gint i;
		i = 0;
		{
			gboolean _tmp76_;
			_tmp76_ = TRUE;
			while (TRUE) {
				gboolean _tmp77_;
				gint _tmp79_;
				Number* _tmp80_;
				gint _tmp81_;
				Number* _tmp82_;
				gint _tmp83_;
				gint _tmp84_;
				gint _tmp85_;
				gint _tmp86_;
				Number* _tmp87_;
				gint _tmp88_;
				gint _tmp89_;
				gint _tmp90_;
				_tmp77_ = _tmp76_;
				if (!_tmp77_) {
					gint _tmp78_;
					_tmp78_ = i;
					i = _tmp78_ + 1;
				}
				_tmp76_ = FALSE;
				_tmp79_ = i;
				_tmp80_ = z;
				if (!(_tmp79_ < 1000)) {
					break;
				}
				_tmp81_ = i;
				_tmp82_ = z;
				_tmp83_ = i;
				_tmp84_ = _tmp82_->re_fraction[_tmp83_];
				self->re_fraction[_tmp81_] = _tmp84_;
				_tmp85_ = self->re_fraction[_tmp81_];
				_tmp86_ = i;
				_tmp87_ = z;
				_tmp88_ = i;
				_tmp89_ = _tmp87_->im_fraction[_tmp88_];
				self->im_fraction[_tmp86_] = _tmp89_;
				_tmp90_ = self->im_fraction[_tmp86_];
			}
		}
	}
	_number_unref0 (z);
	return self;
}


Number* number_new_float (gfloat value) {
	return number_construct_float (TYPE_NUMBER, value);
}


Number* number_construct_double (GType object_type, gdouble value) {
	Number* self = NULL;
	Number* _tmp0_;
	Number* z;
	gdouble _tmp1_;
	Number* _tmp72_;
	gint _tmp73_;
	Number* _tmp74_;
	gint _tmp75_;
	Number* _tmp76_;
	gint _tmp77_;
	Number* _tmp78_;
	gint _tmp79_;
	self = (Number*) g_type_create_instance (object_type);
	_tmp0_ = number_new_integer ((gint64) 0);
	z = _tmp0_;
	_tmp1_ = value;
	if (_tmp1_ != ((gdouble) 0)) {
		gdouble dj;
		gdouble _tmp2_;
		gint ie;
		Number* _tmp18_;
		gint _tmp32_ = 0;
		gint ib;
		gint tp;
		gint _tmp33_;
		dj = 0.0;
		_tmp2_ = value;
		if (_tmp2_ < 0.0) {
			Number* _tmp3_;
			gdouble _tmp4_;
			_tmp3_ = z;
			_tmp3_->re_sign = -1;
			_tmp4_ = value;
			dj = -_tmp4_;
		} else {
			gdouble _tmp5_;
			_tmp5_ = value;
			if (_tmp5_ > 0.0) {
				Number* _tmp6_;
				gdouble _tmp7_;
				_tmp6_ = z;
				_tmp6_->re_sign = 1;
				_tmp7_ = value;
				dj = _tmp7_;
			}
		}
		ie = 0;
		{
			gboolean _tmp8_;
			ie = 0;
			_tmp8_ = TRUE;
			while (TRUE) {
				gboolean _tmp9_;
				gdouble _tmp11_;
				gdouble _tmp12_;
				_tmp9_ = _tmp8_;
				if (!_tmp9_) {
					gint _tmp10_;
					_tmp10_ = ie;
					ie = _tmp10_ + 1;
				}
				_tmp8_ = FALSE;
				_tmp11_ = dj;
				if (!(_tmp11_ >= 1.0)) {
					break;
				}
				_tmp12_ = dj;
				dj = _tmp12_ * (1.0 / 16.0);
			}
		}
		{
			gboolean _tmp13_;
			_tmp13_ = TRUE;
			while (TRUE) {
				gboolean _tmp14_;
				gdouble _tmp16_;
				gdouble _tmp17_;
				_tmp14_ = _tmp13_;
				if (!_tmp14_) {
					gint _tmp15_;
					_tmp15_ = ie;
					ie = _tmp15_ - 1;
				}
				_tmp13_ = FALSE;
				_tmp16_ = dj;
				if (!(_tmp16_ < (1.0 / 16.0))) {
					break;
				}
				_tmp17_ = dj;
				dj = _tmp17_ * 16.0;
			}
		}
		_tmp18_ = z;
		_tmp18_->re_exponent = 0;
		{
			gint i;
			i = 0;
			{
				gboolean _tmp19_;
				_tmp19_ = TRUE;
				while (TRUE) {
					gboolean _tmp20_;
					gint _tmp22_;
					gdouble _tmp23_;
					Number* _tmp24_;
					gint _tmp25_;
					gdouble _tmp26_;
					gint _tmp27_;
					gdouble _tmp28_;
					Number* _tmp29_;
					gint _tmp30_;
					gint _tmp31_;
					_tmp20_ = _tmp19_;
					if (!_tmp20_) {
						gint _tmp21_;
						_tmp21_ = i;
						i = _tmp21_ + 1;
					}
					_tmp19_ = FALSE;
					_tmp22_ = i;
					if (!(_tmp22_ < (T + 4))) {
						break;
					}
					_tmp23_ = dj;
					dj = _tmp23_ * ((gdouble) BASE);
					_tmp24_ = z;
					_tmp25_ = i;
					_tmp26_ = dj;
					_tmp24_->re_fraction[_tmp25_] = (gint) _tmp26_;
					_tmp27_ = _tmp24_->re_fraction[_tmp25_];
					_tmp28_ = dj;
					_tmp29_ = z;
					_tmp30_ = i;
					_tmp31_ = _tmp29_->re_fraction[_tmp30_];
					dj = _tmp28_ - ((gdouble) _tmp31_);
				}
			}
		}
		mp_normalize (&z);
		_tmp32_ = MAX ((BASE * 7) * BASE, 32767);
		ib = _tmp32_ / 16;
		tp = 1;
		_tmp33_ = ie;
		if (_tmp33_ < 0) {
			gint _tmp34_;
			gint k;
			_tmp34_ = ie;
			k = -_tmp34_;
			{
				gint i;
				i = 1;
				{
					gboolean _tmp35_;
					_tmp35_ = TRUE;
					while (TRUE) {
						gboolean _tmp36_;
						gint _tmp38_;
						gint _tmp39_;
						gint _tmp40_;
						gboolean _tmp41_ = FALSE;
						gboolean _tmp42_ = FALSE;
						gint _tmp43_;
						gint _tmp44_;
						gboolean _tmp46_;
						gboolean _tmp49_;
						Number* _tmp50_;
						gint _tmp51_;
						Number* _tmp52_ = NULL;
						_tmp36_ = _tmp35_;
						if (!_tmp36_) {
							gint _tmp37_;
							_tmp37_ = i;
							i = _tmp37_ + 1;
						}
						_tmp35_ = FALSE;
						_tmp38_ = i;
						_tmp39_ = k;
						if (!(_tmp38_ <= _tmp39_)) {
							break;
						}
						_tmp40_ = tp;
						tp = _tmp40_ << 4;
						_tmp43_ = tp;
						_tmp44_ = ib;
						if (_tmp43_ <= _tmp44_) {
							gint _tmp45_;
							_tmp45_ = tp;
							_tmp42_ = _tmp45_ != BASE;
						} else {
							_tmp42_ = FALSE;
						}
						_tmp46_ = _tmp42_;
						if (_tmp46_) {
							gint _tmp47_;
							gint _tmp48_;
							_tmp47_ = i;
							_tmp48_ = k;
							_tmp41_ = _tmp47_ < _tmp48_;
						} else {
							_tmp41_ = FALSE;
						}
						_tmp49_ = _tmp41_;
						if (_tmp49_) {
							continue;
						}
						_tmp50_ = z;
						_tmp51_ = tp;
						_tmp52_ = number_divide_integer (_tmp50_, (gint64) _tmp51_);
						_number_unref0 (z);
						z = _tmp52_;
						tp = 1;
					}
				}
			}
		} else {
			gint _tmp53_;
			_tmp53_ = ie;
			if (_tmp53_ > 0) {
				{
					gint i;
					i = 1;
					{
						gboolean _tmp54_;
						_tmp54_ = TRUE;
						while (TRUE) {
							gboolean _tmp55_;
							gint _tmp57_;
							gint _tmp58_;
							gint _tmp59_;
							gboolean _tmp60_ = FALSE;
							gboolean _tmp61_ = FALSE;
							gint _tmp62_;
							gint _tmp63_;
							gboolean _tmp65_;
							gboolean _tmp68_;
							Number* _tmp69_;
							gint _tmp70_;
							Number* _tmp71_ = NULL;
							_tmp55_ = _tmp54_;
							if (!_tmp55_) {
								gint _tmp56_;
								_tmp56_ = i;
								i = _tmp56_ + 1;
							}
							_tmp54_ = FALSE;
							_tmp57_ = i;
							_tmp58_ = ie;
							if (!(_tmp57_ <= _tmp58_)) {
								break;
							}
							_tmp59_ = tp;
							tp = _tmp59_ << 4;
							_tmp62_ = tp;
							_tmp63_ = ib;
							if (_tmp62_ <= _tmp63_) {
								gint _tmp64_;
								_tmp64_ = tp;
								_tmp61_ = _tmp64_ != BASE;
							} else {
								_tmp61_ = FALSE;
							}
							_tmp65_ = _tmp61_;
							if (_tmp65_) {
								gint _tmp66_;
								gint _tmp67_;
								_tmp66_ = i;
								_tmp67_ = ie;
								_tmp60_ = _tmp66_ < _tmp67_;
							} else {
								_tmp60_ = FALSE;
							}
							_tmp68_ = _tmp60_;
							if (_tmp68_) {
								continue;
							}
							_tmp69_ = z;
							_tmp70_ = tp;
							_tmp71_ = number_multiply_integer (_tmp69_, (gint64) _tmp70_);
							_number_unref0 (z);
							z = _tmp71_;
							tp = 1;
						}
					}
				}
			}
		}
	}
	_tmp72_ = z;
	_tmp73_ = _tmp72_->re_sign;
	self->re_sign = _tmp73_;
	_tmp74_ = z;
	_tmp75_ = _tmp74_->im_sign;
	self->im_sign = _tmp75_;
	_tmp76_ = z;
	_tmp77_ = _tmp76_->re_exponent;
	self->re_exponent = _tmp77_;
	_tmp78_ = z;
	_tmp79_ = _tmp78_->im_exponent;
	self->im_exponent = _tmp79_;
	{
		gint i;
		i = 0;
		{
			gboolean _tmp80_;
			_tmp80_ = TRUE;
			while (TRUE) {
				gboolean _tmp81_;
				gint _tmp83_;
				Number* _tmp84_;
				gint _tmp85_;
				Number* _tmp86_;
				gint _tmp87_;
				gint _tmp88_;
				gint _tmp89_;
				gint _tmp90_;
				Number* _tmp91_;
				gint _tmp92_;
				gint _tmp93_;
				gint _tmp94_;
				_tmp81_ = _tmp80_;
				if (!_tmp81_) {
					gint _tmp82_;
					_tmp82_ = i;
					i = _tmp82_ + 1;
				}
				_tmp80_ = FALSE;
				_tmp83_ = i;
				_tmp84_ = z;
				if (!(_tmp83_ < 1000)) {
					break;
				}
				_tmp85_ = i;
				_tmp86_ = z;
				_tmp87_ = i;
				_tmp88_ = _tmp86_->re_fraction[_tmp87_];
				self->re_fraction[_tmp85_] = _tmp88_;
				_tmp89_ = self->re_fraction[_tmp85_];
				_tmp90_ = i;
				_tmp91_ = z;
				_tmp92_ = i;
				_tmp93_ = _tmp91_->im_fraction[_tmp92_];
				self->im_fraction[_tmp90_] = _tmp93_;
				_tmp94_ = self->im_fraction[_tmp90_];
			}
		}
	}
	_number_unref0 (z);
	return self;
}


Number* number_new_double (gdouble value) {
	return number_construct_double (TYPE_NUMBER, value);
}


Number* number_construct_complex (GType object_type, Number* x, Number* y) {
	Number* self = NULL;
	Number* _tmp0_;
	gint _tmp1_;
	Number* _tmp2_;
	gint _tmp3_;
	Number* _tmp13_;
	gint _tmp14_;
	Number* _tmp15_;
	gint _tmp16_;
	g_return_val_if_fail (x != NULL, NULL);
	g_return_val_if_fail (y != NULL, NULL);
	self = (Number*) g_type_create_instance (object_type);
	_tmp0_ = x;
	_tmp1_ = _tmp0_->re_sign;
	self->re_sign = _tmp1_;
	_tmp2_ = x;
	_tmp3_ = _tmp2_->re_exponent;
	self->re_exponent = _tmp3_;
	{
		gint i;
		i = 0;
		{
			gboolean _tmp4_;
			_tmp4_ = TRUE;
			while (TRUE) {
				gboolean _tmp5_;
				gint _tmp7_;
				gint _tmp8_;
				Number* _tmp9_;
				gint _tmp10_;
				gint _tmp11_;
				gint _tmp12_;
				_tmp5_ = _tmp4_;
				if (!_tmp5_) {
					gint _tmp6_;
					_tmp6_ = i;
					i = _tmp6_ + 1;
				}
				_tmp4_ = FALSE;
				_tmp7_ = i;
				if (!(_tmp7_ < 1000)) {
					break;
				}
				_tmp8_ = i;
				_tmp9_ = x;
				_tmp10_ = i;
				_tmp11_ = _tmp9_->re_fraction[_tmp10_];
				self->re_fraction[_tmp8_] = _tmp11_;
				_tmp12_ = self->re_fraction[_tmp8_];
			}
		}
	}
	_tmp13_ = y;
	_tmp14_ = _tmp13_->re_sign;
	self->im_sign = _tmp14_;
	_tmp15_ = y;
	_tmp16_ = _tmp15_->re_exponent;
	self->im_exponent = _tmp16_;
	{
		gint i;
		i = 0;
		{
			gboolean _tmp17_;
			_tmp17_ = TRUE;
			while (TRUE) {
				gboolean _tmp18_;
				gint _tmp20_;
				gint _tmp21_;
				Number* _tmp22_;
				gint _tmp23_;
				gint _tmp24_;
				gint _tmp25_;
				_tmp18_ = _tmp17_;
				if (!_tmp18_) {
					gint _tmp19_;
					_tmp19_ = i;
					i = _tmp19_ + 1;
				}
				_tmp17_ = FALSE;
				_tmp20_ = i;
				if (!(_tmp20_ < 1000)) {
					break;
				}
				_tmp21_ = i;
				_tmp22_ = y;
				_tmp23_ = i;
				_tmp24_ = _tmp22_->re_fraction[_tmp23_];
				self->im_fraction[_tmp21_] = _tmp24_;
				_tmp25_ = self->im_fraction[_tmp21_];
			}
		}
	}
	return self;
}


Number* number_new_complex (Number* x, Number* y) {
	return number_construct_complex (TYPE_NUMBER, x, y);
}


Number* number_construct_polar (GType object_type, Number* r, Number* theta, AngleUnit unit) {
	Number* self = NULL;
	Number* _tmp0_;
	AngleUnit _tmp1_;
	Number* _tmp2_ = NULL;
	Number* x;
	Number* _tmp3_;
	AngleUnit _tmp4_;
	Number* _tmp5_ = NULL;
	Number* y;
	Number* _tmp6_;
	Number* _tmp7_ = NULL;
	Number* _tmp8_;
	Number* _tmp9_;
	Number* _tmp10_ = NULL;
	Number* _tmp11_;
	g_return_val_if_fail (r != NULL, NULL);
	g_return_val_if_fail (theta != NULL, NULL);
	_tmp0_ = theta;
	_tmp1_ = unit;
	_tmp2_ = number_cos (_tmp0_, _tmp1_);
	x = _tmp2_;
	_tmp3_ = theta;
	_tmp4_ = unit;
	_tmp5_ = number_sin (_tmp3_, _tmp4_);
	y = _tmp5_;
	_tmp6_ = r;
	_tmp7_ = number_multiply (x, _tmp6_);
	_tmp8_ = _tmp7_;
	_tmp9_ = r;
	_tmp10_ = number_multiply (y, _tmp9_);
	_tmp11_ = _tmp10_;
	self = (Number*) number_construct_complex (object_type, _tmp8_, _tmp11_);
	_number_unref0 (_tmp11_);
	_number_unref0 (_tmp8_);
	_number_unref0 (y);
	_number_unref0 (x);
	return self;
}


Number* number_new_polar (Number* r, Number* theta, AngleUnit unit) {
	return number_construct_polar (TYPE_NUMBER, r, theta, unit);
}


Number* number_construct_eulers (GType object_type) {
	Number* self = NULL;
	Number* _tmp0_;
	Number* _tmp1_;
	Number* _tmp2_ = NULL;
	Number* _tmp3_;
	Number* z;
	Number* _tmp4_;
	gint _tmp5_;
	Number* _tmp6_;
	gint _tmp7_;
	Number* _tmp8_;
	gint _tmp9_;
	Number* _tmp10_;
	gint _tmp11_;
	self = (Number*) g_type_create_instance (object_type);
	_tmp0_ = number_new_integer ((gint64) 1);
	_tmp1_ = _tmp0_;
	_tmp2_ = number_epowy (_tmp1_);
	_tmp3_ = _tmp2_;
	_number_unref0 (_tmp1_);
	z = _tmp3_;
	_tmp4_ = z;
	_tmp5_ = _tmp4_->re_sign;
	self->re_sign = _tmp5_;
	_tmp6_ = z;
	_tmp7_ = _tmp6_->im_sign;
	self->im_sign = _tmp7_;
	_tmp8_ = z;
	_tmp9_ = _tmp8_->re_exponent;
	self->re_exponent = _tmp9_;
	_tmp10_ = z;
	_tmp11_ = _tmp10_->im_exponent;
	self->im_exponent = _tmp11_;
	{
		gint i;
		i = 0;
		{
			gboolean _tmp12_;
			_tmp12_ = TRUE;
			while (TRUE) {
				gboolean _tmp13_;
				gint _tmp15_;
				Number* _tmp16_;
				gint _tmp17_;
				Number* _tmp18_;
				gint _tmp19_;
				gint _tmp20_;
				gint _tmp21_;
				gint _tmp22_;
				Number* _tmp23_;
				gint _tmp24_;
				gint _tmp25_;
				gint _tmp26_;
				_tmp13_ = _tmp12_;
				if (!_tmp13_) {
					gint _tmp14_;
					_tmp14_ = i;
					i = _tmp14_ + 1;
				}
				_tmp12_ = FALSE;
				_tmp15_ = i;
				_tmp16_ = z;
				if (!(_tmp15_ < 1000)) {
					break;
				}
				_tmp17_ = i;
				_tmp18_ = z;
				_tmp19_ = i;
				_tmp20_ = _tmp18_->re_fraction[_tmp19_];
				self->re_fraction[_tmp17_] = _tmp20_;
				_tmp21_ = self->re_fraction[_tmp17_];
				_tmp22_ = i;
				_tmp23_ = z;
				_tmp24_ = i;
				_tmp25_ = _tmp23_->im_fraction[_tmp24_];
				self->im_fraction[_tmp22_] = _tmp25_;
				_tmp26_ = self->im_fraction[_tmp22_];
			}
		}
	}
	_number_unref0 (z);
	return self;
}


Number* number_new_eulers (void) {
	return number_construct_eulers (TYPE_NUMBER);
}


Number* number_construct_i (GType object_type) {
	Number* self = NULL;
	gint _tmp0_;
	self = (Number*) g_type_create_instance (object_type);
	self->im_sign = 1;
	self->im_exponent = 1;
	self->im_fraction[0] = 1;
	_tmp0_ = self->im_fraction[0];
	return self;
}


Number* number_new_i (void) {
	return number_construct_i (TYPE_NUMBER);
}


Number* number_construct_pi (GType object_type) {
	Number* self = NULL;
	self = (Number*) number_construct_double (object_type, G_PI);
	return self;
}


Number* number_new_pi (void) {
	return number_construct_pi (TYPE_NUMBER);
}


Number* number_construct_random (GType object_type) {
	Number* self = NULL;
	gdouble _tmp0_ = 0.0;
	_tmp0_ = g_random_double ();
	self = (Number*) number_construct_double (object_type, _tmp0_);
	return self;
}


Number* number_new_random (void) {
	return number_construct_random (TYPE_NUMBER);
}


gint64 number_to_integer (Number* self) {
	gint64 result = 0LL;
	gint64 z;
	gboolean _tmp0_ = FALSE;
	gint _tmp1_;
	gboolean _tmp3_;
	gint64 _tmp15_;
	gint64 v;
	gint64 _tmp27_;
	gint _tmp28_;
	gint64 _tmp29_;
	g_return_val_if_fail (self != NULL, 0LL);
	z = (gint64) 0;
	_tmp1_ = self->re_sign;
	if (_tmp1_ == 0) {
		_tmp0_ = TRUE;
	} else {
		gint _tmp2_;
		_tmp2_ = self->re_exponent;
		_tmp0_ = _tmp2_ <= 0;
	}
	_tmp3_ = _tmp0_;
	if (_tmp3_) {
		result = (gint64) 0;
		return result;
	}
	{
		gint i;
		i = 0;
		{
			gboolean _tmp4_;
			_tmp4_ = TRUE;
			while (TRUE) {
				gboolean _tmp5_;
				gint _tmp7_;
				gint _tmp8_;
				gint64 _tmp9_;
				gint64 t;
				gint64 _tmp10_;
				gint _tmp11_;
				gint _tmp12_;
				gint64 _tmp13_;
				gint64 _tmp14_;
				_tmp5_ = _tmp4_;
				if (!_tmp5_) {
					gint _tmp6_;
					_tmp6_ = i;
					i = _tmp6_ + 1;
				}
				_tmp4_ = FALSE;
				_tmp7_ = i;
				_tmp8_ = self->re_exponent;
				if (!(_tmp7_ < _tmp8_)) {
					break;
				}
				_tmp9_ = z;
				t = _tmp9_;
				_tmp10_ = z;
				_tmp11_ = i;
				_tmp12_ = self->re_fraction[_tmp11_];
				z = (_tmp10_ * BASE) + _tmp12_;
				_tmp13_ = z;
				_tmp14_ = t;
				if (_tmp13_ <= _tmp14_) {
					result = (gint64) 0;
					return result;
				}
			}
		}
	}
	_tmp15_ = z;
	v = _tmp15_;
	{
		gint _tmp16_;
		gint i;
		_tmp16_ = self->re_exponent;
		i = _tmp16_ - 1;
		{
			gboolean _tmp17_;
			_tmp17_ = TRUE;
			while (TRUE) {
				gboolean _tmp18_;
				gint _tmp20_;
				gint64 _tmp21_;
				gint64 _tmp22_;
				gint64 digit;
				gint _tmp23_;
				gint _tmp24_;
				gint64 _tmp25_;
				gint64 _tmp26_;
				_tmp18_ = _tmp17_;
				if (!_tmp18_) {
					gint _tmp19_;
					_tmp19_ = i;
					i = _tmp19_ - 1;
				}
				_tmp17_ = FALSE;
				_tmp20_ = i;
				if (!(_tmp20_ >= 0)) {
					break;
				}
				_tmp21_ = v;
				_tmp22_ = v;
				digit = _tmp21_ - ((_tmp22_ / BASE) * BASE);
				_tmp23_ = i;
				_tmp24_ = self->re_fraction[_tmp23_];
				_tmp25_ = digit;
				if (((gint64) _tmp24_) != _tmp25_) {
					result = (gint64) 0;
					return result;
				}
				_tmp26_ = v;
				v = _tmp26_ / BASE;
			}
		}
	}
	_tmp27_ = v;
	if (_tmp27_ != ((gint64) 0)) {
		result = (gint64) 0;
		return result;
	}
	_tmp28_ = self->re_sign;
	_tmp29_ = z;
	result = _tmp28_ * _tmp29_;
	return result;
}


guint64 number_to_unsigned_integer (Number* self) {
	guint64 result = 0ULL;
	gboolean _tmp0_ = FALSE;
	gint _tmp1_;
	gboolean _tmp3_;
	guint64 z;
	guint64 _tmp15_;
	guint64 v;
	guint64 _tmp27_;
	g_return_val_if_fail (self != NULL, 0ULL);
	_tmp1_ = self->re_sign;
	if (_tmp1_ <= 0) {
		_tmp0_ = TRUE;
	} else {
		gint _tmp2_;
		_tmp2_ = self->re_exponent;
		_tmp0_ = _tmp2_ <= 0;
	}
	_tmp3_ = _tmp0_;
	if (_tmp3_) {
		result = (guint64) 0;
		return result;
	}
	z = (guint64) 0;
	{
		gint i;
		i = 0;
		{
			gboolean _tmp4_;
			_tmp4_ = TRUE;
			while (TRUE) {
				gboolean _tmp5_;
				gint _tmp7_;
				gint _tmp8_;
				guint64 _tmp9_;
				guint64 t;
				guint64 _tmp10_;
				gint _tmp11_;
				gint _tmp12_;
				guint64 _tmp13_;
				guint64 _tmp14_;
				_tmp5_ = _tmp4_;
				if (!_tmp5_) {
					gint _tmp6_;
					_tmp6_ = i;
					i = _tmp6_ + 1;
				}
				_tmp4_ = FALSE;
				_tmp7_ = i;
				_tmp8_ = self->re_exponent;
				if (!(_tmp7_ < _tmp8_)) {
					break;
				}
				_tmp9_ = z;
				t = _tmp9_;
				_tmp10_ = z;
				_tmp11_ = i;
				_tmp12_ = self->re_fraction[_tmp11_];
				z = (_tmp10_ * BASE) + _tmp12_;
				_tmp13_ = z;
				_tmp14_ = t;
				if (_tmp13_ <= _tmp14_) {
					result = (guint64) 0;
					return result;
				}
			}
		}
	}
	_tmp15_ = z;
	v = _tmp15_;
	{
		gint _tmp16_;
		gint i;
		_tmp16_ = self->re_exponent;
		i = _tmp16_ - 1;
		{
			gboolean _tmp17_;
			_tmp17_ = TRUE;
			while (TRUE) {
				gboolean _tmp18_;
				gint _tmp20_;
				guint64 _tmp21_;
				guint64 _tmp22_;
				guint64 digit;
				gint _tmp23_;
				gint _tmp24_;
				guint64 _tmp25_;
				guint64 _tmp26_;
				_tmp18_ = _tmp17_;
				if (!_tmp18_) {
					gint _tmp19_;
					_tmp19_ = i;
					i = _tmp19_ - 1;
				}
				_tmp17_ = FALSE;
				_tmp20_ = i;
				if (!(_tmp20_ >= 0)) {
					break;
				}
				_tmp21_ = v;
				_tmp22_ = v;
				digit = ((guint64) _tmp21_) - ((_tmp22_ / BASE) * BASE);
				_tmp23_ = i;
				_tmp24_ = self->re_fraction[_tmp23_];
				_tmp25_ = digit;
				if (((guint64) _tmp24_) != _tmp25_) {
					result = (guint64) 0;
					return result;
				}
				_tmp26_ = v;
				v = _tmp26_ / BASE;
			}
		}
	}
	_tmp27_ = v;
	if (_tmp27_ != ((guint64) 0)) {
		result = (guint64) 0;
		return result;
	}
	result = z;
	return result;
}


gfloat number_to_float (Number* self) {
	gfloat result = 0.0F;
	gboolean _tmp0_ = FALSE;
	gfloat z;
	gint _tmp13_;
	g_return_val_if_fail (self != NULL, 0.0F);
	_tmp0_ = number_is_zero (self);
	if (_tmp0_) {
		result = 0.f;
		return result;
	}
	z = 0.f;
	{
		gint i;
		i = 0;
		{
			gboolean _tmp1_;
			_tmp1_ = TRUE;
			while (TRUE) {
				gboolean _tmp2_;
				gint _tmp4_;
				gint _tmp5_;
				gint _tmp6_;
				_tmp2_ = _tmp1_;
				if (!_tmp2_) {
					gint _tmp3_;
					_tmp3_ = i;
					i = _tmp3_ + 1;
				}
				_tmp1_ = FALSE;
				_tmp4_ = i;
				if (!(_tmp4_ < T)) {
					break;
				}
				_tmp5_ = i;
				_tmp6_ = self->re_fraction[_tmp5_];
				if (_tmp6_ != 0) {
					gfloat _tmp7_;
					gint _tmp8_;
					gint _tmp9_;
					gint _tmp10_;
					gint _tmp11_;
					gfloat _tmp12_ = 0.0F;
					_tmp7_ = z;
					_tmp8_ = i;
					_tmp9_ = self->re_fraction[_tmp8_];
					_tmp10_ = self->re_exponent;
					_tmp11_ = i;
					_tmp12_ = powf ((gfloat) BASE, (gfloat) ((_tmp10_ - _tmp11_) - 1));
					z = _tmp7_ + (_tmp9_ * _tmp12_);
				}
			}
		}
	}
	_tmp13_ = self->re_sign;
	if (_tmp13_ < 0) {
		gfloat _tmp14_;
		_tmp14_ = z;
		result = -_tmp14_;
		return result;
	} else {
		result = z;
		return result;
	}
}


gdouble number_to_double (Number* self) {
	gdouble result = 0.0;
	gboolean _tmp0_ = FALSE;
	gdouble z;
	gint _tmp13_;
	g_return_val_if_fail (self != NULL, 0.0);
	_tmp0_ = number_is_zero (self);
	if (_tmp0_) {
		result = 0.;
		return result;
	}
	z = 0.;
	{
		gint i;
		i = 0;
		{
			gboolean _tmp1_;
			_tmp1_ = TRUE;
			while (TRUE) {
				gboolean _tmp2_;
				gint _tmp4_;
				gint _tmp5_;
				gint _tmp6_;
				_tmp2_ = _tmp1_;
				if (!_tmp2_) {
					gint _tmp3_;
					_tmp3_ = i;
					i = _tmp3_ + 1;
				}
				_tmp1_ = FALSE;
				_tmp4_ = i;
				if (!(_tmp4_ < T)) {
					break;
				}
				_tmp5_ = i;
				_tmp6_ = self->re_fraction[_tmp5_];
				if (_tmp6_ != 0) {
					gdouble _tmp7_;
					gint _tmp8_;
					gint _tmp9_;
					gint _tmp10_;
					gint _tmp11_;
					gdouble _tmp12_ = 0.0;
					_tmp7_ = z;
					_tmp8_ = i;
					_tmp9_ = self->re_fraction[_tmp8_];
					_tmp10_ = self->re_exponent;
					_tmp11_ = i;
					_tmp12_ = pow ((gdouble) BASE, (gdouble) ((_tmp10_ - _tmp11_) - 1));
					z = _tmp7_ + (_tmp9_ * _tmp12_);
				}
			}
		}
	}
	_tmp13_ = self->re_sign;
	if (_tmp13_ < 0) {
		gdouble _tmp14_;
		_tmp14_ = z;
		result = -_tmp14_;
		return result;
	} else {
		result = z;
		return result;
	}
}


gboolean number_is_zero (Number* self) {
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	gint _tmp1_;
	gboolean _tmp3_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp1_ = self->re_sign;
	if (_tmp1_ == 0) {
		gint _tmp2_;
		_tmp2_ = self->im_sign;
		_tmp0_ = _tmp2_ == 0;
	} else {
		_tmp0_ = FALSE;
	}
	_tmp3_ = _tmp0_;
	result = _tmp3_;
	return result;
}


gboolean number_is_negative (Number* self) {
	gboolean result = FALSE;
	gint _tmp0_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->re_sign;
	result = _tmp0_ < 0;
	return result;
}


gboolean number_is_integer (Number* self) {
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	Number* _tmp1_;
	Number* t3;
	Number* _tmp2_;
	Number* _tmp3_ = NULL;
	Number* t1;
	Number* _tmp4_;
	Number* _tmp5_;
	Number* _tmp6_ = NULL;
	Number* _tmp7_;
	Number* _tmp8_ = NULL;
	Number* t2;
	Number* _tmp9_;
	Number* _tmp10_;
	gboolean _tmp11_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = number_is_complex (self);
	if (_tmp0_) {
		result = FALSE;
		return result;
	}
	_tmp1_ = number_new_integer ((gint64) 10000);
	t3 = _tmp1_;
	_tmp2_ = t3;
	_tmp3_ = number_multiply (self, _tmp2_);
	t1 = _tmp3_;
	_tmp4_ = t1;
	_tmp5_ = t3;
	_tmp6_ = number_divide (_tmp4_, _tmp5_);
	_number_unref0 (t1);
	t1 = _tmp6_;
	_tmp7_ = t1;
	_tmp8_ = number_floor (_tmp7_);
	t2 = _tmp8_;
	_tmp9_ = t1;
	_tmp10_ = t2;
	_tmp11_ = number_equals (_tmp9_, _tmp10_);
	result = _tmp11_;
	_number_unref0 (t2);
	_number_unref0 (t1);
	_number_unref0 (t3);
	return result;
}


gboolean number_is_positive_integer (Number* self) {
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = number_is_complex (self);
	if (_tmp0_) {
		result = FALSE;
		return result;
	} else {
		gboolean _tmp1_ = FALSE;
		gint _tmp2_;
		gboolean _tmp4_;
		_tmp2_ = self->re_sign;
		if (_tmp2_ >= 0) {
			gboolean _tmp3_ = FALSE;
			_tmp3_ = number_is_integer (self);
			_tmp1_ = _tmp3_;
		} else {
			_tmp1_ = FALSE;
		}
		_tmp4_ = _tmp1_;
		result = _tmp4_;
		return result;
	}
}


gboolean number_is_natural (Number* self) {
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = number_is_complex (self);
	if (_tmp0_) {
		result = FALSE;
		return result;
	} else {
		gboolean _tmp1_ = FALSE;
		gint _tmp2_;
		gboolean _tmp4_;
		_tmp2_ = self->re_sign;
		if (_tmp2_ > 0) {
			gboolean _tmp3_ = FALSE;
			_tmp3_ = number_is_integer (self);
			_tmp1_ = _tmp3_;
		} else {
			_tmp1_ = FALSE;
		}
		_tmp4_ = _tmp1_;
		result = _tmp4_;
		return result;
	}
}


gboolean number_is_complex (Number* self) {
	gboolean result = FALSE;
	gint _tmp0_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->im_sign;
	result = _tmp0_ != 0;
	return result;
}


gboolean number_equals (Number* self, Number* y) {
	gboolean result = FALSE;
	Number* _tmp0_;
	gint _tmp1_ = 0;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (y != NULL, FALSE);
	_tmp0_ = y;
	_tmp1_ = number_compare (self, _tmp0_);
	result = _tmp1_ == 0;
	return result;
}


gint number_compare (Number* self, Number* y) {
	gint result = 0;
	gint _tmp0_;
	Number* _tmp1_;
	gint _tmp2_;
	gboolean _tmp6_ = FALSE;
	gint _tmp7_;
	Number* _tmp8_;
	gint _tmp9_;
	g_return_val_if_fail (self != NULL, 0);
	g_return_val_if_fail (y != NULL, 0);
	_tmp0_ = self->re_sign;
	_tmp1_ = y;
	_tmp2_ = _tmp1_->re_sign;
	if (_tmp0_ != _tmp2_) {
		gint _tmp3_;
		Number* _tmp4_;
		gint _tmp5_;
		_tmp3_ = self->re_sign;
		_tmp4_ = y;
		_tmp5_ = _tmp4_->re_sign;
		if (_tmp3_ > _tmp5_) {
			result = 1;
			return result;
		} else {
			result = -1;
			return result;
		}
	}
	_tmp6_ = number_is_zero (self);
	if (_tmp6_) {
		result = 0;
		return result;
	}
	_tmp7_ = self->re_exponent;
	_tmp8_ = y;
	_tmp9_ = _tmp8_->re_exponent;
	if (_tmp7_ != _tmp9_) {
		gint _tmp10_;
		Number* _tmp11_;
		gint _tmp12_;
		_tmp10_ = self->re_exponent;
		_tmp11_ = y;
		_tmp12_ = _tmp11_->re_exponent;
		if (_tmp10_ > _tmp12_) {
			gint _tmp13_;
			_tmp13_ = self->re_sign;
			result = _tmp13_;
			return result;
		} else {
			gint _tmp14_;
			_tmp14_ = self->re_sign;
			result = -_tmp14_;
			return result;
		}
	}
	{
		gint i;
		i = 0;
		{
			gboolean _tmp15_;
			_tmp15_ = TRUE;
			while (TRUE) {
				gboolean _tmp16_;
				gint _tmp18_;
				gint _tmp19_;
				gint _tmp20_;
				Number* _tmp21_;
				gint _tmp22_;
				gint _tmp23_;
				gint _tmp24_;
				gint _tmp25_;
				Number* _tmp26_;
				gint _tmp27_;
				gint _tmp28_;
				_tmp16_ = _tmp15_;
				if (!_tmp16_) {
					gint _tmp17_;
					_tmp17_ = i;
					i = _tmp17_ + 1;
				}
				_tmp15_ = FALSE;
				_tmp18_ = i;
				if (!(_tmp18_ < SIZE)) {
					break;
				}
				_tmp19_ = i;
				_tmp20_ = self->re_fraction[_tmp19_];
				_tmp21_ = y;
				_tmp22_ = i;
				_tmp23_ = _tmp21_->re_fraction[_tmp22_];
				if (_tmp20_ == _tmp23_) {
					continue;
				}
				_tmp24_ = i;
				_tmp25_ = self->re_fraction[_tmp24_];
				_tmp26_ = y;
				_tmp27_ = i;
				_tmp28_ = _tmp26_->re_fraction[_tmp27_];
				if (_tmp25_ > _tmp28_) {
					gint _tmp29_;
					_tmp29_ = self->re_sign;
					result = _tmp29_;
					return result;
				} else {
					gint _tmp30_;
					_tmp30_ = self->re_sign;
					result = -_tmp30_;
					return result;
				}
			}
		}
	}
	result = 0;
	return result;
}


Number* number_sgn (Number* self) {
	Number* result = NULL;
	gboolean _tmp0_ = FALSE;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = number_is_zero (self);
	if (_tmp0_) {
		Number* _tmp1_;
		_tmp1_ = number_new_integer ((gint64) 0);
		result = _tmp1_;
		return result;
	} else {
		gboolean _tmp2_ = FALSE;
		_tmp2_ = number_is_negative (self);
		if (_tmp2_) {
			Number* _tmp3_;
			_tmp3_ = number_new_integer ((gint64) (-1));
			result = _tmp3_;
			return result;
		} else {
			Number* _tmp4_;
			_tmp4_ = number_new_integer ((gint64) 1);
			result = _tmp4_;
			return result;
		}
	}
}


Number* number_invert_sign (Number* self) {
	Number* result = NULL;
	Number* _tmp0_ = NULL;
	Number* z;
	gint _tmp1_;
	gint _tmp2_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = number_copy (self);
	z = _tmp0_;
	_tmp1_ = z->re_sign;
	z->re_sign = -_tmp1_;
	_tmp2_ = z->im_sign;
	z->im_sign = -_tmp2_;
	result = z;
	return result;
}


Number* number_abs (Number* self) {
	Number* result = NULL;
	gboolean _tmp0_ = FALSE;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = number_is_complex (self);
	if (_tmp0_) {
		Number* _tmp1_ = NULL;
		Number* x_real;
		Number* _tmp2_ = NULL;
		Number* x_im;
		Number* _tmp3_;
		Number* _tmp4_;
		Number* _tmp5_ = NULL;
		Number* _tmp6_;
		Number* _tmp7_;
		Number* _tmp8_ = NULL;
		Number* _tmp9_;
		Number* _tmp10_;
		Number* _tmp11_ = NULL;
		Number* z;
		Number* _tmp12_;
		Number* _tmp13_ = NULL;
		_tmp1_ = number_real_component (self);
		x_real = _tmp1_;
		_tmp2_ = number_imaginary_component (self);
		x_im = _tmp2_;
		_tmp3_ = x_real;
		_tmp4_ = x_real;
		_tmp5_ = number_multiply (_tmp3_, _tmp4_);
		_number_unref0 (x_real);
		x_real = _tmp5_;
		_tmp6_ = x_im;
		_tmp7_ = x_im;
		_tmp8_ = number_multiply (_tmp6_, _tmp7_);
		_number_unref0 (x_im);
		x_im = _tmp8_;
		_tmp9_ = x_real;
		_tmp10_ = x_im;
		_tmp11_ = number_add (_tmp9_, _tmp10_);
		z = _tmp11_;
		_tmp12_ = z;
		_tmp13_ = number_root (_tmp12_, (gint64) 2);
		result = _tmp13_;
		_number_unref0 (z);
		_number_unref0 (x_im);
		_number_unref0 (x_real);
		return result;
	} else {
		Number* _tmp14_ = NULL;
		Number* z;
		Number* _tmp15_;
		gint _tmp16_;
		_tmp14_ = number_copy (self);
		z = _tmp14_;
		_tmp15_ = z;
		_tmp16_ = _tmp15_->re_sign;
		if (_tmp16_ < 0) {
			Number* _tmp17_;
			Number* _tmp18_;
			gint _tmp19_;
			_tmp17_ = z;
			_tmp18_ = z;
			_tmp19_ = _tmp18_->re_sign;
			_tmp17_->re_sign = -_tmp19_;
		}
		result = z;
		return result;
	}
}


static gpointer _number_ref0 (gpointer self) {
	return self ? number_ref (self) : NULL;
}


Number* number_arg (Number* self, AngleUnit unit) {
	Number* result = NULL;
	gboolean _tmp0_ = FALSE;
	Number* _tmp3_ = NULL;
	Number* x_real;
	Number* _tmp4_ = NULL;
	Number* x_im;
	Number* _tmp5_;
	Number* pi;
	Number* z = NULL;
	Number* _tmp6_;
	gboolean _tmp7_ = FALSE;
	Number* _tmp41_;
	AngleUnit _tmp42_;
	Number* _tmp43_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = number_is_zero (self);
	if (_tmp0_) {
		const gchar* _tmp1_ = NULL;
		Number* _tmp2_;
		_tmp1_ = _ ("Argument not defined for zero");
		mperr (_tmp1_);
		_tmp2_ = number_new_integer ((gint64) 0);
		result = _tmp2_;
		return result;
	}
	_tmp3_ = number_real_component (self);
	x_real = _tmp3_;
	_tmp4_ = number_imaginary_component (self);
	x_im = _tmp4_;
	_tmp5_ = number_new_pi ();
	pi = _tmp5_;
	_tmp6_ = x_im;
	_tmp7_ = number_is_zero (_tmp6_);
	if (_tmp7_) {
		Number* _tmp8_;
		gboolean _tmp9_ = FALSE;
		_tmp8_ = x_real;
		_tmp9_ = number_is_negative (_tmp8_);
		if (_tmp9_) {
			Number* _tmp10_;
			Number* _tmp11_;
			_tmp10_ = pi;
			_tmp11_ = _number_ref0 (_tmp10_);
			_number_unref0 (z);
			z = _tmp11_;
		} else {
			Number* _tmp12_;
			_tmp12_ = number_new_integer ((gint64) 0);
			result = _tmp12_;
			_number_unref0 (z);
			_number_unref0 (pi);
			_number_unref0 (x_im);
			_number_unref0 (x_real);
			return result;
		}
	} else {
		Number* _tmp13_;
		gboolean _tmp14_ = FALSE;
		_tmp13_ = x_real;
		_tmp14_ = number_is_zero (_tmp13_);
		if (_tmp14_) {
			Number* _tmp15_;
			gboolean _tmp16_ = FALSE;
			_tmp15_ = x_im;
			_tmp16_ = number_is_negative (_tmp15_);
			if (_tmp16_) {
				Number* _tmp17_;
				Number* _tmp18_ = NULL;
				_tmp17_ = pi;
				_tmp18_ = number_divide_integer (_tmp17_, (gint64) (-2));
				_number_unref0 (z);
				z = _tmp18_;
			} else {
				Number* _tmp19_;
				Number* _tmp20_ = NULL;
				_tmp19_ = pi;
				_tmp20_ = number_divide_integer (_tmp19_, (gint64) 2);
				_number_unref0 (z);
				z = _tmp20_;
			}
		} else {
			Number* _tmp21_;
			gboolean _tmp22_ = FALSE;
			_tmp21_ = x_real;
			_tmp22_ = number_is_negative (_tmp21_);
			if (_tmp22_) {
				Number* _tmp23_;
				Number* _tmp24_;
				Number* _tmp25_ = NULL;
				Number* _tmp26_;
				Number* _tmp27_ = NULL;
				Number* _tmp28_;
				gboolean _tmp29_ = FALSE;
				_tmp23_ = x_im;
				_tmp24_ = x_real;
				_tmp25_ = number_divide (_tmp23_, _tmp24_);
				_number_unref0 (z);
				z = _tmp25_;
				_tmp26_ = z;
				_tmp27_ = number_atan (_tmp26_, ANGLE_UNIT_RADIANS);
				_number_unref0 (z);
				z = _tmp27_;
				_tmp28_ = x_im;
				_tmp29_ = number_is_negative (_tmp28_);
				if (_tmp29_) {
					Number* _tmp30_;
					Number* _tmp31_;
					Number* _tmp32_ = NULL;
					_tmp30_ = z;
					_tmp31_ = pi;
					_tmp32_ = number_subtract (_tmp30_, _tmp31_);
					_number_unref0 (z);
					z = _tmp32_;
				} else {
					Number* _tmp33_;
					Number* _tmp34_;
					Number* _tmp35_ = NULL;
					_tmp33_ = z;
					_tmp34_ = pi;
					_tmp35_ = number_add (_tmp33_, _tmp34_);
					_number_unref0 (z);
					z = _tmp35_;
				}
			} else {
				Number* _tmp36_;
				Number* _tmp37_;
				Number* _tmp38_ = NULL;
				Number* _tmp39_;
				Number* _tmp40_ = NULL;
				_tmp36_ = x_im;
				_tmp37_ = x_real;
				_tmp38_ = number_divide (_tmp36_, _tmp37_);
				_number_unref0 (z);
				z = _tmp38_;
				_tmp39_ = z;
				_tmp40_ = number_atan (_tmp39_, ANGLE_UNIT_RADIANS);
				_number_unref0 (z);
				z = _tmp40_;
			}
		}
	}
	_tmp41_ = z;
	_tmp42_ = unit;
	_tmp43_ = number_from_radians (_tmp41_, _tmp42_);
	result = _tmp43_;
	_number_unref0 (z);
	_number_unref0 (pi);
	_number_unref0 (x_im);
	_number_unref0 (x_real);
	return result;
}


Number* number_conjugate (Number* self) {
	Number* result = NULL;
	Number* _tmp0_ = NULL;
	Number* z;
	gint _tmp1_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = number_copy (self);
	z = _tmp0_;
	_tmp1_ = z->im_sign;
	z->im_sign = -_tmp1_;
	result = z;
	return result;
}


Number* number_real_component (Number* self) {
	Number* result = NULL;
	Number* _tmp0_ = NULL;
	Number* z;
	Number* _tmp1_;
	Number* _tmp2_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = number_copy (self);
	z = _tmp0_;
	_tmp1_ = z;
	_tmp1_->im_sign = 0;
	_tmp2_ = z;
	_tmp2_->im_exponent = 0;
	{
		gint i;
		i = 0;
		{
			gboolean _tmp3_;
			_tmp3_ = TRUE;
			while (TRUE) {
				gboolean _tmp4_;
				gint _tmp6_;
				Number* _tmp7_;
				Number* _tmp8_;
				gint _tmp9_;
				gint _tmp10_;
				_tmp4_ = _tmp3_;
				if (!_tmp4_) {
					gint _tmp5_;
					_tmp5_ = i;
					i = _tmp5_ + 1;
				}
				_tmp3_ = FALSE;
				_tmp6_ = i;
				_tmp7_ = z;
				if (!(_tmp6_ < 1000)) {
					break;
				}
				_tmp8_ = z;
				_tmp9_ = i;
				_tmp8_->im_fraction[_tmp9_] = 0;
				_tmp10_ = _tmp8_->im_fraction[_tmp9_];
			}
		}
	}
	result = z;
	return result;
}


Number* number_imaginary_component (Number* self) {
	Number* result = NULL;
	Number* _tmp0_;
	Number* z;
	Number* _tmp1_;
	gint _tmp2_;
	Number* _tmp3_;
	gint _tmp4_;
	Number* _tmp15_;
	Number* _tmp16_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = number_new ();
	z = _tmp0_;
	_tmp1_ = z;
	_tmp2_ = self->im_sign;
	_tmp1_->re_sign = _tmp2_;
	_tmp3_ = z;
	_tmp4_ = self->im_exponent;
	_tmp3_->re_exponent = _tmp4_;
	{
		gint i;
		i = 0;
		{
			gboolean _tmp5_;
			_tmp5_ = TRUE;
			while (TRUE) {
				gboolean _tmp6_;
				gint _tmp8_;
				Number* _tmp9_;
				Number* _tmp10_;
				gint _tmp11_;
				gint _tmp12_;
				gint _tmp13_;
				gint _tmp14_;
				_tmp6_ = _tmp5_;
				if (!_tmp6_) {
					gint _tmp7_;
					_tmp7_ = i;
					i = _tmp7_ + 1;
				}
				_tmp5_ = FALSE;
				_tmp8_ = i;
				_tmp9_ = z;
				if (!(_tmp8_ < 1000)) {
					break;
				}
				_tmp10_ = z;
				_tmp11_ = i;
				_tmp12_ = i;
				_tmp13_ = self->im_fraction[_tmp12_];
				_tmp10_->re_fraction[_tmp11_] = _tmp13_;
				_tmp14_ = _tmp10_->re_fraction[_tmp11_];
			}
		}
	}
	_tmp15_ = z;
	_tmp15_->im_sign = 0;
	_tmp16_ = z;
	_tmp16_->im_exponent = 0;
	{
		gint i;
		i = 0;
		{
			gboolean _tmp17_;
			_tmp17_ = TRUE;
			while (TRUE) {
				gboolean _tmp18_;
				gint _tmp20_;
				Number* _tmp21_;
				Number* _tmp22_;
				gint _tmp23_;
				gint _tmp24_;
				_tmp18_ = _tmp17_;
				if (!_tmp18_) {
					gint _tmp19_;
					_tmp19_ = i;
					i = _tmp19_ + 1;
				}
				_tmp17_ = FALSE;
				_tmp20_ = i;
				_tmp21_ = z;
				if (!(_tmp20_ < 1000)) {
					break;
				}
				_tmp22_ = z;
				_tmp23_ = i;
				_tmp22_->im_fraction[_tmp23_] = 0;
				_tmp24_ = _tmp22_->im_fraction[_tmp23_];
			}
		}
	}
	result = z;
	return result;
}


Number* number_integer_component (Number* self) {
	Number* result = NULL;
	Number* _tmp0_ = NULL;
	Number* z;
	Number* _tmp10_;
	Number* _tmp11_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = number_copy (self);
	z = _tmp0_;
	{
		Number* _tmp1_;
		gint _tmp2_;
		gint i;
		_tmp1_ = z;
		_tmp2_ = _tmp1_->re_exponent;
		i = _tmp2_;
		{
			gboolean _tmp3_;
			_tmp3_ = TRUE;
			while (TRUE) {
				gboolean _tmp4_;
				gint _tmp6_;
				Number* _tmp7_;
				gint _tmp8_;
				gint _tmp9_;
				_tmp4_ = _tmp3_;
				if (!_tmp4_) {
					gint _tmp5_;
					_tmp5_ = i;
					i = _tmp5_ + 1;
				}
				_tmp3_ = FALSE;
				_tmp6_ = i;
				if (!(_tmp6_ < SIZE)) {
					break;
				}
				_tmp7_ = z;
				_tmp8_ = i;
				_tmp7_->re_fraction[_tmp8_] = 0;
				_tmp9_ = _tmp7_->re_fraction[_tmp8_];
			}
		}
	}
	_tmp10_ = z;
	_tmp10_->im_sign = 0;
	_tmp11_ = z;
	_tmp11_->im_exponent = 0;
	{
		gint i;
		i = 0;
		{
			gboolean _tmp12_;
			_tmp12_ = TRUE;
			while (TRUE) {
				gboolean _tmp13_;
				gint _tmp15_;
				Number* _tmp16_;
				Number* _tmp17_;
				gint _tmp18_;
				gint _tmp19_;
				_tmp13_ = _tmp12_;
				if (!_tmp13_) {
					gint _tmp14_;
					_tmp14_ = i;
					i = _tmp14_ + 1;
				}
				_tmp12_ = FALSE;
				_tmp15_ = i;
				_tmp16_ = z;
				if (!(_tmp15_ < 1000)) {
					break;
				}
				_tmp17_ = z;
				_tmp18_ = i;
				_tmp17_->im_fraction[_tmp18_] = 0;
				_tmp19_ = _tmp17_->im_fraction[_tmp18_];
			}
		}
	}
	result = z;
	return result;
}


Number* number_fractional_component (Number* self) {
	Number* result = NULL;
	gboolean _tmp0_ = FALSE;
	gint _tmp2_;
	gint _tmp4_;
	gint shift;
	Number* _tmp15_;
	Number* z;
	Number* _tmp16_;
	gint _tmp17_;
	Number* _tmp18_;
	gint _tmp19_;
	gint _tmp20_;
	Number* _tmp36_;
	gint _tmp37_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = number_is_zero (self);
	if (_tmp0_) {
		Number* _tmp1_;
		_tmp1_ = number_new_integer ((gint64) 0);
		result = _tmp1_;
		return result;
	}
	_tmp2_ = self->re_exponent;
	if (_tmp2_ <= 0) {
		Number* _tmp3_;
		_tmp3_ = _number_ref0 (self);
		result = _tmp3_;
		return result;
	}
	_tmp4_ = self->re_exponent;
	shift = _tmp4_;
	{
		gint _tmp5_;
		gint i;
		_tmp5_ = shift;
		i = _tmp5_;
		{
			gboolean _tmp6_;
			_tmp6_ = TRUE;
			while (TRUE) {
				gboolean _tmp7_;
				gboolean _tmp9_ = FALSE;
				gint _tmp10_;
				gboolean _tmp13_;
				gint _tmp14_;
				_tmp7_ = _tmp6_;
				if (!_tmp7_) {
					gint _tmp8_;
					_tmp8_ = i;
					i = _tmp8_ + 1;
				}
				_tmp6_ = FALSE;
				_tmp10_ = i;
				if (_tmp10_ < SIZE) {
					gint _tmp11_;
					gint _tmp12_;
					_tmp11_ = i;
					_tmp12_ = self->re_fraction[_tmp11_];
					_tmp9_ = _tmp12_ == 0;
				} else {
					_tmp9_ = FALSE;
				}
				_tmp13_ = _tmp9_;
				if (!_tmp13_) {
					break;
				}
				_tmp14_ = shift;
				shift = _tmp14_ + 1;
			}
		}
	}
	_tmp15_ = number_new_integer ((gint64) 0);
	z = _tmp15_;
	_tmp16_ = z;
	_tmp17_ = self->re_sign;
	_tmp16_->re_sign = _tmp17_;
	_tmp18_ = z;
	_tmp19_ = self->re_exponent;
	_tmp20_ = shift;
	_tmp18_->re_exponent = _tmp19_ - _tmp20_;
	{
		gint i;
		i = 0;
		{
			gboolean _tmp21_;
			_tmp21_ = TRUE;
			while (TRUE) {
				gboolean _tmp22_;
				gint _tmp24_;
				gint _tmp25_;
				gint _tmp26_;
				_tmp22_ = _tmp21_;
				if (!_tmp22_) {
					gint _tmp23_;
					_tmp23_ = i;
					i = _tmp23_ + 1;
				}
				_tmp21_ = FALSE;
				_tmp24_ = i;
				if (!(_tmp24_ < SIZE)) {
					break;
				}
				_tmp25_ = i;
				_tmp26_ = shift;
				if ((_tmp25_ + _tmp26_) >= SIZE) {
					Number* _tmp27_;
					gint _tmp28_;
					gint _tmp29_;
					_tmp27_ = z;
					_tmp28_ = i;
					_tmp27_->re_fraction[_tmp28_] = 0;
					_tmp29_ = _tmp27_->re_fraction[_tmp28_];
				} else {
					Number* _tmp30_;
					gint _tmp31_;
					gint _tmp32_;
					gint _tmp33_;
					gint _tmp34_;
					gint _tmp35_;
					_tmp30_ = z;
					_tmp31_ = i;
					_tmp32_ = i;
					_tmp33_ = shift;
					_tmp34_ = self->re_fraction[_tmp32_ + _tmp33_];
					_tmp30_->re_fraction[_tmp31_] = _tmp34_;
					_tmp35_ = _tmp30_->re_fraction[_tmp31_];
				}
			}
		}
	}
	_tmp36_ = z;
	_tmp37_ = _tmp36_->re_fraction[0];
	if (_tmp37_ == 0) {
		Number* _tmp38_;
		_tmp38_ = z;
		_tmp38_->re_sign = 0;
	}
	result = z;
	return result;
}


Number* number_fractional_part (Number* self) {
	Number* result = NULL;
	Number* _tmp0_ = NULL;
	Number* _tmp1_;
	Number* _tmp2_ = NULL;
	Number* _tmp3_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = number_floor (self);
	_tmp1_ = _tmp0_;
	_tmp2_ = number_subtract (self, _tmp1_);
	_tmp3_ = _tmp2_;
	_number_unref0 (_tmp1_);
	result = _tmp3_;
	return result;
}


Number* number_floor (Number* self) {
	Number* result = NULL;
	gboolean _tmp0_ = FALSE;
	gint _tmp2_;
	Number* _tmp6_ = NULL;
	Number* z;
	gboolean have_fraction;
	Number* _tmp19_;
	Number* _tmp20_;
	gboolean _tmp29_ = FALSE;
	gboolean _tmp30_;
	gboolean _tmp32_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = number_is_zero (self);
	if (_tmp0_) {
		Number* _tmp1_;
		_tmp1_ = _number_ref0 (self);
		result = _tmp1_;
		return result;
	}
	_tmp2_ = self->re_exponent;
	if (_tmp2_ <= 0) {
		gboolean _tmp3_ = FALSE;
		_tmp3_ = number_is_negative (self);
		if (_tmp3_) {
			Number* _tmp4_;
			_tmp4_ = number_new_integer ((gint64) (-1));
			result = _tmp4_;
			return result;
		} else {
			Number* _tmp5_;
			_tmp5_ = number_new_integer ((gint64) 0);
			result = _tmp5_;
			return result;
		}
	}
	_tmp6_ = number_copy (self);
	z = _tmp6_;
	have_fraction = FALSE;
	{
		Number* _tmp7_;
		gint _tmp8_;
		gint i;
		_tmp7_ = z;
		_tmp8_ = _tmp7_->re_exponent;
		i = _tmp8_;
		{
			gboolean _tmp9_;
			_tmp9_ = TRUE;
			while (TRUE) {
				gboolean _tmp10_;
				gint _tmp12_;
				Number* _tmp13_;
				gint _tmp14_;
				gint _tmp15_;
				Number* _tmp16_;
				gint _tmp17_;
				gint _tmp18_;
				_tmp10_ = _tmp9_;
				if (!_tmp10_) {
					gint _tmp11_;
					_tmp11_ = i;
					i = _tmp11_ + 1;
				}
				_tmp9_ = FALSE;
				_tmp12_ = i;
				if (!(_tmp12_ < SIZE)) {
					break;
				}
				_tmp13_ = z;
				_tmp14_ = i;
				_tmp15_ = _tmp13_->re_fraction[_tmp14_];
				if (_tmp15_ != 0) {
					have_fraction = TRUE;
				}
				_tmp16_ = z;
				_tmp17_ = i;
				_tmp16_->re_fraction[_tmp17_] = 0;
				_tmp18_ = _tmp16_->re_fraction[_tmp17_];
			}
		}
	}
	_tmp19_ = z;
	_tmp19_->im_sign = 0;
	_tmp20_ = z;
	_tmp20_->im_exponent = 0;
	{
		gint i;
		i = 0;
		{
			gboolean _tmp21_;
			_tmp21_ = TRUE;
			while (TRUE) {
				gboolean _tmp22_;
				gint _tmp24_;
				Number* _tmp25_;
				Number* _tmp26_;
				gint _tmp27_;
				gint _tmp28_;
				_tmp22_ = _tmp21_;
				if (!_tmp22_) {
					gint _tmp23_;
					_tmp23_ = i;
					i = _tmp23_ + 1;
				}
				_tmp21_ = FALSE;
				_tmp24_ = i;
				_tmp25_ = z;
				if (!(_tmp24_ < 1000)) {
					break;
				}
				_tmp26_ = z;
				_tmp27_ = i;
				_tmp26_->im_fraction[_tmp27_] = 0;
				_tmp28_ = _tmp26_->im_fraction[_tmp27_];
			}
		}
	}
	_tmp30_ = have_fraction;
	if (_tmp30_) {
		gboolean _tmp31_ = FALSE;
		_tmp31_ = number_is_negative (self);
		_tmp29_ = _tmp31_;
	} else {
		_tmp29_ = FALSE;
	}
	_tmp32_ = _tmp29_;
	if (_tmp32_) {
		Number* _tmp33_;
		Number* _tmp34_;
		Number* _tmp35_;
		Number* _tmp36_ = NULL;
		_tmp33_ = z;
		_tmp34_ = number_new_integer ((gint64) (-1));
		_tmp35_ = _tmp34_;
		_tmp36_ = number_add (_tmp33_, _tmp35_);
		_number_unref0 (z);
		z = _tmp36_;
		_number_unref0 (_tmp35_);
	}
	result = z;
	return result;
}


Number* number_ceiling (Number* self) {
	Number* result = NULL;
	Number* _tmp0_ = NULL;
	Number* z;
	Number* _tmp1_ = NULL;
	Number* f;
	Number* _tmp2_;
	gboolean _tmp3_ = FALSE;
	Number* _tmp4_;
	Number* _tmp5_;
	Number* _tmp6_;
	Number* _tmp7_ = NULL;
	Number* _tmp8_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = number_floor (self);
	z = _tmp0_;
	_tmp1_ = number_fractional_component (self);
	f = _tmp1_;
	_tmp2_ = f;
	_tmp3_ = number_is_zero (_tmp2_);
	if (_tmp3_) {
		result = z;
		_number_unref0 (f);
		return result;
	}
	_tmp4_ = z;
	_tmp5_ = number_new_integer ((gint64) 1);
	_tmp6_ = _tmp5_;
	_tmp7_ = number_add (_tmp4_, _tmp6_);
	_tmp8_ = _tmp7_;
	_number_unref0 (_tmp6_);
	result = _tmp8_;
	_number_unref0 (f);
	_number_unref0 (z);
	return result;
}


Number* number_round (Number* self) {
	Number* result = NULL;
	gboolean _tmp0_ = FALSE;
	gboolean do_floor;
	Number* _tmp1_ = NULL;
	Number* f;
	Number* _tmp2_;
	Number* _tmp3_ = NULL;
	Number* _tmp4_;
	Number* _tmp5_ = NULL;
	Number* _tmp6_;
	Number* _tmp7_;
	Number* _tmp8_;
	gint _tmp9_ = 0;
	gboolean _tmp10_;
	gboolean _tmp12_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = number_is_negative (self);
	do_floor = !_tmp0_;
	_tmp1_ = number_fractional_component (self);
	f = _tmp1_;
	_tmp2_ = f;
	_tmp3_ = number_multiply_integer (_tmp2_, (gint64) 2);
	_number_unref0 (f);
	f = _tmp3_;
	_tmp4_ = f;
	_tmp5_ = number_abs (_tmp4_);
	_number_unref0 (f);
	f = _tmp5_;
	_tmp6_ = f;
	_tmp7_ = number_new_integer ((gint64) 1);
	_tmp8_ = _tmp7_;
	_tmp9_ = number_compare (_tmp6_, _tmp8_);
	_tmp10_ = _tmp9_ >= 0;
	_number_unref0 (_tmp8_);
	if (_tmp10_) {
		gboolean _tmp11_;
		_tmp11_ = do_floor;
		do_floor = !_tmp11_;
	}
	_tmp12_ = do_floor;
	if (_tmp12_) {
		Number* _tmp13_ = NULL;
		_tmp13_ = number_floor (self);
		result = _tmp13_;
		_number_unref0 (f);
		return result;
	} else {
		Number* _tmp14_ = NULL;
		_tmp14_ = number_ceiling (self);
		result = _tmp14_;
		_number_unref0 (f);
		return result;
	}
	_number_unref0 (f);
}


Number* number_reciprocal (Number* self) {
	Number* result = NULL;
	gboolean _tmp0_ = FALSE;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = number_is_complex (self);
	if (_tmp0_) {
		Number* _tmp1_ = NULL;
		Number* real_x;
		Number* _tmp2_ = NULL;
		Number* im_x;
		Number* _tmp3_;
		Number* _tmp4_;
		Number* _tmp5_ = NULL;
		Number* t1;
		Number* _tmp6_;
		Number* _tmp7_;
		Number* _tmp8_ = NULL;
		Number* t2;
		Number* _tmp9_;
		Number* _tmp10_;
		Number* _tmp11_ = NULL;
		Number* _tmp12_;
		Number* _tmp13_ = NULL;
		Number* z;
		Number* _tmp14_ = NULL;
		Number* _tmp15_;
		Number* _tmp16_;
		Number* _tmp17_ = NULL;
		Number* _tmp18_;
		_tmp1_ = number_real_component (self);
		real_x = _tmp1_;
		_tmp2_ = number_imaginary_component (self);
		im_x = _tmp2_;
		_tmp3_ = real_x;
		_tmp4_ = real_x;
		_tmp5_ = number_multiply (_tmp3_, _tmp4_);
		t1 = _tmp5_;
		_tmp6_ = im_x;
		_tmp7_ = im_x;
		_tmp8_ = number_multiply (_tmp6_, _tmp7_);
		t2 = _tmp8_;
		_tmp9_ = t1;
		_tmp10_ = t2;
		_tmp11_ = number_add (_tmp9_, _tmp10_);
		_number_unref0 (t1);
		t1 = _tmp11_;
		_tmp12_ = t1;
		_tmp13_ = number_reciprocal_real (_tmp12_);
		z = _tmp13_;
		_tmp14_ = number_conjugate (self);
		_tmp15_ = _tmp14_;
		_tmp16_ = z;
		_tmp17_ = number_multiply (_tmp15_, _tmp16_);
		_tmp18_ = _tmp17_;
		_number_unref0 (_tmp15_);
		result = _tmp18_;
		_number_unref0 (z);
		_number_unref0 (t2);
		_number_unref0 (t1);
		_number_unref0 (im_x);
		_number_unref0 (real_x);
		return result;
	} else {
		Number* _tmp19_ = NULL;
		_tmp19_ = number_reciprocal_real (self);
		result = _tmp19_;
		return result;
	}
}


Number* number_epowy (Number* self) {
	Number* result = NULL;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp2_ = FALSE;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = number_is_zero (self);
	if (_tmp0_) {
		Number* _tmp1_;
		_tmp1_ = number_new_integer ((gint64) 1);
		result = _tmp1_;
		return result;
	}
	_tmp2_ = number_is_complex (self);
	if (_tmp2_) {
		Number* _tmp3_ = NULL;
		Number* x_real;
		Number* _tmp4_ = NULL;
		Number* theta;
		Number* _tmp5_;
		Number* _tmp6_ = NULL;
		Number* r;
		Number* _tmp7_;
		Number* _tmp8_;
		Number* _tmp9_;
		_tmp3_ = number_real_component (self);
		x_real = _tmp3_;
		_tmp4_ = number_imaginary_component (self);
		theta = _tmp4_;
		_tmp5_ = x_real;
		_tmp6_ = number_epowy_real (_tmp5_);
		r = _tmp6_;
		_tmp7_ = r;
		_tmp8_ = theta;
		_tmp9_ = number_new_polar (_tmp7_, _tmp8_, ANGLE_UNIT_RADIANS);
		result = _tmp9_;
		_number_unref0 (r);
		_number_unref0 (theta);
		_number_unref0 (x_real);
		return result;
	} else {
		Number* _tmp10_ = NULL;
		_tmp10_ = number_epowy_real (self);
		result = _tmp10_;
		return result;
	}
}


Number* number_xpowy (Number* self, Number* y) {
	Number* result = NULL;
	Number* _tmp0_;
	gboolean _tmp1_ = FALSE;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (y != NULL, NULL);
	_tmp0_ = y;
	_tmp1_ = number_is_integer (_tmp0_);
	if (_tmp1_) {
		Number* _tmp2_;
		gint64 _tmp3_ = 0LL;
		Number* _tmp4_ = NULL;
		_tmp2_ = y;
		_tmp3_ = number_to_integer (_tmp2_);
		_tmp4_ = number_xpowy_integer (self, _tmp3_);
		result = _tmp4_;
		return result;
	} else {
		Number* _tmp5_;
		Number* _tmp6_ = NULL;
		Number* reciprocal;
		Number* _tmp7_;
		gboolean _tmp8_ = FALSE;
		_tmp5_ = y;
		_tmp6_ = number_reciprocal (_tmp5_);
		reciprocal = _tmp6_;
		_tmp7_ = reciprocal;
		_tmp8_ = number_is_integer (_tmp7_);
		if (_tmp8_) {
			Number* _tmp9_;
			gint64 _tmp10_ = 0LL;
			Number* _tmp11_ = NULL;
			_tmp9_ = reciprocal;
			_tmp10_ = number_to_integer (_tmp9_);
			_tmp11_ = number_root (self, _tmp10_);
			result = _tmp11_;
			_number_unref0 (reciprocal);
			return result;
		} else {
			Number* _tmp12_;
			Number* _tmp13_ = NULL;
			_tmp12_ = y;
			_tmp13_ = number_pwr (self, _tmp12_);
			result = _tmp13_;
			_number_unref0 (reciprocal);
			return result;
		}
		_number_unref0 (reciprocal);
	}
}


Number* number_xpowy_integer (Number* self, gint64 n) {
	Number* result = NULL;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp3_;
	gint64 _tmp6_;
	gboolean _tmp8_ = FALSE;
	gint64 _tmp10_;
	Number* t = NULL;
	gint64 _tmp12_;
	Number* _tmp16_;
	Number* z;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp1_ = number_is_zero (self);
	if (_tmp1_) {
		gint64 _tmp2_;
		_tmp2_ = n;
		_tmp0_ = _tmp2_ < ((gint64) 0);
	} else {
		_tmp0_ = FALSE;
	}
	_tmp3_ = _tmp0_;
	if (_tmp3_) {
		const gchar* _tmp4_ = NULL;
		Number* _tmp5_;
		_tmp4_ = _ ("The power of zero is undefined for a negative exponent");
		mperr (_tmp4_);
		_tmp5_ = number_new_integer ((gint64) 0);
		result = _tmp5_;
		return result;
	}
	_tmp6_ = n;
	if (_tmp6_ == ((gint64) 0)) {
		Number* _tmp7_;
		_tmp7_ = number_new_integer ((gint64) 1);
		result = _tmp7_;
		return result;
	}
	_tmp8_ = number_is_zero (self);
	if (_tmp8_) {
		Number* _tmp9_;
		_tmp9_ = number_new_integer ((gint64) 0);
		result = _tmp9_;
		return result;
	}
	_tmp10_ = n;
	if (_tmp10_ == ((gint64) 1)) {
		Number* _tmp11_;
		_tmp11_ = _number_ref0 (self);
		result = _tmp11_;
		return result;
	}
	_tmp12_ = n;
	if (_tmp12_ < ((gint64) 0)) {
		Number* _tmp13_ = NULL;
		gint64 _tmp14_;
		_tmp13_ = number_reciprocal (self);
		_number_unref0 (t);
		t = _tmp13_;
		_tmp14_ = n;
		n = -_tmp14_;
	} else {
		Number* _tmp15_;
		_tmp15_ = _number_ref0 (self);
		_number_unref0 (t);
		t = _tmp15_;
	}
	_tmp16_ = number_new_integer ((gint64) 1);
	z = _tmp16_;
	{
		gint i;
		i = 0;
		{
			gboolean _tmp17_;
			_tmp17_ = TRUE;
			while (TRUE) {
				gboolean _tmp18_;
				gint _tmp20_;
				gint64 _tmp21_;
				Number* _tmp22_;
				Number* _tmp23_;
				Number* _tmp24_ = NULL;
				_tmp18_ = _tmp17_;
				if (!_tmp18_) {
					gint _tmp19_;
					_tmp19_ = i;
					i = _tmp19_ + 1;
				}
				_tmp17_ = FALSE;
				_tmp20_ = i;
				_tmp21_ = n;
				if (!(((gint64) _tmp20_) < _tmp21_)) {
					break;
				}
				_tmp22_ = z;
				_tmp23_ = t;
				_tmp24_ = number_multiply (_tmp22_, _tmp23_);
				_number_unref0 (z);
				z = _tmp24_;
			}
		}
	}
	result = z;
	_number_unref0 (t);
	return result;
}


Number* number_root (Number* self, gint64 n) {
	Number* result = NULL;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp2_ = FALSE;
	gboolean _tmp4_;
	gboolean _tmp6_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp2_ = number_is_complex (self);
	if (!_tmp2_) {
		gboolean _tmp3_ = FALSE;
		_tmp3_ = number_is_negative (self);
		_tmp1_ = _tmp3_;
	} else {
		_tmp1_ = FALSE;
	}
	_tmp4_ = _tmp1_;
	if (_tmp4_) {
		gint64 _tmp5_;
		_tmp5_ = n;
		_tmp0_ = (_tmp5_ % 2) == ((gint64) 1);
	} else {
		_tmp0_ = FALSE;
	}
	_tmp6_ = _tmp0_;
	if (_tmp6_) {
		Number* _tmp7_ = NULL;
		Number* z;
		Number* _tmp8_;
		gint64 _tmp9_;
		Number* _tmp10_ = NULL;
		Number* _tmp11_;
		Number* _tmp12_ = NULL;
		_tmp7_ = number_abs (self);
		z = _tmp7_;
		_tmp8_ = z;
		_tmp9_ = n;
		_tmp10_ = number_root_real (_tmp8_, _tmp9_);
		_number_unref0 (z);
		z = _tmp10_;
		_tmp11_ = z;
		_tmp12_ = number_invert_sign (_tmp11_);
		_number_unref0 (z);
		z = _tmp12_;
		result = z;
		return result;
	} else {
		gboolean _tmp13_ = FALSE;
		gboolean _tmp14_ = FALSE;
		gboolean _tmp16_;
		_tmp14_ = number_is_complex (self);
		if (_tmp14_) {
			_tmp13_ = TRUE;
		} else {
			gboolean _tmp15_ = FALSE;
			_tmp15_ = number_is_negative (self);
			_tmp13_ = _tmp15_;
		}
		_tmp16_ = _tmp13_;
		if (_tmp16_) {
			Number* _tmp17_ = NULL;
			Number* r;
			Number* _tmp18_ = NULL;
			Number* theta;
			Number* _tmp19_;
			gint64 _tmp20_;
			Number* _tmp21_ = NULL;
			Number* _tmp22_;
			gint64 _tmp23_;
			Number* _tmp24_ = NULL;
			Number* _tmp25_;
			Number* _tmp26_;
			Number* _tmp27_;
			_tmp17_ = number_abs (self);
			r = _tmp17_;
			_tmp18_ = number_arg (self, ANGLE_UNIT_RADIANS);
			theta = _tmp18_;
			_tmp19_ = r;
			_tmp20_ = n;
			_tmp21_ = number_root_real (_tmp19_, _tmp20_);
			_number_unref0 (r);
			r = _tmp21_;
			_tmp22_ = theta;
			_tmp23_ = n;
			_tmp24_ = number_divide_integer (_tmp22_, _tmp23_);
			_number_unref0 (theta);
			theta = _tmp24_;
			_tmp25_ = r;
			_tmp26_ = theta;
			_tmp27_ = number_new_polar (_tmp25_, _tmp26_, ANGLE_UNIT_RADIANS);
			result = _tmp27_;
			_number_unref0 (theta);
			_number_unref0 (r);
			return result;
		} else {
			gint64 _tmp28_;
			Number* _tmp29_ = NULL;
			_tmp28_ = n;
			_tmp29_ = number_root_real (self, _tmp28_);
			result = _tmp29_;
			return result;
		}
	}
}


Number* number_sqrt (Number* self) {
	Number* result = NULL;
	gboolean _tmp0_ = FALSE;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = number_is_zero (self);
	if (_tmp0_) {
		Number* _tmp1_;
		_tmp1_ = _number_ref0 (self);
		result = _tmp1_;
		return result;
	} else {
		Number* _tmp2_ = NULL;
		Number* t;
		Number* _tmp3_;
		Number* _tmp4_ = NULL;
		Number* z;
		Number* _tmp5_;
		Number* _tmp6_;
		gint _tmp7_;
		Number* _tmp8_;
		gint _tmp9_;
		Number* _tmp10_ = NULL;
		_tmp2_ = number_root (self, (gint64) (-2));
		t = _tmp2_;
		_tmp3_ = t;
		_tmp4_ = number_multiply (self, _tmp3_);
		z = _tmp4_;
		_tmp5_ = z;
		_tmp6_ = t;
		_tmp7_ = _tmp6_->re_fraction[0];
		_tmp8_ = z;
		_tmp9_ = _tmp8_->re_fraction[0];
		_tmp10_ = number_ext (_tmp5_, _tmp7_, _tmp9_);
		result = _tmp10_;
		_number_unref0 (z);
		_number_unref0 (t);
		return result;
	}
}


Number* number_ln (Number* self) {
	Number* result = NULL;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp3_ = FALSE;
	gboolean _tmp4_ = FALSE;
	gboolean _tmp6_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = number_is_zero (self);
	if (_tmp0_) {
		const gchar* _tmp1_ = NULL;
		Number* _tmp2_;
		_tmp1_ = _ ("Logarithm of zero is undefined");
		mperr (_tmp1_);
		_tmp2_ = number_new_integer ((gint64) 0);
		result = _tmp2_;
		return result;
	}
	_tmp4_ = number_is_complex (self);
	if (_tmp4_) {
		_tmp3_ = TRUE;
	} else {
		gboolean _tmp5_ = FALSE;
		_tmp5_ = number_is_negative (self);
		_tmp3_ = _tmp5_;
	}
	_tmp6_ = _tmp3_;
	if (_tmp6_) {
		Number* _tmp7_ = NULL;
		Number* r;
		Number* _tmp8_ = NULL;
		Number* theta;
		Number* _tmp9_;
		Number* _tmp10_ = NULL;
		Number* z_real;
		Number* _tmp11_;
		Number* _tmp12_;
		Number* _tmp13_;
		_tmp7_ = number_abs (self);
		r = _tmp7_;
		_tmp8_ = number_arg (self, ANGLE_UNIT_RADIANS);
		theta = _tmp8_;
		_tmp9_ = r;
		_tmp10_ = number_ln_real (_tmp9_);
		z_real = _tmp10_;
		_tmp11_ = z_real;
		_tmp12_ = theta;
		_tmp13_ = number_new_complex (_tmp11_, _tmp12_);
		result = _tmp13_;
		_number_unref0 (z_real);
		_number_unref0 (theta);
		_number_unref0 (r);
		return result;
	} else {
		Number* _tmp14_ = NULL;
		_tmp14_ = number_ln_real (self);
		result = _tmp14_;
		return result;
	}
}


Number* number_logarithm (Number* self, gint64 n) {
	Number* result = NULL;
	gboolean _tmp0_ = FALSE;
	gint64 _tmp3_;
	Number* _tmp4_;
	Number* t1;
	Number* _tmp5_ = NULL;
	Number* _tmp6_;
	Number* _tmp7_;
	Number* _tmp8_ = NULL;
	Number* _tmp9_;
	Number* _tmp10_ = NULL;
	Number* _tmp11_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = number_is_zero (self);
	if (_tmp0_) {
		const gchar* _tmp1_ = NULL;
		Number* _tmp2_;
		_tmp1_ = _ ("Logarithm of zero is undefined");
		mperr (_tmp1_);
		_tmp2_ = number_new_integer ((gint64) 0);
		result = _tmp2_;
		return result;
	}
	_tmp3_ = n;
	_tmp4_ = number_new_integer (_tmp3_);
	t1 = _tmp4_;
	_tmp5_ = number_ln (self);
	_tmp6_ = _tmp5_;
	_tmp7_ = t1;
	_tmp8_ = number_ln (_tmp7_);
	_tmp9_ = _tmp8_;
	_tmp10_ = number_divide (_tmp6_, _tmp9_);
	_tmp11_ = _tmp10_;
	_number_unref0 (_tmp9_);
	_number_unref0 (_tmp6_);
	result = _tmp11_;
	_number_unref0 (t1);
	return result;
}


Number* number_factorial (Number* self) {
	Number* result = NULL;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp2_ = FALSE;
	gint64 _tmp5_ = 0LL;
	gint64 value;
	Number* _tmp6_;
	Number* z;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = number_is_zero (self);
	if (_tmp0_) {
		Number* _tmp1_;
		_tmp1_ = number_new_integer ((gint64) 1);
		result = _tmp1_;
		return result;
	}
	_tmp2_ = number_is_natural (self);
	if (!_tmp2_) {
		const gchar* _tmp3_ = NULL;
		Number* _tmp4_;
		_tmp3_ = _ ("Factorial is only defined for natural numbers");
		mperr (_tmp3_);
		_tmp4_ = number_new_integer ((gint64) 0);
		result = _tmp4_;
		return result;
	}
	_tmp5_ = number_to_integer (self);
	value = _tmp5_;
	_tmp6_ = _number_ref0 (self);
	z = _tmp6_;
	{
		gint i;
		i = 2;
		{
			gboolean _tmp7_;
			_tmp7_ = TRUE;
			while (TRUE) {
				gboolean _tmp8_;
				gint _tmp10_;
				gint64 _tmp11_;
				Number* _tmp12_;
				gint _tmp13_;
				Number* _tmp14_ = NULL;
				_tmp8_ = _tmp7_;
				if (!_tmp8_) {
					gint _tmp9_;
					_tmp9_ = i;
					i = _tmp9_ + 1;
				}
				_tmp7_ = FALSE;
				_tmp10_ = i;
				_tmp11_ = value;
				if (!(((gint64) _tmp10_) < _tmp11_)) {
					break;
				}
				_tmp12_ = z;
				_tmp13_ = i;
				_tmp14_ = number_multiply_integer (_tmp12_, (gint64) _tmp13_);
				_number_unref0 (z);
				z = _tmp14_;
			}
		}
	}
	result = z;
	return result;
}


Number* number_add (Number* self, Number* y) {
	Number* result = NULL;
	Number* _tmp0_;
	Number* _tmp1_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (y != NULL, NULL);
	_tmp0_ = y;
	_tmp1_ = number_add_with_sign (self, 1, _tmp0_);
	result = _tmp1_;
	return result;
}


Number* number_subtract (Number* self, Number* y) {
	Number* result = NULL;
	Number* _tmp0_;
	Number* _tmp1_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (y != NULL, NULL);
	_tmp0_ = y;
	_tmp1_ = number_add_with_sign (self, -1, _tmp0_);
	result = _tmp1_;
	return result;
}


Number* number_multiply (Number* self, Number* y) {
	Number* result = NULL;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp4_;
	gboolean _tmp6_ = FALSE;
	gboolean _tmp7_ = FALSE;
	gboolean _tmp10_;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (y != NULL, NULL);
	_tmp1_ = number_is_zero (self);
	if (_tmp1_) {
		_tmp0_ = TRUE;
	} else {
		Number* _tmp2_;
		gboolean _tmp3_ = FALSE;
		_tmp2_ = y;
		_tmp3_ = number_is_zero (_tmp2_);
		_tmp0_ = _tmp3_;
	}
	_tmp4_ = _tmp0_;
	if (_tmp4_) {
		Number* _tmp5_;
		_tmp5_ = number_new_integer ((gint64) 0);
		result = _tmp5_;
		return result;
	}
	_tmp7_ = number_is_complex (self);
	if (_tmp7_) {
		_tmp6_ = TRUE;
	} else {
		Number* _tmp8_;
		gboolean _tmp9_ = FALSE;
		_tmp8_ = y;
		_tmp9_ = number_is_complex (_tmp8_);
		_tmp6_ = _tmp9_;
	}
	_tmp10_ = _tmp6_;
	if (_tmp10_) {
		Number* t1 = NULL;
		Number* t2 = NULL;
		Number* real_z = NULL;
		Number* im_z = NULL;
		Number* _tmp11_ = NULL;
		Number* real_x;
		Number* _tmp12_ = NULL;
		Number* im_x;
		Number* _tmp13_;
		Number* _tmp14_ = NULL;
		Number* real_y;
		Number* _tmp15_;
		Number* _tmp16_ = NULL;
		Number* im_y;
		Number* _tmp17_;
		Number* _tmp18_;
		Number* _tmp19_ = NULL;
		Number* _tmp20_;
		Number* _tmp21_;
		Number* _tmp22_ = NULL;
		Number* _tmp23_;
		Number* _tmp24_;
		Number* _tmp25_ = NULL;
		Number* _tmp26_;
		Number* _tmp27_;
		Number* _tmp28_ = NULL;
		Number* _tmp29_;
		Number* _tmp30_;
		Number* _tmp31_ = NULL;
		Number* _tmp32_;
		Number* _tmp33_;
		Number* _tmp34_ = NULL;
		Number* _tmp35_;
		Number* _tmp36_;
		Number* _tmp37_;
		_tmp11_ = number_real_component (self);
		real_x = _tmp11_;
		_tmp12_ = number_imaginary_component (self);
		im_x = _tmp12_;
		_tmp13_ = y;
		_tmp14_ = number_real_component (_tmp13_);
		real_y = _tmp14_;
		_tmp15_ = y;
		_tmp16_ = number_imaginary_component (_tmp15_);
		im_y = _tmp16_;
		_tmp17_ = real_x;
		_tmp18_ = real_y;
		_tmp19_ = number_multiply_real (_tmp17_, _tmp18_);
		_number_unref0 (t1);
		t1 = _tmp19_;
		_tmp20_ = im_x;
		_tmp21_ = im_y;
		_tmp22_ = number_multiply_real (_tmp20_, _tmp21_);
		_number_unref0 (t2);
		t2 = _tmp22_;
		_tmp23_ = t1;
		_tmp24_ = t2;
		_tmp25_ = number_subtract (_tmp23_, _tmp24_);
		_number_unref0 (real_z);
		real_z = _tmp25_;
		_tmp26_ = real_x;
		_tmp27_ = im_y;
		_tmp28_ = number_multiply_real (_tmp26_, _tmp27_);
		_number_unref0 (t1);
		t1 = _tmp28_;
		_tmp29_ = im_x;
		_tmp30_ = real_y;
		_tmp31_ = number_multiply_real (_tmp29_, _tmp30_);
		_number_unref0 (t2);
		t2 = _tmp31_;
		_tmp32_ = t1;
		_tmp33_ = t2;
		_tmp34_ = number_add (_tmp32_, _tmp33_);
		_number_unref0 (im_z);
		im_z = _tmp34_;
		_tmp35_ = real_z;
		_tmp36_ = im_z;
		_tmp37_ = number_new_complex (_tmp35_, _tmp36_);
		result = _tmp37_;
		_number_unref0 (im_y);
		_number_unref0 (real_y);
		_number_unref0 (im_x);
		_number_unref0 (real_x);
		_number_unref0 (im_z);
		_number_unref0 (real_z);
		_number_unref0 (t2);
		_number_unref0 (t1);
		return result;
	} else {
		Number* _tmp38_;
		Number* _tmp39_ = NULL;
		_tmp38_ = y;
		_tmp39_ = number_multiply_real (self, _tmp38_);
		result = _tmp39_;
		return result;
	}
}


Number* number_multiply_integer (Number* self, gint64 y) {
	Number* result = NULL;
	gboolean _tmp0_ = FALSE;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = number_is_complex (self);
	if (_tmp0_) {
		Number* _tmp1_ = NULL;
		Number* _tmp2_;
		gint64 _tmp3_;
		Number* _tmp4_ = NULL;
		Number* _tmp5_;
		Number* re_z;
		Number* _tmp6_ = NULL;
		Number* _tmp7_;
		gint64 _tmp8_;
		Number* _tmp9_ = NULL;
		Number* _tmp10_;
		Number* im_z;
		Number* _tmp11_;
		Number* _tmp12_;
		Number* _tmp13_;
		_tmp1_ = number_real_component (self);
		_tmp2_ = _tmp1_;
		_tmp3_ = y;
		_tmp4_ = number_multiply_integer_real (_tmp2_, _tmp3_);
		_tmp5_ = _tmp4_;
		_number_unref0 (_tmp2_);
		re_z = _tmp5_;
		_tmp6_ = number_imaginary_component (self);
		_tmp7_ = _tmp6_;
		_tmp8_ = y;
		_tmp9_ = number_multiply_integer_real (_tmp7_, _tmp8_);
		_tmp10_ = _tmp9_;
		_number_unref0 (_tmp7_);
		im_z = _tmp10_;
		_tmp11_ = re_z;
		_tmp12_ = im_z;
		_tmp13_ = number_new_complex (_tmp11_, _tmp12_);
		result = _tmp13_;
		_number_unref0 (im_z);
		_number_unref0 (re_z);
		return result;
	} else {
		gint64 _tmp14_;
		Number* _tmp15_ = NULL;
		_tmp14_ = y;
		_tmp15_ = number_multiply_integer_real (self, _tmp14_);
		result = _tmp15_;
		return result;
	}
}


Number* number_divide (Number* self, Number* y) {
	Number* result = NULL;
	Number* _tmp0_;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp4_ = FALSE;
	Number* _tmp6_;
	Number* _tmp7_ = NULL;
	Number* t;
	Number* _tmp8_;
	gint _tmp9_;
	gint ie;
	Number* _tmp10_;
	Number* _tmp11_;
	gint _tmp12_;
	gint i;
	Number* _tmp13_;
	Number* _tmp14_ = NULL;
	Number* z;
	Number* _tmp15_;
	gint _tmp16_;
	Number* _tmp17_;
	gint _tmp18_;
	Number* _tmp19_ = NULL;
	Number* _tmp20_;
	Number* _tmp21_;
	gint _tmp22_;
	gint _tmp23_;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (y != NULL, NULL);
	_tmp0_ = y;
	_tmp1_ = number_is_zero (_tmp0_);
	if (_tmp1_) {
		const gchar* _tmp2_ = NULL;
		Number* _tmp3_;
		_tmp2_ = _ ("Division by zero is undefined");
		mperr (_tmp2_);
		_tmp3_ = number_new_integer ((gint64) 0);
		result = _tmp3_;
		return result;
	}
	_tmp4_ = number_is_zero (self);
	if (_tmp4_) {
		Number* _tmp5_;
		_tmp5_ = _number_ref0 (self);
		result = _tmp5_;
		return result;
	}
	_tmp6_ = y;
	_tmp7_ = number_reciprocal (_tmp6_);
	t = _tmp7_;
	_tmp8_ = t;
	_tmp9_ = _tmp8_->re_exponent;
	ie = _tmp9_;
	_tmp10_ = t;
	_tmp10_->re_exponent = 0;
	_tmp11_ = t;
	_tmp12_ = _tmp11_->re_fraction[0];
	i = _tmp12_;
	_tmp13_ = t;
	_tmp14_ = number_multiply (self, _tmp13_);
	z = _tmp14_;
	_tmp15_ = z;
	_tmp16_ = i;
	_tmp17_ = z;
	_tmp18_ = _tmp17_->re_fraction[0];
	_tmp19_ = number_ext (_tmp15_, _tmp16_, _tmp18_);
	_number_unref0 (z);
	z = _tmp19_;
	_tmp20_ = z;
	_tmp21_ = z;
	_tmp22_ = _tmp21_->re_exponent;
	_tmp23_ = ie;
	_tmp21_->re_exponent = _tmp22_ + _tmp23_;
	result = z;
	_number_unref0 (t);
	return result;
}


Number* number_divide_integer (Number* self, gint64 y) {
	Number* result = NULL;
	gboolean _tmp0_ = FALSE;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = number_is_complex (self);
	if (_tmp0_) {
		Number* _tmp1_ = NULL;
		Number* _tmp2_;
		gint64 _tmp3_;
		Number* _tmp4_ = NULL;
		Number* _tmp5_;
		Number* re_z;
		Number* _tmp6_ = NULL;
		Number* _tmp7_;
		gint64 _tmp8_;
		Number* _tmp9_ = NULL;
		Number* _tmp10_;
		Number* im_z;
		Number* _tmp11_;
		Number* _tmp12_;
		Number* _tmp13_;
		_tmp1_ = number_real_component (self);
		_tmp2_ = _tmp1_;
		_tmp3_ = y;
		_tmp4_ = number_divide_integer_real (_tmp2_, _tmp3_);
		_tmp5_ = _tmp4_;
		_number_unref0 (_tmp2_);
		re_z = _tmp5_;
		_tmp6_ = number_imaginary_component (self);
		_tmp7_ = _tmp6_;
		_tmp8_ = y;
		_tmp9_ = number_divide_integer_real (_tmp7_, _tmp8_);
		_tmp10_ = _tmp9_;
		_number_unref0 (_tmp7_);
		im_z = _tmp10_;
		_tmp11_ = re_z;
		_tmp12_ = im_z;
		_tmp13_ = number_new_complex (_tmp11_, _tmp12_);
		result = _tmp13_;
		_number_unref0 (im_z);
		_number_unref0 (re_z);
		return result;
	} else {
		gint64 _tmp14_;
		Number* _tmp15_ = NULL;
		_tmp14_ = y;
		_tmp15_ = number_divide_integer_real (self, _tmp14_);
		result = _tmp15_;
		return result;
	}
}


Number* number_modulus_divide (Number* self, Number* y) {
	Number* result = NULL;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp4_;
	Number* _tmp7_;
	Number* _tmp8_ = NULL;
	Number* _tmp9_;
	Number* _tmp10_ = NULL;
	Number* _tmp11_;
	Number* t1;
	Number* _tmp12_;
	Number* _tmp13_;
	Number* _tmp14_ = NULL;
	Number* t2;
	Number* _tmp15_;
	Number* _tmp16_ = NULL;
	Number* z;
	Number* _tmp17_;
	gboolean _tmp18_ = FALSE;
	gboolean _tmp19_ = FALSE;
	Number* _tmp20_;
	Number* _tmp21_;
	gint _tmp22_ = 0;
	gboolean _tmp26_;
	gboolean _tmp35_;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (y != NULL, NULL);
	_tmp1_ = number_is_integer (self);
	if (!_tmp1_) {
		_tmp0_ = TRUE;
	} else {
		Number* _tmp2_;
		gboolean _tmp3_ = FALSE;
		_tmp2_ = y;
		_tmp3_ = number_is_integer (_tmp2_);
		_tmp0_ = !_tmp3_;
	}
	_tmp4_ = _tmp0_;
	if (_tmp4_) {
		const gchar* _tmp5_ = NULL;
		Number* _tmp6_;
		_tmp5_ = _ ("Modulus division is only defined for integers");
		mperr (_tmp5_);
		_tmp6_ = number_new_integer ((gint64) 0);
		result = _tmp6_;
		return result;
	}
	_tmp7_ = y;
	_tmp8_ = number_divide (self, _tmp7_);
	_tmp9_ = _tmp8_;
	_tmp10_ = number_floor (_tmp9_);
	_tmp11_ = _tmp10_;
	_number_unref0 (_tmp9_);
	t1 = _tmp11_;
	_tmp12_ = t1;
	_tmp13_ = y;
	_tmp14_ = number_multiply (_tmp12_, _tmp13_);
	t2 = _tmp14_;
	_tmp15_ = t2;
	_tmp16_ = number_subtract (self, _tmp15_);
	z = _tmp16_;
	_tmp17_ = number_new_integer ((gint64) 0);
	_number_unref0 (t1);
	t1 = _tmp17_;
	_tmp20_ = y;
	_tmp21_ = t1;
	_tmp22_ = number_compare (_tmp20_, _tmp21_);
	if (_tmp22_ < 0) {
		Number* _tmp23_;
		Number* _tmp24_;
		gint _tmp25_ = 0;
		_tmp23_ = z;
		_tmp24_ = t1;
		_tmp25_ = number_compare (_tmp23_, _tmp24_);
		_tmp19_ = _tmp25_ > 0;
	} else {
		_tmp19_ = FALSE;
	}
	_tmp26_ = _tmp19_;
	if (_tmp26_) {
		_tmp18_ = TRUE;
	} else {
		gboolean _tmp27_ = FALSE;
		Number* _tmp28_;
		Number* _tmp29_;
		gint _tmp30_ = 0;
		gboolean _tmp34_;
		_tmp28_ = y;
		_tmp29_ = t1;
		_tmp30_ = number_compare (_tmp28_, _tmp29_);
		if (_tmp30_ > 0) {
			Number* _tmp31_;
			Number* _tmp32_;
			gint _tmp33_ = 0;
			_tmp31_ = z;
			_tmp32_ = t1;
			_tmp33_ = number_compare (_tmp31_, _tmp32_);
			_tmp27_ = _tmp33_ < 0;
		} else {
			_tmp27_ = FALSE;
		}
		_tmp34_ = _tmp27_;
		_tmp18_ = _tmp34_;
	}
	_tmp35_ = _tmp18_;
	if (_tmp35_) {
		Number* _tmp36_;
		Number* _tmp37_;
		Number* _tmp38_ = NULL;
		_tmp36_ = z;
		_tmp37_ = y;
		_tmp38_ = number_add (_tmp36_, _tmp37_);
		_number_unref0 (z);
		z = _tmp38_;
	}
	result = z;
	_number_unref0 (t2);
	_number_unref0 (t1);
	return result;
}


Number* number_sin (Number* self, AngleUnit unit) {
	Number* result = NULL;
	gboolean _tmp0_ = FALSE;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = number_is_complex (self);
	if (_tmp0_) {
		Number* _tmp1_ = NULL;
		Number* x_real;
		Number* _tmp2_ = NULL;
		Number* x_im;
		Number* _tmp3_;
		AngleUnit _tmp4_;
		Number* _tmp5_ = NULL;
		Number* z_real;
		Number* _tmp6_;
		Number* _tmp7_ = NULL;
		Number* t;
		Number* _tmp8_;
		Number* _tmp9_;
		Number* _tmp10_ = NULL;
		Number* _tmp11_;
		AngleUnit _tmp12_;
		Number* _tmp13_ = NULL;
		Number* z_im;
		Number* _tmp14_;
		Number* _tmp15_ = NULL;
		Number* _tmp16_;
		Number* _tmp17_;
		Number* _tmp18_ = NULL;
		Number* _tmp19_;
		Number* _tmp20_;
		Number* _tmp21_;
		_tmp1_ = number_real_component (self);
		x_real = _tmp1_;
		_tmp2_ = number_imaginary_component (self);
		x_im = _tmp2_;
		_tmp3_ = x_real;
		_tmp4_ = unit;
		_tmp5_ = number_sin_real (_tmp3_, _tmp4_);
		z_real = _tmp5_;
		_tmp6_ = x_im;
		_tmp7_ = number_cosh (_tmp6_);
		t = _tmp7_;
		_tmp8_ = z_real;
		_tmp9_ = t;
		_tmp10_ = number_multiply (_tmp8_, _tmp9_);
		_number_unref0 (z_real);
		z_real = _tmp10_;
		_tmp11_ = x_real;
		_tmp12_ = unit;
		_tmp13_ = number_cos_real (_tmp11_, _tmp12_);
		z_im = _tmp13_;
		_tmp14_ = x_im;
		_tmp15_ = number_sinh (_tmp14_);
		_number_unref0 (t);
		t = _tmp15_;
		_tmp16_ = z_im;
		_tmp17_ = t;
		_tmp18_ = number_multiply (_tmp16_, _tmp17_);
		_number_unref0 (z_im);
		z_im = _tmp18_;
		_tmp19_ = z_real;
		_tmp20_ = z_im;
		_tmp21_ = number_new_complex (_tmp19_, _tmp20_);
		result = _tmp21_;
		_number_unref0 (z_im);
		_number_unref0 (t);
		_number_unref0 (z_real);
		_number_unref0 (x_im);
		_number_unref0 (x_real);
		return result;
	} else {
		AngleUnit _tmp22_;
		Number* _tmp23_ = NULL;
		_tmp22_ = unit;
		_tmp23_ = number_sin_real (self, _tmp22_);
		result = _tmp23_;
		return result;
	}
}


Number* number_cos (Number* self, AngleUnit unit) {
	Number* result = NULL;
	gboolean _tmp0_ = FALSE;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = number_is_complex (self);
	if (_tmp0_) {
		Number* _tmp1_ = NULL;
		Number* x_real;
		Number* _tmp2_ = NULL;
		Number* x_im;
		Number* _tmp3_;
		AngleUnit _tmp4_;
		Number* _tmp5_ = NULL;
		Number* z_real;
		Number* _tmp6_;
		Number* _tmp7_ = NULL;
		Number* t;
		Number* _tmp8_;
		Number* _tmp9_;
		Number* _tmp10_ = NULL;
		Number* _tmp11_;
		AngleUnit _tmp12_;
		Number* _tmp13_ = NULL;
		Number* z_im;
		Number* _tmp14_;
		Number* _tmp15_ = NULL;
		Number* _tmp16_;
		Number* _tmp17_;
		Number* _tmp18_ = NULL;
		Number* _tmp19_;
		Number* _tmp20_ = NULL;
		Number* _tmp21_;
		Number* _tmp22_;
		Number* _tmp23_;
		_tmp1_ = number_real_component (self);
		x_real = _tmp1_;
		_tmp2_ = number_imaginary_component (self);
		x_im = _tmp2_;
		_tmp3_ = x_real;
		_tmp4_ = unit;
		_tmp5_ = number_cos_real (_tmp3_, _tmp4_);
		z_real = _tmp5_;
		_tmp6_ = x_im;
		_tmp7_ = number_cosh (_tmp6_);
		t = _tmp7_;
		_tmp8_ = z_real;
		_tmp9_ = t;
		_tmp10_ = number_multiply (_tmp8_, _tmp9_);
		_number_unref0 (z_real);
		z_real = _tmp10_;
		_tmp11_ = x_real;
		_tmp12_ = unit;
		_tmp13_ = number_sin_real (_tmp11_, _tmp12_);
		z_im = _tmp13_;
		_tmp14_ = x_im;
		_tmp15_ = number_sinh (_tmp14_);
		_number_unref0 (t);
		t = _tmp15_;
		_tmp16_ = z_im;
		_tmp17_ = t;
		_tmp18_ = number_multiply (_tmp16_, _tmp17_);
		_number_unref0 (z_im);
		z_im = _tmp18_;
		_tmp19_ = z_im;
		_tmp20_ = number_invert_sign (_tmp19_);
		_number_unref0 (z_im);
		z_im = _tmp20_;
		_tmp21_ = z_real;
		_tmp22_ = z_im;
		_tmp23_ = number_new_complex (_tmp21_, _tmp22_);
		result = _tmp23_;
		_number_unref0 (z_im);
		_number_unref0 (t);
		_number_unref0 (z_real);
		_number_unref0 (x_im);
		_number_unref0 (x_real);
		return result;
	} else {
		AngleUnit _tmp24_;
		Number* _tmp25_ = NULL;
		_tmp24_ = unit;
		_tmp25_ = number_cos_real (self, _tmp24_);
		result = _tmp25_;
		return result;
	}
}


Number* number_tan (Number* self, AngleUnit unit) {
	Number* result = NULL;
	AngleUnit _tmp0_;
	Number* _tmp1_ = NULL;
	Number* cos_x;
	Number* _tmp2_;
	gboolean _tmp3_ = FALSE;
	AngleUnit _tmp6_;
	Number* _tmp7_ = NULL;
	Number* _tmp8_;
	Number* _tmp9_;
	Number* _tmp10_ = NULL;
	Number* _tmp11_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = unit;
	_tmp1_ = number_cos (self, _tmp0_);
	cos_x = _tmp1_;
	_tmp2_ = cos_x;
	_tmp3_ = number_is_zero (_tmp2_);
	if (_tmp3_) {
		const gchar* _tmp4_ = NULL;
		Number* _tmp5_;
		_tmp4_ = _ ("Tangent is undefined for angles that are multiples of  (180) from " \
"2 (90)");
		mperr (_tmp4_);
		_tmp5_ = number_new_integer ((gint64) 0);
		result = _tmp5_;
		_number_unref0 (cos_x);
		return result;
	}
	_tmp6_ = unit;
	_tmp7_ = number_sin (self, _tmp6_);
	_tmp8_ = _tmp7_;
	_tmp9_ = cos_x;
	_tmp10_ = number_divide (_tmp8_, _tmp9_);
	_tmp11_ = _tmp10_;
	_number_unref0 (_tmp8_);
	result = _tmp11_;
	_number_unref0 (cos_x);
	return result;
}


Number* number_asin (Number* self, AngleUnit unit) {
	Number* result = NULL;
	gboolean _tmp0_ = FALSE;
	gint _tmp2_;
	gint _tmp20_;
	Number* _tmp21_;
	Number* t2;
	Number* _tmp22_;
	gboolean _tmp23_ = FALSE;
	const gchar* _tmp33_ = NULL;
	Number* _tmp34_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = number_is_zero (self);
	if (_tmp0_) {
		Number* _tmp1_;
		_tmp1_ = number_new_integer ((gint64) 0);
		result = _tmp1_;
		return result;
	}
	_tmp2_ = self->re_exponent;
	if (_tmp2_ <= 0) {
		Number* _tmp3_;
		Number* t1;
		Number* _tmp4_;
		Number* _tmp5_;
		Number* t2;
		Number* _tmp6_;
		Number* _tmp7_ = NULL;
		Number* _tmp8_;
		Number* _tmp9_ = NULL;
		Number* _tmp10_;
		Number* _tmp11_;
		Number* _tmp12_ = NULL;
		Number* _tmp13_;
		Number* _tmp14_ = NULL;
		Number* _tmp15_;
		Number* _tmp16_ = NULL;
		Number* z;
		Number* _tmp17_;
		AngleUnit _tmp18_;
		Number* _tmp19_ = NULL;
		_tmp3_ = number_new_integer ((gint64) 1);
		t1 = _tmp3_;
		_tmp4_ = t1;
		_tmp5_ = _number_ref0 (_tmp4_);
		t2 = _tmp5_;
		_tmp6_ = t1;
		_tmp7_ = number_subtract (_tmp6_, self);
		_number_unref0 (t1);
		t1 = _tmp7_;
		_tmp8_ = t2;
		_tmp9_ = number_add (_tmp8_, self);
		_number_unref0 (t2);
		t2 = _tmp9_;
		_tmp10_ = t1;
		_tmp11_ = t2;
		_tmp12_ = number_multiply (_tmp10_, _tmp11_);
		_number_unref0 (t2);
		t2 = _tmp12_;
		_tmp13_ = t2;
		_tmp14_ = number_root (_tmp13_, (gint64) (-2));
		_number_unref0 (t2);
		t2 = _tmp14_;
		_tmp15_ = t2;
		_tmp16_ = number_multiply (self, _tmp15_);
		z = _tmp16_;
		_tmp17_ = z;
		_tmp18_ = unit;
		_tmp19_ = number_atan (_tmp17_, _tmp18_);
		_number_unref0 (z);
		z = _tmp19_;
		result = z;
		_number_unref0 (t2);
		_number_unref0 (t1);
		return result;
	}
	_tmp20_ = self->re_sign;
	_tmp21_ = number_new_integer ((gint64) _tmp20_);
	t2 = _tmp21_;
	_tmp22_ = t2;
	_tmp23_ = number_equals (self, _tmp22_);
	if (_tmp23_) {
		Number* _tmp24_;
		Number* _tmp25_;
		Number* _tmp26_;
		gint _tmp27_;
		Number* _tmp28_ = NULL;
		Number* _tmp29_;
		Number* z;
		Number* _tmp30_;
		AngleUnit _tmp31_;
		Number* _tmp32_ = NULL;
		_tmp24_ = number_new_pi ();
		_tmp25_ = _tmp24_;
		_tmp26_ = t2;
		_tmp27_ = _tmp26_->re_sign;
		_tmp28_ = number_divide_integer (_tmp25_, (gint64) (2 * _tmp27_));
		_tmp29_ = _tmp28_;
		_number_unref0 (_tmp25_);
		z = _tmp29_;
		_tmp30_ = z;
		_tmp31_ = unit;
		_tmp32_ = number_from_radians (_tmp30_, _tmp31_);
		result = _tmp32_;
		_number_unref0 (z);
		_number_unref0 (t2);
		return result;
	}
	_tmp33_ = _ ("Inverse sine is undefined for values outside [-1, 1]");
	mperr (_tmp33_);
	_tmp34_ = number_new_integer ((gint64) 0);
	result = _tmp34_;
	_number_unref0 (t2);
	return result;
}


Number* number_acos (Number* self, AngleUnit unit) {
	Number* result = NULL;
	Number* _tmp0_;
	Number* pi;
	Number* _tmp1_;
	Number* t1;
	Number* _tmp2_;
	Number* n1;
	Number* z = NULL;
	gboolean _tmp3_ = FALSE;
	Number* _tmp4_;
	gint _tmp5_ = 0;
	gboolean _tmp8_;
	Number* _tmp37_;
	AngleUnit _tmp38_;
	Number* _tmp39_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = number_new_pi ();
	pi = _tmp0_;
	_tmp1_ = number_new_integer ((gint64) 1);
	t1 = _tmp1_;
	_tmp2_ = number_new_integer ((gint64) (-1));
	n1 = _tmp2_;
	_tmp4_ = t1;
	_tmp5_ = number_compare (self, _tmp4_);
	if (_tmp5_ > 0) {
		_tmp3_ = TRUE;
	} else {
		Number* _tmp6_;
		gint _tmp7_ = 0;
		_tmp6_ = n1;
		_tmp7_ = number_compare (self, _tmp6_);
		_tmp3_ = _tmp7_ < 0;
	}
	_tmp8_ = _tmp3_;
	if (_tmp8_) {
		const gchar* _tmp9_ = NULL;
		Number* _tmp10_;
		_tmp9_ = _ ("Inverse cosine is undefined for values outside [-1, 1]");
		mperr (_tmp9_);
		_tmp10_ = number_new_integer ((gint64) 0);
		_number_unref0 (z);
		z = _tmp10_;
	} else {
		gboolean _tmp11_ = FALSE;
		_tmp11_ = number_is_zero (self);
		if (_tmp11_) {
			Number* _tmp12_;
			Number* _tmp13_ = NULL;
			_tmp12_ = pi;
			_tmp13_ = number_divide_integer (_tmp12_, (gint64) 2);
			_number_unref0 (z);
			z = _tmp13_;
		} else {
			Number* _tmp14_;
			gboolean _tmp15_ = FALSE;
			_tmp14_ = t1;
			_tmp15_ = number_equals (self, _tmp14_);
			if (_tmp15_) {
				Number* _tmp16_;
				_tmp16_ = number_new_integer ((gint64) 0);
				_number_unref0 (z);
				z = _tmp16_;
			} else {
				Number* _tmp17_;
				gboolean _tmp18_ = FALSE;
				_tmp17_ = n1;
				_tmp18_ = number_equals (self, _tmp17_);
				if (_tmp18_) {
					Number* _tmp19_;
					Number* _tmp20_;
					_tmp19_ = pi;
					_tmp20_ = _number_ref0 (_tmp19_);
					_number_unref0 (z);
					z = _tmp20_;
				} else {
					Number* y = NULL;
					Number* _tmp21_ = NULL;
					Number* t2;
					Number* _tmp22_;
					Number* _tmp23_;
					Number* _tmp24_ = NULL;
					Number* _tmp25_;
					Number* _tmp26_ = NULL;
					Number* _tmp27_;
					Number* _tmp28_ = NULL;
					Number* _tmp29_;
					Number* _tmp30_ = NULL;
					gint _tmp31_;
					_tmp21_ = number_multiply (self, self);
					t2 = _tmp21_;
					_tmp22_ = t1;
					_tmp23_ = t2;
					_tmp24_ = number_subtract (_tmp22_, _tmp23_);
					_number_unref0 (t2);
					t2 = _tmp24_;
					_tmp25_ = t2;
					_tmp26_ = number_sqrt (_tmp25_);
					_number_unref0 (t2);
					t2 = _tmp26_;
					_tmp27_ = t2;
					_tmp28_ = number_divide (_tmp27_, self);
					_number_unref0 (t2);
					t2 = _tmp28_;
					_tmp29_ = t2;
					_tmp30_ = number_atan (_tmp29_, ANGLE_UNIT_RADIANS);
					_number_unref0 (y);
					y = _tmp30_;
					_tmp31_ = self->re_sign;
					if (_tmp31_ > 0) {
						Number* _tmp32_;
						Number* _tmp33_;
						_tmp32_ = y;
						_tmp33_ = _number_ref0 (_tmp32_);
						_number_unref0 (z);
						z = _tmp33_;
					} else {
						Number* _tmp34_;
						Number* _tmp35_;
						Number* _tmp36_ = NULL;
						_tmp34_ = y;
						_tmp35_ = pi;
						_tmp36_ = number_add (_tmp34_, _tmp35_);
						_number_unref0 (z);
						z = _tmp36_;
					}
					_number_unref0 (t2);
					_number_unref0 (y);
				}
			}
		}
	}
	_tmp37_ = z;
	_tmp38_ = unit;
	_tmp39_ = number_from_radians (_tmp37_, _tmp38_);
	result = _tmp39_;
	_number_unref0 (z);
	_number_unref0 (n1);
	_number_unref0 (t1);
	_number_unref0 (pi);
	return result;
}


Number* number_atan (Number* self, AngleUnit unit) {
	Number* result = NULL;
	gboolean _tmp0_ = FALSE;
	Number* _tmp2_;
	Number* t2;
	gfloat rx;
	gint _tmp3_;
	gint _tmp4_ = 0;
	gint q;
	Number* z = NULL;
	Number* _tmp31_;
	Number* _tmp32_;
	Number* _tmp33_;
	Number* _tmp34_;
	Number* _tmp35_ = NULL;
	Number* t1;
	Number* _tmp55_;
	gint _tmp56_;
	Number* _tmp57_ = NULL;
	gint _tmp58_;
	gint _tmp59_ = 0;
	Number* _tmp68_;
	AngleUnit _tmp69_;
	Number* _tmp70_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = number_is_zero (self);
	if (_tmp0_) {
		Number* _tmp1_;
		_tmp1_ = number_new_integer ((gint64) 0);
		result = _tmp1_;
		return result;
	}
	_tmp2_ = _number_ref0 (self);
	t2 = _tmp2_;
	rx = 0.f;
	_tmp3_ = self->re_exponent;
	_tmp4_ = abs (_tmp3_);
	if (_tmp4_ <= 2) {
		gfloat _tmp5_ = 0.0F;
		_tmp5_ = number_to_float (self);
		rx = _tmp5_;
	}
	q = 1;
	while (TRUE) {
		Number* _tmp6_;
		gint _tmp7_;
		gboolean _tmp8_ = FALSE;
		Number* _tmp9_;
		gint _tmp10_;
		gboolean _tmp13_;
		gint _tmp14_;
		Number* _tmp15_;
		Number* _tmp16_;
		Number* _tmp17_ = NULL;
		Number* _tmp18_;
		Number* _tmp19_;
		Number* _tmp20_;
		Number* _tmp21_ = NULL;
		Number* _tmp22_;
		Number* _tmp23_ = NULL;
		Number* _tmp24_;
		Number* _tmp25_;
		Number* _tmp26_;
		Number* _tmp27_ = NULL;
		Number* _tmp28_;
		Number* _tmp29_;
		Number* _tmp30_ = NULL;
		_tmp6_ = t2;
		_tmp7_ = _tmp6_->re_exponent;
		if (!(_tmp7_ >= 0)) {
			break;
		}
		_tmp9_ = t2;
		_tmp10_ = _tmp9_->re_exponent;
		if (_tmp10_ == 0) {
			Number* _tmp11_;
			gint _tmp12_;
			_tmp11_ = t2;
			_tmp12_ = _tmp11_->re_fraction[0];
			_tmp8_ = (2 * (_tmp12_ + 1)) <= BASE;
		} else {
			_tmp8_ = FALSE;
		}
		_tmp13_ = _tmp8_;
		if (_tmp13_) {
			break;
		}
		_tmp14_ = q;
		q = _tmp14_ * 2;
		_tmp15_ = t2;
		_tmp16_ = t2;
		_tmp17_ = number_multiply (_tmp15_, _tmp16_);
		_number_unref0 (z);
		z = _tmp17_;
		_tmp18_ = z;
		_tmp19_ = number_new_integer ((gint64) 1);
		_tmp20_ = _tmp19_;
		_tmp21_ = number_add (_tmp18_, _tmp20_);
		_number_unref0 (z);
		z = _tmp21_;
		_number_unref0 (_tmp20_);
		_tmp22_ = z;
		_tmp23_ = number_sqrt (_tmp22_);
		_number_unref0 (z);
		z = _tmp23_;
		_tmp24_ = z;
		_tmp25_ = number_new_integer ((gint64) 1);
		_tmp26_ = _tmp25_;
		_tmp27_ = number_add (_tmp24_, _tmp26_);
		_number_unref0 (z);
		z = _tmp27_;
		_number_unref0 (_tmp26_);
		_tmp28_ = t2;
		_tmp29_ = z;
		_tmp30_ = number_divide (_tmp28_, _tmp29_);
		_number_unref0 (t2);
		t2 = _tmp30_;
	}
	_tmp31_ = t2;
	_tmp32_ = _number_ref0 (_tmp31_);
	_number_unref0 (z);
	z = _tmp32_;
	_tmp33_ = t2;
	_tmp34_ = t2;
	_tmp35_ = number_multiply (_tmp33_, _tmp34_);
	t1 = _tmp35_;
	{
		gint i;
		i = 1;
		{
			gboolean _tmp36_;
			_tmp36_ = TRUE;
			while (TRUE) {
				gboolean _tmp37_;
				Number* _tmp39_;
				gint _tmp40_;
				Number* _tmp41_;
				Number* _tmp42_;
				Number* _tmp43_ = NULL;
				Number* _tmp44_;
				gint _tmp45_;
				Number* _tmp46_ = NULL;
				Number* _tmp47_;
				gint _tmp48_;
				Number* _tmp49_ = NULL;
				Number* _tmp50_;
				Number* _tmp51_;
				Number* _tmp52_ = NULL;
				Number* _tmp53_;
				gboolean _tmp54_ = FALSE;
				_tmp37_ = _tmp36_;
				if (!_tmp37_) {
					gint _tmp38_;
					_tmp38_ = i;
					i = _tmp38_ + 2;
				}
				_tmp36_ = FALSE;
				_tmp39_ = t2;
				_tmp40_ = _tmp39_->re_exponent;
				if (((T + 2) + _tmp40_) <= 1) {
					break;
				}
				_tmp41_ = t2;
				_tmp42_ = t1;
				_tmp43_ = number_multiply (_tmp41_, _tmp42_);
				_tmp44_ = _tmp43_;
				_tmp45_ = i;
				_tmp46_ = number_multiply_integer (_tmp44_, (gint64) (-_tmp45_));
				_tmp47_ = _tmp46_;
				_tmp48_ = i;
				_tmp49_ = number_divide_integer (_tmp47_, (gint64) (_tmp48_ + 2));
				_number_unref0 (t2);
				t2 = _tmp49_;
				_number_unref0 (_tmp47_);
				_number_unref0 (_tmp44_);
				_tmp50_ = z;
				_tmp51_ = t2;
				_tmp52_ = number_add (_tmp50_, _tmp51_);
				_number_unref0 (z);
				z = _tmp52_;
				_tmp53_ = t2;
				_tmp54_ = number_is_zero (_tmp53_);
				if (_tmp54_) {
					break;
				}
			}
		}
	}
	_tmp55_ = z;
	_tmp56_ = q;
	_tmp57_ = number_multiply_integer (_tmp55_, (gint64) _tmp56_);
	_number_unref0 (z);
	z = _tmp57_;
	_tmp58_ = self->re_exponent;
	_tmp59_ = abs (_tmp58_);
	if (_tmp59_ <= 2) {
		Number* _tmp60_;
		gfloat _tmp61_ = 0.0F;
		gfloat ry;
		gfloat _tmp62_;
		gfloat _tmp63_;
		gdouble _tmp64_ = 0.0;
		gdouble _tmp65_ = 0.0;
		gfloat _tmp66_;
		gdouble _tmp67_ = 0.0;
		_tmp60_ = z;
		_tmp61_ = number_to_float (_tmp60_);
		ry = _tmp61_;
		_tmp62_ = ry;
		_tmp63_ = rx;
		_tmp64_ = atan ((gdouble) _tmp63_);
		_tmp65_ = fabs (_tmp62_ - _tmp64_);
		_tmp66_ = ry;
		_tmp67_ = fabs ((gdouble) _tmp66_);
		if (_tmp65_ >= (_tmp67_ * 0.01)) {
			mperr ("*** ERROR OCCURRED IN ATAN, RESULT INCORRECT ***");
		}
	}
	_tmp68_ = z;
	_tmp69_ = unit;
	_tmp70_ = number_from_radians (_tmp68_, _tmp69_);
	result = _tmp70_;
	_number_unref0 (t1);
	_number_unref0 (z);
	_number_unref0 (t2);
	return result;
}


Number* number_sinh (Number* self) {
	Number* result = NULL;
	gboolean _tmp0_ = FALSE;
	Number* _tmp2_ = NULL;
	Number* abs_x;
	Number* z = NULL;
	Number* _tmp3_;
	gint _tmp4_;
	Number* _tmp30_;
	Number* _tmp31_ = NULL;
	Number* _tmp32_;
	gint _tmp33_;
	Number* _tmp34_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = number_is_zero (self);
	if (_tmp0_) {
		Number* _tmp1_;
		_tmp1_ = number_new_integer ((gint64) 0);
		result = _tmp1_;
		return result;
	}
	_tmp2_ = number_abs (self);
	abs_x = _tmp2_;
	_tmp3_ = abs_x;
	_tmp4_ = _tmp3_->re_exponent;
	if (_tmp4_ <= 0) {
		Number* _tmp5_;
		Number* _tmp6_ = NULL;
		Number* exp_x;
		Number* _tmp7_;
		Number* _tmp8_;
		Number* _tmp9_;
		Number* _tmp10_ = NULL;
		Number* _tmp11_;
		Number* a;
		Number* _tmp12_;
		Number* _tmp13_;
		Number* _tmp14_;
		Number* _tmp15_ = NULL;
		Number* _tmp16_;
		Number* b;
		Number* _tmp17_;
		Number* _tmp18_;
		Number* _tmp19_ = NULL;
		Number* _tmp20_;
		Number* _tmp21_;
		Number* _tmp22_ = NULL;
		_tmp5_ = abs_x;
		_tmp6_ = number_epowy (_tmp5_);
		exp_x = _tmp6_;
		_tmp7_ = exp_x;
		_tmp8_ = number_new_integer ((gint64) 1);
		_tmp9_ = _tmp8_;
		_tmp10_ = number_add (_tmp7_, _tmp9_);
		_tmp11_ = _tmp10_;
		_number_unref0 (_tmp9_);
		a = _tmp11_;
		_tmp12_ = exp_x;
		_tmp13_ = number_new_integer ((gint64) (-1));
		_tmp14_ = _tmp13_;
		_tmp15_ = number_add (_tmp12_, _tmp14_);
		_tmp16_ = _tmp15_;
		_number_unref0 (_tmp14_);
		b = _tmp16_;
		_tmp17_ = a;
		_tmp18_ = b;
		_tmp19_ = number_multiply (_tmp17_, _tmp18_);
		_number_unref0 (z);
		z = _tmp19_;
		_tmp20_ = z;
		_tmp21_ = exp_x;
		_tmp22_ = number_divide (_tmp20_, _tmp21_);
		_number_unref0 (z);
		z = _tmp22_;
		_number_unref0 (b);
		_number_unref0 (a);
		_number_unref0 (exp_x);
	} else {
		Number* _tmp23_;
		Number* _tmp24_ = NULL;
		Number* exp_x;
		Number* _tmp25_;
		Number* _tmp26_ = NULL;
		Number* _tmp27_;
		Number* _tmp28_;
		Number* _tmp29_ = NULL;
		_tmp23_ = abs_x;
		_tmp24_ = number_epowy (_tmp23_);
		exp_x = _tmp24_;
		_tmp25_ = exp_x;
		_tmp26_ = number_reciprocal (_tmp25_);
		_number_unref0 (z);
		z = _tmp26_;
		_tmp27_ = exp_x;
		_tmp28_ = z;
		_tmp29_ = number_subtract (_tmp27_, _tmp28_);
		_number_unref0 (z);
		z = _tmp29_;
		_number_unref0 (exp_x);
	}
	_tmp30_ = z;
	_tmp31_ = number_divide_integer (_tmp30_, (gint64) 2);
	_number_unref0 (z);
	z = _tmp31_;
	_tmp32_ = z;
	_tmp33_ = self->re_sign;
	_tmp34_ = number_multiply_integer (_tmp32_, (gint64) _tmp33_);
	result = _tmp34_;
	_number_unref0 (z);
	_number_unref0 (abs_x);
	return result;
}


Number* number_cosh (Number* self) {
	Number* result = NULL;
	gboolean _tmp0_ = FALSE;
	Number* _tmp2_ = NULL;
	Number* t;
	Number* _tmp3_;
	Number* _tmp4_ = NULL;
	Number* _tmp5_;
	Number* _tmp6_ = NULL;
	Number* z;
	Number* _tmp7_;
	Number* _tmp8_;
	Number* _tmp9_ = NULL;
	Number* _tmp10_;
	Number* _tmp11_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = number_is_zero (self);
	if (_tmp0_) {
		Number* _tmp1_;
		_tmp1_ = number_new_integer ((gint64) 1);
		result = _tmp1_;
		return result;
	}
	_tmp2_ = number_abs (self);
	t = _tmp2_;
	_tmp3_ = t;
	_tmp4_ = number_epowy (_tmp3_);
	_number_unref0 (t);
	t = _tmp4_;
	_tmp5_ = t;
	_tmp6_ = number_reciprocal (_tmp5_);
	z = _tmp6_;
	_tmp7_ = t;
	_tmp8_ = z;
	_tmp9_ = number_add (_tmp7_, _tmp8_);
	_number_unref0 (z);
	z = _tmp9_;
	_tmp10_ = z;
	_tmp11_ = number_divide_integer (_tmp10_, (gint64) 2);
	result = _tmp11_;
	_number_unref0 (z);
	_number_unref0 (t);
	return result;
}


Number* number_tanh (Number* self) {
	Number* result = NULL;
	gboolean _tmp0_ = FALSE;
	Number* _tmp2_ = NULL;
	Number* t;
	gdouble _tmp3_ = 0.0;
	gdouble r__1;
	gdouble _tmp4_;
	Number* _tmp5_;
	Number* z;
	Number* _tmp6_;
	Number* _tmp7_;
	gint _tmp8_ = 0;
	Number* _tmp11_;
	Number* _tmp12_ = NULL;
	Number* _tmp13_;
	gint _tmp14_;
	Number* _tmp41_;
	gint _tmp42_;
	Number* _tmp43_;
	gint _tmp44_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = number_is_zero (self);
	if (_tmp0_) {
		Number* _tmp1_;
		_tmp1_ = number_new_integer ((gint64) 0);
		result = _tmp1_;
		return result;
	}
	_tmp2_ = number_abs (self);
	t = _tmp2_;
	_tmp3_ = log ((gdouble) ((gfloat) BASE));
	r__1 = (((gfloat) T) * 0.5) * _tmp3_;
	_tmp4_ = r__1;
	_tmp5_ = number_new_double (_tmp4_);
	z = _tmp5_;
	_tmp6_ = t;
	_tmp7_ = z;
	_tmp8_ = number_compare (_tmp6_, _tmp7_);
	if (_tmp8_ > 0) {
		gint _tmp9_;
		Number* _tmp10_;
		_tmp9_ = self->re_sign;
		_tmp10_ = number_new_integer ((gint64) _tmp9_);
		result = _tmp10_;
		_number_unref0 (z);
		_number_unref0 (t);
		return result;
	}
	_tmp11_ = t;
	_tmp12_ = number_multiply_integer (_tmp11_, (gint64) 2);
	_number_unref0 (t);
	t = _tmp12_;
	_tmp13_ = t;
	_tmp14_ = _tmp13_->re_exponent;
	if (_tmp14_ > 0) {
		Number* _tmp15_;
		Number* _tmp16_ = NULL;
		Number* _tmp17_;
		Number* _tmp18_;
		Number* _tmp19_;
		Number* _tmp20_ = NULL;
		Number* _tmp21_;
		Number* _tmp22_;
		Number* _tmp23_;
		Number* _tmp24_ = NULL;
		Number* _tmp25_;
		Number* _tmp26_;
		Number* _tmp27_ = NULL;
		_tmp15_ = t;
		_tmp16_ = number_epowy (_tmp15_);
		_number_unref0 (t);
		t = _tmp16_;
		_tmp17_ = t;
		_tmp18_ = number_new_integer ((gint64) (-1));
		_tmp19_ = _tmp18_;
		_tmp20_ = number_add (_tmp17_, _tmp19_);
		_number_unref0 (z);
		z = _tmp20_;
		_number_unref0 (_tmp19_);
		_tmp21_ = t;
		_tmp22_ = number_new_integer ((gint64) 1);
		_tmp23_ = _tmp22_;
		_tmp24_ = number_add (_tmp21_, _tmp23_);
		_number_unref0 (t);
		t = _tmp24_;
		_number_unref0 (_tmp23_);
		_tmp25_ = z;
		_tmp26_ = t;
		_tmp27_ = number_divide (_tmp25_, _tmp26_);
		_number_unref0 (z);
		z = _tmp27_;
	} else {
		Number* _tmp28_;
		Number* _tmp29_ = NULL;
		Number* _tmp30_;
		Number* _tmp31_;
		Number* _tmp32_;
		Number* _tmp33_ = NULL;
		Number* _tmp34_;
		Number* _tmp35_;
		Number* _tmp36_;
		Number* _tmp37_ = NULL;
		Number* _tmp38_;
		Number* _tmp39_;
		Number* _tmp40_ = NULL;
		_tmp28_ = t;
		_tmp29_ = number_epowy (_tmp28_);
		_number_unref0 (t);
		t = _tmp29_;
		_tmp30_ = t;
		_tmp31_ = number_new_integer ((gint64) 1);
		_tmp32_ = _tmp31_;
		_tmp33_ = number_add (_tmp30_, _tmp32_);
		_number_unref0 (z);
		z = _tmp33_;
		_number_unref0 (_tmp32_);
		_tmp34_ = t;
		_tmp35_ = number_new_integer ((gint64) (-1));
		_tmp36_ = _tmp35_;
		_tmp37_ = number_add (_tmp34_, _tmp36_);
		_number_unref0 (t);
		t = _tmp37_;
		_number_unref0 (_tmp36_);
		_tmp38_ = t;
		_tmp39_ = z;
		_tmp40_ = number_divide (_tmp38_, _tmp39_);
		_number_unref0 (z);
		z = _tmp40_;
	}
	_tmp41_ = z;
	_tmp42_ = self->re_sign;
	_tmp43_ = z;
	_tmp44_ = _tmp43_->re_sign;
	_tmp41_->re_sign = _tmp42_ * _tmp44_;
	result = z;
	_number_unref0 (t);
	return result;
}


Number* number_asinh (Number* self) {
	Number* result = NULL;
	Number* _tmp0_ = NULL;
	Number* t;
	Number* _tmp1_;
	Number* _tmp2_;
	Number* _tmp3_;
	Number* _tmp4_ = NULL;
	Number* _tmp5_;
	Number* _tmp6_ = NULL;
	Number* _tmp7_;
	Number* _tmp8_ = NULL;
	Number* _tmp9_;
	Number* _tmp10_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = number_multiply (self, self);
	t = _tmp0_;
	_tmp1_ = t;
	_tmp2_ = number_new_integer ((gint64) 1);
	_tmp3_ = _tmp2_;
	_tmp4_ = number_add (_tmp1_, _tmp3_);
	_number_unref0 (t);
	t = _tmp4_;
	_number_unref0 (_tmp3_);
	_tmp5_ = t;
	_tmp6_ = number_sqrt (_tmp5_);
	_number_unref0 (t);
	t = _tmp6_;
	_tmp7_ = t;
	_tmp8_ = number_add (self, _tmp7_);
	_number_unref0 (t);
	t = _tmp8_;
	_tmp9_ = t;
	_tmp10_ = number_ln (_tmp9_);
	result = _tmp10_;
	_number_unref0 (t);
	return result;
}


Number* number_acosh (Number* self) {
	Number* result = NULL;
	Number* _tmp0_;
	Number* t;
	Number* _tmp1_;
	gint _tmp2_ = 0;
	Number* _tmp5_ = NULL;
	Number* _tmp6_;
	Number* _tmp7_;
	Number* _tmp8_;
	Number* _tmp9_ = NULL;
	Number* _tmp10_;
	Number* _tmp11_ = NULL;
	Number* _tmp12_;
	Number* _tmp13_ = NULL;
	Number* _tmp14_;
	Number* _tmp15_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = number_new_integer ((gint64) 1);
	t = _tmp0_;
	_tmp1_ = t;
	_tmp2_ = number_compare (self, _tmp1_);
	if (_tmp2_ < 0) {
		const gchar* _tmp3_ = NULL;
		Number* _tmp4_;
		_tmp3_ = _ ("Inverse hyperbolic cosine is undefined for values less than one");
		mperr (_tmp3_);
		_tmp4_ = number_new_integer ((gint64) 0);
		result = _tmp4_;
		_number_unref0 (t);
		return result;
	}
	_tmp5_ = number_multiply (self, self);
	_number_unref0 (t);
	t = _tmp5_;
	_tmp6_ = t;
	_tmp7_ = number_new_integer ((gint64) (-1));
	_tmp8_ = _tmp7_;
	_tmp9_ = number_add (_tmp6_, _tmp8_);
	_number_unref0 (t);
	t = _tmp9_;
	_number_unref0 (_tmp8_);
	_tmp10_ = t;
	_tmp11_ = number_sqrt (_tmp10_);
	_number_unref0 (t);
	t = _tmp11_;
	_tmp12_ = t;
	_tmp13_ = number_add (self, _tmp12_);
	_number_unref0 (t);
	t = _tmp13_;
	_tmp14_ = t;
	_tmp15_ = number_ln (_tmp14_);
	result = _tmp15_;
	_number_unref0 (t);
	return result;
}


Number* number_atanh (Number* self) {
	Number* result = NULL;
	gboolean _tmp0_ = FALSE;
	Number* _tmp1_;
	Number* _tmp2_;
	gint _tmp3_ = 0;
	gboolean _tmp4_;
	gboolean _tmp8_;
	Number* _tmp11_;
	Number* _tmp12_;
	Number* _tmp13_ = NULL;
	Number* _tmp14_;
	Number* n;
	Number* _tmp15_ = NULL;
	Number* d;
	Number* _tmp16_;
	Number* _tmp17_;
	Number* _tmp18_;
	Number* _tmp19_ = NULL;
	Number* _tmp20_;
	Number* _tmp21_;
	Number* _tmp22_ = NULL;
	Number* z;
	Number* _tmp23_;
	Number* _tmp24_ = NULL;
	Number* _tmp25_;
	Number* _tmp26_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp1_ = number_new_integer ((gint64) 1);
	_tmp2_ = _tmp1_;
	_tmp3_ = number_compare (self, _tmp2_);
	_tmp4_ = _tmp3_ >= 0;
	_number_unref0 (_tmp2_);
	if (_tmp4_) {
		_tmp0_ = TRUE;
	} else {
		Number* _tmp5_;
		Number* _tmp6_;
		gint _tmp7_ = 0;
		_tmp5_ = number_new_integer ((gint64) (-1));
		_tmp6_ = _tmp5_;
		_tmp7_ = number_compare (self, _tmp6_);
		_tmp0_ = _tmp7_ <= 0;
		_number_unref0 (_tmp6_);
	}
	_tmp8_ = _tmp0_;
	if (_tmp8_) {
		const gchar* _tmp9_ = NULL;
		Number* _tmp10_;
		_tmp9_ = _ ("Inverse hyperbolic tangent is undefined for values outside [-1, 1]");
		mperr (_tmp9_);
		_tmp10_ = number_new_integer ((gint64) 0);
		result = _tmp10_;
		return result;
	}
	_tmp11_ = number_new_integer ((gint64) 1);
	_tmp12_ = _tmp11_;
	_tmp13_ = number_add (self, _tmp12_);
	_tmp14_ = _tmp13_;
	_number_unref0 (_tmp12_);
	n = _tmp14_;
	_tmp15_ = number_invert_sign (self);
	d = _tmp15_;
	_tmp16_ = d;
	_tmp17_ = number_new_integer ((gint64) 1);
	_tmp18_ = _tmp17_;
	_tmp19_ = number_add (_tmp16_, _tmp18_);
	_number_unref0 (d);
	d = _tmp19_;
	_number_unref0 (_tmp18_);
	_tmp20_ = n;
	_tmp21_ = d;
	_tmp22_ = number_divide (_tmp20_, _tmp21_);
	z = _tmp22_;
	_tmp23_ = z;
	_tmp24_ = number_ln (_tmp23_);
	_number_unref0 (z);
	z = _tmp24_;
	_tmp25_ = z;
	_tmp26_ = number_divide_integer (_tmp25_, (gint64) 2);
	result = _tmp26_;
	_number_unref0 (z);
	_number_unref0 (d);
	_number_unref0 (n);
	return result;
}


static gint __lambda2_ (Number* self, gint v1, gint v2) {
	gint result = 0;
	gint _tmp0_;
	gint _tmp1_;
	_tmp0_ = v1;
	_tmp1_ = v2;
	result = _tmp0_ & _tmp1_;
	return result;
}


static gint ___lambda2__bitwise_func (gint v1, gint v2, gpointer self) {
	gint result;
	result = __lambda2_ (self, v1, v2);
	return result;
}


Number* number_and (Number* self, Number* y) {
	Number* result = NULL;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp4_;
	Number* _tmp6_;
	Number* _tmp7_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (y != NULL, NULL);
	_tmp1_ = number_is_positive_integer (self);
	if (!_tmp1_) {
		_tmp0_ = TRUE;
	} else {
		Number* _tmp2_;
		gboolean _tmp3_ = FALSE;
		_tmp2_ = y;
		_tmp3_ = number_is_positive_integer (_tmp2_);
		_tmp0_ = !_tmp3_;
	}
	_tmp4_ = _tmp0_;
	if (_tmp4_) {
		const gchar* _tmp5_ = NULL;
		_tmp5_ = _ ("Boolean AND is only defined for positive integers");
		mperr (_tmp5_);
	}
	_tmp6_ = y;
	_tmp7_ = number_bitwise (self, _tmp6_, ___lambda2__bitwise_func, self, 0);
	result = _tmp7_;
	return result;
}


static gint __lambda3_ (Number* self, gint v1, gint v2) {
	gint result = 0;
	gint _tmp0_;
	gint _tmp1_;
	_tmp0_ = v1;
	_tmp1_ = v2;
	result = _tmp0_ | _tmp1_;
	return result;
}


static gint ___lambda3__bitwise_func (gint v1, gint v2, gpointer self) {
	gint result;
	result = __lambda3_ (self, v1, v2);
	return result;
}


Number* number_or (Number* self, Number* y) {
	Number* result = NULL;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp4_;
	Number* _tmp6_;
	Number* _tmp7_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (y != NULL, NULL);
	_tmp1_ = number_is_positive_integer (self);
	if (!_tmp1_) {
		_tmp0_ = TRUE;
	} else {
		Number* _tmp2_;
		gboolean _tmp3_ = FALSE;
		_tmp2_ = y;
		_tmp3_ = number_is_positive_integer (_tmp2_);
		_tmp0_ = !_tmp3_;
	}
	_tmp4_ = _tmp0_;
	if (_tmp4_) {
		const gchar* _tmp5_ = NULL;
		_tmp5_ = _ ("Boolean OR is only defined for positive integers");
		mperr (_tmp5_);
	}
	_tmp6_ = y;
	_tmp7_ = number_bitwise (self, _tmp6_, ___lambda3__bitwise_func, self, 0);
	result = _tmp7_;
	return result;
}


static gint __lambda4_ (Number* self, gint v1, gint v2) {
	gint result = 0;
	gint _tmp0_;
	gint _tmp1_;
	_tmp0_ = v1;
	_tmp1_ = v2;
	result = _tmp0_ ^ _tmp1_;
	return result;
}


static gint ___lambda4__bitwise_func (gint v1, gint v2, gpointer self) {
	gint result;
	result = __lambda4_ (self, v1, v2);
	return result;
}


Number* number_xor (Number* self, Number* y) {
	Number* result = NULL;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp4_;
	Number* _tmp6_;
	Number* _tmp7_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (y != NULL, NULL);
	_tmp1_ = number_is_positive_integer (self);
	if (!_tmp1_) {
		_tmp0_ = TRUE;
	} else {
		Number* _tmp2_;
		gboolean _tmp3_ = FALSE;
		_tmp2_ = y;
		_tmp3_ = number_is_positive_integer (_tmp2_);
		_tmp0_ = !_tmp3_;
	}
	_tmp4_ = _tmp0_;
	if (_tmp4_) {
		const gchar* _tmp5_ = NULL;
		_tmp5_ = _ ("Boolean XOR is only defined for positive integers");
		mperr (_tmp5_);
	}
	_tmp6_ = y;
	_tmp7_ = number_bitwise (self, _tmp6_, ___lambda4__bitwise_func, self, 0);
	result = _tmp7_;
	return result;
}


static gint __lambda5_ (Number* self, gint v1, gint v2) {
	gint result = 0;
	gint _tmp0_;
	_tmp0_ = v1;
	result = _tmp0_ ^ 0xF;
	return result;
}


static gint ___lambda5__bitwise_func (gint v1, gint v2, gpointer self) {
	gint result;
	result = __lambda5_ (self, v1, v2);
	return result;
}


Number* number_not (Number* self, gint wordlen) {
	Number* result = NULL;
	gboolean _tmp0_ = FALSE;
	Number* _tmp2_;
	Number* _tmp3_;
	gint _tmp4_;
	Number* _tmp5_ = NULL;
	Number* _tmp6_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = number_is_positive_integer (self);
	if (!_tmp0_) {
		const gchar* _tmp1_ = NULL;
		_tmp1_ = _ ("Boolean NOT is only defined for positive integers");
		mperr (_tmp1_);
	}
	_tmp2_ = number_new_integer ((gint64) 0);
	_tmp3_ = _tmp2_;
	_tmp4_ = wordlen;
	_tmp5_ = number_bitwise (self, _tmp3_, ___lambda5__bitwise_func, self, _tmp4_);
	_tmp6_ = _tmp5_;
	_number_unref0 (_tmp3_);
	result = _tmp6_;
	return result;
}


static glong string_strnlen (gchar* str, glong maxlen) {
	glong result = 0L;
	gchar* _tmp0_;
	glong _tmp1_;
	gchar* _tmp2_ = NULL;
	gchar* end;
	gchar* _tmp3_;
	_tmp0_ = str;
	_tmp1_ = maxlen;
	_tmp2_ = memchr (_tmp0_, 0, (gsize) _tmp1_);
	end = _tmp2_;
	_tmp3_ = end;
	if (_tmp3_ == NULL) {
		glong _tmp4_;
		_tmp4_ = maxlen;
		result = _tmp4_;
		return result;
	} else {
		gchar* _tmp5_;
		gchar* _tmp6_;
		_tmp5_ = end;
		_tmp6_ = str;
		result = (glong) (_tmp5_ - _tmp6_);
		return result;
	}
}


static gchar* string_substring (const gchar* self, glong offset, glong len) {
	gchar* result = NULL;
	glong string_length = 0L;
	gboolean _tmp0_ = FALSE;
	glong _tmp1_;
	gboolean _tmp3_;
	glong _tmp9_;
	glong _tmp15_;
	glong _tmp18_;
	glong _tmp19_;
	glong _tmp20_;
	glong _tmp21_;
	glong _tmp22_;
	gchar* _tmp23_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp1_ = offset;
	if (_tmp1_ >= ((glong) 0)) {
		glong _tmp2_;
		_tmp2_ = len;
		_tmp0_ = _tmp2_ >= ((glong) 0);
	} else {
		_tmp0_ = FALSE;
	}
	_tmp3_ = _tmp0_;
	if (_tmp3_) {
		glong _tmp4_;
		glong _tmp5_;
		glong _tmp6_ = 0L;
		_tmp4_ = offset;
		_tmp5_ = len;
		_tmp6_ = string_strnlen ((gchar*) self, _tmp4_ + _tmp5_);
		string_length = _tmp6_;
	} else {
		gint _tmp7_;
		gint _tmp8_;
		_tmp7_ = strlen (self);
		_tmp8_ = _tmp7_;
		string_length = (glong) _tmp8_;
	}
	_tmp9_ = offset;
	if (_tmp9_ < ((glong) 0)) {
		glong _tmp10_;
		glong _tmp11_;
		glong _tmp12_;
		_tmp10_ = string_length;
		_tmp11_ = offset;
		offset = _tmp10_ + _tmp11_;
		_tmp12_ = offset;
		g_return_val_if_fail (_tmp12_ >= ((glong) 0), NULL);
	} else {
		glong _tmp13_;
		glong _tmp14_;
		_tmp13_ = offset;
		_tmp14_ = string_length;
		g_return_val_if_fail (_tmp13_ <= _tmp14_, NULL);
	}
	_tmp15_ = len;
	if (_tmp15_ < ((glong) 0)) {
		glong _tmp16_;
		glong _tmp17_;
		_tmp16_ = string_length;
		_tmp17_ = offset;
		len = _tmp16_ - _tmp17_;
	}
	_tmp18_ = offset;
	_tmp19_ = len;
	_tmp20_ = string_length;
	g_return_val_if_fail ((_tmp18_ + _tmp19_) <= _tmp20_, NULL);
	_tmp21_ = offset;
	_tmp22_ = len;
	_tmp23_ = g_strndup (((gchar*) self) + _tmp21_, (gsize) _tmp22_);
	result = _tmp23_;
	return result;
}


Number* number_mask (Number* self, Number* x, gint wordlen) {
	Number* result = NULL;
	Number* _tmp0_;
	gchar* _tmp1_ = NULL;
	gchar* text;
	const gchar* _tmp2_;
	gint _tmp3_;
	gint _tmp4_;
	gint len;
	gint _tmp5_;
	gint offset;
	gint _tmp6_ = 0;
	gint _tmp7_;
	gint _tmp8_;
	gint _tmp11_;
	const gchar* _tmp12_;
	gint _tmp13_;
	gchar* _tmp14_ = NULL;
	gchar* _tmp15_;
	Number* _tmp16_ = NULL;
	Number* _tmp17_;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (x != NULL, NULL);
	_tmp0_ = x;
	_tmp1_ = number_to_hex_string (_tmp0_);
	text = _tmp1_;
	_tmp2_ = text;
	_tmp3_ = strlen (_tmp2_);
	_tmp4_ = _tmp3_;
	len = _tmp4_;
	_tmp5_ = wordlen;
	offset = _tmp5_ / 4;
	_tmp7_ = len;
	_tmp8_ = offset;
	if (_tmp7_ > _tmp8_) {
		gint _tmp9_;
		gint _tmp10_;
		_tmp9_ = len;
		_tmp10_ = offset;
		_tmp6_ = ((gint) _tmp9_) - _tmp10_;
	} else {
		_tmp6_ = 0;
	}
	_tmp11_ = _tmp6_;
	offset = _tmp11_;
	_tmp12_ = text;
	_tmp13_ = offset;
	_tmp14_ = string_substring (_tmp12_, (glong) _tmp13_, (glong) (-1));
	_tmp15_ = _tmp14_;
	_tmp16_ = mp_set_from_string (_tmp15_, 16);
	_tmp17_ = _tmp16_;
	_g_free0 (_tmp15_);
	result = _tmp17_;
	_g_free0 (text);
	return result;
}


Number* number_shift (Number* self, gint count) {
	Number* result = NULL;
	gboolean _tmp0_ = FALSE;
	gint _tmp3_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = number_is_integer (self);
	if (!_tmp0_) {
		const gchar* _tmp1_ = NULL;
		Number* _tmp2_;
		_tmp1_ = _ ("Shift is only possible on integer values");
		mperr (_tmp1_);
		_tmp2_ = number_new_integer ((gint64) 0);
		result = _tmp2_;
		return result;
	}
	_tmp3_ = count;
	if (_tmp3_ >= 0) {
		gint multiplier;
		gint _tmp10_;
		Number* _tmp11_ = NULL;
		multiplier = 1;
		{
			gint i;
			i = 0;
			{
				gboolean _tmp4_;
				_tmp4_ = TRUE;
				while (TRUE) {
					gboolean _tmp5_;
					gint _tmp7_;
					gint _tmp8_;
					gint _tmp9_;
					_tmp5_ = _tmp4_;
					if (!_tmp5_) {
						gint _tmp6_;
						_tmp6_ = i;
						i = _tmp6_ + 1;
					}
					_tmp4_ = FALSE;
					_tmp7_ = i;
					_tmp8_ = count;
					if (!(_tmp7_ < _tmp8_)) {
						break;
					}
					_tmp9_ = multiplier;
					multiplier = _tmp9_ * 2;
				}
			}
		}
		_tmp10_ = multiplier;
		_tmp11_ = number_multiply_integer (self, (gint64) _tmp10_);
		result = _tmp11_;
		return result;
	} else {
		gint multiplier;
		gint _tmp18_;
		Number* _tmp19_ = NULL;
		Number* _tmp20_;
		Number* _tmp21_ = NULL;
		Number* _tmp22_;
		multiplier = 1;
		{
			gint i;
			i = 0;
			{
				gboolean _tmp12_;
				_tmp12_ = TRUE;
				while (TRUE) {
					gboolean _tmp13_;
					gint _tmp15_;
					gint _tmp16_;
					gint _tmp17_;
					_tmp13_ = _tmp12_;
					if (!_tmp13_) {
						gint _tmp14_;
						_tmp14_ = i;
						i = _tmp14_ + 1;
					}
					_tmp12_ = FALSE;
					_tmp15_ = i;
					_tmp16_ = count;
					if (!(_tmp15_ < (-_tmp16_))) {
						break;
					}
					_tmp17_ = multiplier;
					multiplier = _tmp17_ * 2;
				}
			}
		}
		_tmp18_ = multiplier;
		_tmp19_ = number_divide_integer (self, (gint64) _tmp18_);
		_tmp20_ = _tmp19_;
		_tmp21_ = number_floor (_tmp20_);
		_tmp22_ = _tmp21_;
		_number_unref0 (_tmp20_);
		result = _tmp22_;
		return result;
	}
}


static gint __lambda6_ (Number* self, gint v1, gint v2) {
	gint result = 0;
	gint _tmp0_;
	gint _tmp1_;
	_tmp0_ = v1;
	_tmp1_ = v2;
	result = _tmp0_ ^ _tmp1_;
	return result;
}


static gint ___lambda6__bitwise_func (gint v1, gint v2, gpointer self) {
	gint result;
	result = __lambda6_ (self, v1, v2);
	return result;
}


Number* number_ones_complement (Number* self, gint wordlen) {
	Number* result = NULL;
	Number* _tmp0_;
	Number* _tmp1_;
	gint _tmp2_;
	Number* _tmp3_ = NULL;
	Number* _tmp4_;
	gint _tmp5_;
	Number* _tmp6_ = NULL;
	Number* _tmp7_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = number_new_integer ((gint64) 0);
	_tmp1_ = _tmp0_;
	_tmp2_ = wordlen;
	_tmp3_ = number_bitwise (self, _tmp1_, ___lambda6__bitwise_func, self, _tmp2_);
	_tmp4_ = _tmp3_;
	_tmp5_ = wordlen;
	_tmp6_ = number_not (_tmp4_, _tmp5_);
	_tmp7_ = _tmp6_;
	_number_unref0 (_tmp4_);
	_number_unref0 (_tmp1_);
	result = _tmp7_;
	return result;
}


Number* number_twos_complement (Number* self, gint wordlen) {
	Number* result = NULL;
	gint _tmp0_;
	Number* _tmp1_ = NULL;
	Number* _tmp2_;
	Number* _tmp3_;
	Number* _tmp4_;
	Number* _tmp5_ = NULL;
	Number* _tmp6_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = wordlen;
	_tmp1_ = number_ones_complement (self, _tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = number_new_integer ((gint64) 1);
	_tmp4_ = _tmp3_;
	_tmp5_ = number_add (_tmp2_, _tmp4_);
	_tmp6_ = _tmp5_;
	_number_unref0 (_tmp4_);
	_number_unref0 (_tmp2_);
	result = _tmp6_;
	return result;
}


static void _number_unref0_ (gpointer var) {
	(var == NULL) ? NULL : (var = (number_unref (var), NULL));
}


static void _g_list_free__number_unref0_ (GList* self) {
	g_list_foreach (self, (GFunc) _number_unref0_, NULL);
	g_list_free (self);
}


GList* number_factorize (Number* self) {
	GList* result = NULL;
	GList* factors;
	Number* _tmp0_ = NULL;
	Number* value;
	Number* _tmp1_;
	gboolean _tmp2_ = FALSE;
	Number* _tmp5_;
	Number* _tmp6_;
	Number* _tmp7_;
	gboolean _tmp8_ = FALSE;
	gboolean _tmp9_;
	Number* _tmp11_;
	Number* divisor;
	Number* _tmp21_;
	Number* _tmp22_;
	Number* _tmp23_ = NULL;
	Number* root;
	Number* _tmp44_;
	Number* _tmp45_;
	Number* _tmp46_;
	gint _tmp47_ = 0;
	gboolean _tmp48_;
	gboolean _tmp51_ = FALSE;
	g_return_val_if_fail (self != NULL, NULL);
	factors = NULL;
	_tmp0_ = number_abs (self);
	value = _tmp0_;
	_tmp1_ = value;
	_tmp2_ = number_is_zero (_tmp1_);
	if (_tmp2_) {
		Number* _tmp3_;
		Number* _tmp4_;
		_tmp3_ = value;
		_tmp4_ = _number_ref0 (_tmp3_);
		factors = g_list_append (factors, _tmp4_);
		result = factors;
		_number_unref0 (value);
		return result;
	}
	_tmp5_ = value;
	_tmp6_ = number_new_integer ((gint64) 1);
	_tmp7_ = _tmp6_;
	_tmp8_ = number_equals (_tmp5_, _tmp7_);
	_tmp9_ = _tmp8_;
	_number_unref0 (_tmp7_);
	if (_tmp9_) {
		Number* _tmp10_;
		_tmp10_ = _number_ref0 (self);
		factors = g_list_append (factors, _tmp10_);
		result = factors;
		_number_unref0 (value);
		return result;
	}
	_tmp11_ = number_new_integer ((gint64) 2);
	divisor = _tmp11_;
	while (TRUE) {
		Number* _tmp12_;
		Number* _tmp13_;
		Number* _tmp14_ = NULL;
		Number* tmp;
		Number* _tmp15_;
		gboolean _tmp16_ = FALSE;
		_tmp12_ = value;
		_tmp13_ = divisor;
		_tmp14_ = number_divide (_tmp12_, _tmp13_);
		tmp = _tmp14_;
		_tmp15_ = tmp;
		_tmp16_ = number_is_integer (_tmp15_);
		if (_tmp16_) {
			Number* _tmp17_;
			Number* _tmp18_;
			Number* _tmp19_;
			Number* _tmp20_;
			_tmp17_ = tmp;
			_tmp18_ = _number_ref0 (_tmp17_);
			_number_unref0 (value);
			value = _tmp18_;
			_tmp19_ = divisor;
			_tmp20_ = _number_ref0 (_tmp19_);
			factors = g_list_append (factors, _tmp20_);
		} else {
			_number_unref0 (tmp);
			break;
		}
		_number_unref0 (tmp);
	}
	_tmp21_ = number_new_integer ((gint64) 3);
	_number_unref0 (divisor);
	divisor = _tmp21_;
	_tmp22_ = value;
	_tmp23_ = number_sqrt (_tmp22_);
	root = _tmp23_;
	while (TRUE) {
		Number* _tmp24_;
		Number* _tmp25_;
		gint _tmp26_ = 0;
		Number* _tmp27_;
		Number* _tmp28_;
		Number* _tmp29_ = NULL;
		Number* tmp;
		Number* _tmp30_;
		gboolean _tmp31_ = FALSE;
		_tmp24_ = divisor;
		_tmp25_ = root;
		_tmp26_ = number_compare (_tmp24_, _tmp25_);
		if (!(_tmp26_ <= 0)) {
			break;
		}
		_tmp27_ = value;
		_tmp28_ = divisor;
		_tmp29_ = number_divide (_tmp27_, _tmp28_);
		tmp = _tmp29_;
		_tmp30_ = tmp;
		_tmp31_ = number_is_integer (_tmp30_);
		if (_tmp31_) {
			Number* _tmp32_;
			Number* _tmp33_;
			Number* _tmp34_;
			Number* _tmp35_ = NULL;
			Number* _tmp36_;
			Number* _tmp37_;
			_tmp32_ = tmp;
			_tmp33_ = _number_ref0 (_tmp32_);
			_number_unref0 (value);
			value = _tmp33_;
			_tmp34_ = value;
			_tmp35_ = number_sqrt (_tmp34_);
			_number_unref0 (root);
			root = _tmp35_;
			_tmp36_ = divisor;
			_tmp37_ = _number_ref0 (_tmp36_);
			factors = g_list_append (factors, _tmp37_);
		} else {
			Number* _tmp38_;
			Number* _tmp39_;
			Number* _tmp40_;
			Number* _tmp41_ = NULL;
			Number* _tmp42_;
			Number* _tmp43_;
			_tmp38_ = divisor;
			_tmp39_ = number_new_integer ((gint64) 2);
			_tmp40_ = _tmp39_;
			_tmp41_ = number_add (_tmp38_, _tmp40_);
			_number_unref0 (tmp);
			tmp = _tmp41_;
			_number_unref0 (_tmp40_);
			_tmp42_ = tmp;
			_tmp43_ = _number_ref0 (_tmp42_);
			_number_unref0 (divisor);
			divisor = _tmp43_;
		}
		_number_unref0 (tmp);
	}
	_tmp44_ = value;
	_tmp45_ = number_new_integer ((gint64) 1);
	_tmp46_ = _tmp45_;
	_tmp47_ = number_compare (_tmp44_, _tmp46_);
	_tmp48_ = _tmp47_ > 0;
	_number_unref0 (_tmp46_);
	if (_tmp48_) {
		Number* _tmp49_;
		Number* _tmp50_;
		_tmp49_ = value;
		_tmp50_ = _number_ref0 (_tmp49_);
		factors = g_list_append (factors, _tmp50_);
	}
	_tmp51_ = number_is_negative (self);
	if (_tmp51_) {
		GList* _tmp52_;
		GList* _tmp53_;
		gconstpointer _tmp54_;
		Number* _tmp55_ = NULL;
		_tmp52_ = factors;
		_tmp53_ = factors;
		_tmp54_ = _tmp53_->data;
		_tmp55_ = number_invert_sign ((Number*) _tmp54_);
		_number_unref0 (_tmp52_->data);
		_tmp52_->data = _tmp55_;
	}
	result = factors;
	_number_unref0 (root);
	_number_unref0 (divisor);
	_number_unref0 (value);
	return result;
}


static Number* number_copy (Number* self) {
	Number* result = NULL;
	Number* _tmp0_;
	Number* z;
	Number* _tmp1_;
	gint _tmp2_;
	Number* _tmp3_;
	gint _tmp4_;
	Number* _tmp5_;
	gint _tmp6_;
	Number* _tmp7_;
	gint _tmp8_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = number_new ();
	z = _tmp0_;
	_tmp1_ = z;
	_tmp2_ = self->re_sign;
	_tmp1_->re_sign = _tmp2_;
	_tmp3_ = z;
	_tmp4_ = self->im_sign;
	_tmp3_->im_sign = _tmp4_;
	_tmp5_ = z;
	_tmp6_ = self->re_exponent;
	_tmp5_->re_exponent = _tmp6_;
	_tmp7_ = z;
	_tmp8_ = self->im_exponent;
	_tmp7_->im_exponent = _tmp8_;
	{
		gint i;
		i = 0;
		{
			gboolean _tmp9_;
			_tmp9_ = TRUE;
			while (TRUE) {
				gboolean _tmp10_;
				gint _tmp12_;
				Number* _tmp13_;
				gint _tmp14_;
				gint _tmp15_;
				gint _tmp16_;
				gint _tmp17_;
				Number* _tmp18_;
				gint _tmp19_;
				gint _tmp20_;
				gint _tmp21_;
				gint _tmp22_;
				_tmp10_ = _tmp9_;
				if (!_tmp10_) {
					gint _tmp11_;
					_tmp11_ = i;
					i = _tmp11_ + 1;
				}
				_tmp9_ = FALSE;
				_tmp12_ = i;
				if (!(_tmp12_ < 1000)) {
					break;
				}
				_tmp13_ = z;
				_tmp14_ = i;
				_tmp15_ = i;
				_tmp16_ = self->re_fraction[_tmp15_];
				_tmp13_->re_fraction[_tmp14_] = _tmp16_;
				_tmp17_ = _tmp13_->re_fraction[_tmp14_];
				_tmp18_ = z;
				_tmp19_ = i;
				_tmp20_ = i;
				_tmp21_ = self->im_fraction[_tmp20_];
				_tmp18_->im_fraction[_tmp19_] = _tmp21_;
				_tmp22_ = _tmp18_->im_fraction[_tmp19_];
			}
		}
	}
	result = z;
	return result;
}


static Number* number_add_with_sign (Number* self, gint y_sign, Number* y) {
	Number* result = NULL;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp4_;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (y != NULL, NULL);
	_tmp1_ = number_is_complex (self);
	if (_tmp1_) {
		_tmp0_ = TRUE;
	} else {
		Number* _tmp2_;
		gboolean _tmp3_ = FALSE;
		_tmp2_ = y;
		_tmp3_ = number_is_complex (_tmp2_);
		_tmp0_ = _tmp3_;
	}
	_tmp4_ = _tmp0_;
	if (_tmp4_) {
		Number* real_z = NULL;
		Number* im_z = NULL;
		Number* _tmp5_ = NULL;
		Number* real_x;
		Number* _tmp6_ = NULL;
		Number* im_x;
		Number* _tmp7_;
		Number* _tmp8_ = NULL;
		Number* real_y;
		Number* _tmp9_;
		Number* _tmp10_ = NULL;
		Number* im_y;
		Number* _tmp11_;
		gint _tmp12_;
		Number* _tmp13_;
		gint _tmp14_;
		Number* _tmp15_;
		Number* _tmp16_ = NULL;
		Number* _tmp17_;
		gint _tmp18_;
		Number* _tmp19_;
		gint _tmp20_;
		Number* _tmp21_;
		Number* _tmp22_ = NULL;
		Number* _tmp23_;
		Number* _tmp24_;
		Number* _tmp25_;
		_tmp5_ = number_real_component (self);
		real_x = _tmp5_;
		_tmp6_ = number_imaginary_component (self);
		im_x = _tmp6_;
		_tmp7_ = y;
		_tmp8_ = number_real_component (_tmp7_);
		real_y = _tmp8_;
		_tmp9_ = y;
		_tmp10_ = number_imaginary_component (_tmp9_);
		im_y = _tmp10_;
		_tmp11_ = real_x;
		_tmp12_ = y_sign;
		_tmp13_ = y;
		_tmp14_ = _tmp13_->re_sign;
		_tmp15_ = real_y;
		_tmp16_ = number_add_real (_tmp11_, _tmp12_ * _tmp14_, _tmp15_);
		_number_unref0 (real_z);
		real_z = _tmp16_;
		_tmp17_ = im_x;
		_tmp18_ = y_sign;
		_tmp19_ = y;
		_tmp20_ = _tmp19_->im_sign;
		_tmp21_ = im_y;
		_tmp22_ = number_add_real (_tmp17_, _tmp18_ * _tmp20_, _tmp21_);
		_number_unref0 (im_z);
		im_z = _tmp22_;
		_tmp23_ = real_z;
		_tmp24_ = im_z;
		_tmp25_ = number_new_complex (_tmp23_, _tmp24_);
		result = _tmp25_;
		_number_unref0 (im_y);
		_number_unref0 (real_y);
		_number_unref0 (im_x);
		_number_unref0 (real_x);
		_number_unref0 (im_z);
		_number_unref0 (real_z);
		return result;
	} else {
		gint _tmp26_;
		Number* _tmp27_;
		gint _tmp28_;
		Number* _tmp29_;
		Number* _tmp30_ = NULL;
		_tmp26_ = y_sign;
		_tmp27_ = y;
		_tmp28_ = _tmp27_->re_sign;
		_tmp29_ = y;
		_tmp30_ = number_add_real (self, _tmp26_ * _tmp28_, _tmp29_);
		result = _tmp30_;
		return result;
	}
}


static Number* number_epowy_real (Number* self) {
	Number* result = NULL;
	gboolean _tmp0_ = FALSE;
	gint _tmp2_;
	gdouble _tmp4_ = 0.0;
	gdouble rx;
	gint _tmp5_;
	gint xs;
	Number* _tmp6_ = NULL;
	Number* t2;
	Number* _tmp7_;
	gint64 _tmp8_ = 0LL;
	gint64 ix;
	Number* _tmp9_;
	Number* _tmp10_ = NULL;
	Number* _tmp11_;
	Number* _tmp12_;
	gint _tmp13_;
	gint _tmp14_;
	Number* _tmp15_;
	Number* _tmp16_ = NULL;
	Number* z;
	gint tss;
	gint _tmp17_;
	Number* _tmp18_;
	Number* t1;
	Number* _tmp19_;
	gint _tmp37_;
	Number* _tmp42_;
	gint64 _tmp43_;
	Number* _tmp44_ = NULL;
	Number* _tmp45_;
	Number* _tmp46_;
	Number* _tmp47_ = NULL;
	gdouble _tmp48_;
	gdouble _tmp49_ = 0.0;
	Number* _tmp50_;
	gdouble _tmp51_ = 0.0;
	gdouble rz;
	gdouble _tmp52_;
	gdouble _tmp53_;
	gdouble _tmp54_ = 0.0;
	gdouble r__1;
	gdouble _tmp55_;
	gdouble _tmp56_ = 0.0;
	gdouble _tmp57_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = number_is_zero (self);
	if (_tmp0_) {
		Number* _tmp1_;
		_tmp1_ = number_new_integer ((gint64) 1);
		result = _tmp1_;
		return result;
	}
	_tmp2_ = self->re_exponent;
	if (_tmp2_ <= 0) {
		Number* _tmp3_ = NULL;
		_tmp3_ = number_exp (self);
		result = _tmp3_;
		return result;
	}
	_tmp4_ = number_to_double (self);
	rx = _tmp4_;
	_tmp5_ = self->re_sign;
	xs = _tmp5_;
	_tmp6_ = number_abs (self);
	t2 = _tmp6_;
	_tmp7_ = t2;
	_tmp8_ = number_to_integer (_tmp7_);
	ix = _tmp8_;
	_tmp9_ = t2;
	_tmp10_ = number_fractional_component (_tmp9_);
	_number_unref0 (t2);
	t2 = _tmp10_;
	_tmp11_ = t2;
	_tmp12_ = t2;
	_tmp13_ = _tmp12_->re_sign;
	_tmp14_ = xs;
	_tmp12_->re_sign = _tmp13_ * _tmp14_;
	_tmp15_ = t2;
	_tmp16_ = number_exp (_tmp15_);
	z = _tmp16_;
	tss = 0;
	if (T < 4) {
		tss = T + 1;
	} else {
		tss = T + 2;
	}
	_tmp17_ = xs;
	_tmp18_ = number_new_integer ((gint64) _tmp17_);
	t1 = _tmp18_;
	_tmp19_ = t2;
	_tmp19_->re_sign = 0;
	{
		gint i;
		i = 2;
		{
			gboolean _tmp20_;
			_tmp20_ = TRUE;
			while (TRUE) {
				gboolean _tmp21_;
				gint _tmp23_;
				gint _tmp24_;
				Number* _tmp25_;
				gint _tmp26_;
				gint _tmp27_ = 0;
				Number* _tmp28_;
				gint _tmp29_;
				gint _tmp30_;
				Number* _tmp31_ = NULL;
				Number* _tmp32_;
				Number* _tmp33_;
				Number* _tmp34_ = NULL;
				Number* _tmp35_;
				gboolean _tmp36_ = FALSE;
				_tmp21_ = _tmp20_;
				if (!_tmp21_) {
					gint _tmp22_;
					_tmp22_ = i;
					i = _tmp22_ + 1;
				}
				_tmp20_ = FALSE;
				_tmp23_ = tss;
				_tmp24_ = tss;
				_tmp25_ = t1;
				_tmp26_ = _tmp25_->re_exponent;
				_tmp27_ = MIN (_tmp23_, (_tmp24_ + 2) + _tmp26_);
				if (_tmp27_ <= 2) {
					break;
				}
				_tmp28_ = t1;
				_tmp29_ = i;
				_tmp30_ = xs;
				_tmp31_ = number_divide_integer (_tmp28_, (gint64) (_tmp29_ * _tmp30_));
				_number_unref0 (t1);
				t1 = _tmp31_;
				_tmp32_ = t2;
				_tmp33_ = t1;
				_tmp34_ = number_add (_tmp32_, _tmp33_);
				_number_unref0 (t2);
				t2 = _tmp34_;
				_tmp35_ = t1;
				_tmp36_ = number_is_zero (_tmp35_);
				if (_tmp36_) {
					break;
				}
			}
		}
	}
	_tmp37_ = xs;
	if (_tmp37_ > 0) {
		Number* _tmp38_;
		Number* _tmp39_;
		Number* _tmp40_;
		Number* _tmp41_ = NULL;
		_tmp38_ = t2;
		_tmp39_ = number_new_integer ((gint64) 2);
		_tmp40_ = _tmp39_;
		_tmp41_ = number_add (_tmp38_, _tmp40_);
		_number_unref0 (t2);
		t2 = _tmp41_;
		_number_unref0 (_tmp40_);
	}
	_tmp42_ = t2;
	_tmp43_ = ix;
	_tmp44_ = number_xpowy_integer (_tmp42_, _tmp43_);
	_number_unref0 (t2);
	t2 = _tmp44_;
	_tmp45_ = z;
	_tmp46_ = t2;
	_tmp47_ = number_multiply (_tmp45_, _tmp46_);
	_number_unref0 (z);
	z = _tmp47_;
	_tmp48_ = rx;
	_tmp49_ = fabs (_tmp48_);
	if (_tmp49_ > ((gdouble) 10.0f)) {
		result = z;
		_number_unref0 (t1);
		_number_unref0 (t2);
		return result;
	}
	_tmp50_ = z;
	_tmp51_ = number_to_double (_tmp50_);
	rz = _tmp51_;
	_tmp52_ = rz;
	_tmp53_ = rx;
	_tmp54_ = exp (_tmp53_);
	r__1 = _tmp52_ - _tmp54_;
	_tmp55_ = r__1;
	_tmp56_ = fabs (_tmp55_);
	_tmp57_ = rz;
	if (_tmp56_ < (_tmp57_ * 0.01f)) {
		result = z;
		_number_unref0 (t1);
		_number_unref0 (t2);
		return result;
	}
	mperr ("*** ERROR OCCURRED IN EPOWY, RESULT INCORRECT ***");
	result = z;
	_number_unref0 (t1);
	_number_unref0 (t2);
	return result;
}


static Number* number_exp (Number* self) {
	Number* result = NULL;
	gboolean _tmp0_ = FALSE;
	gint _tmp2_;
	Number* _tmp4_;
	Number* t1;
	gdouble _tmp5_ = 0.0;
	gdouble rlb;
	gdouble _tmp6_;
	gdouble _tmp7_ = 0.0;
	gint _tmp8_;
	gdouble _tmp9_;
	gint q;
	gint _tmp10_;
	Number* _tmp29_;
	gboolean _tmp30_ = FALSE;
	Number* _tmp32_;
	Number* _tmp33_ = NULL;
	Number* z;
	Number* _tmp34_;
	Number* _tmp35_;
	Number* t2;
	Number* _tmp66_;
	Number* _tmp67_;
	Number* _tmp68_;
	Number* _tmp69_ = NULL;
	Number* _tmp70_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = number_is_zero (self);
	if (_tmp0_) {
		Number* _tmp1_;
		_tmp1_ = number_new_integer ((gint64) 1);
		result = _tmp1_;
		return result;
	}
	_tmp2_ = self->re_exponent;
	if (_tmp2_ > 0) {
		Number* _tmp3_;
		mperr ("*** ABS (X) NOT LESS THAN 1 IN CALL TO MP_EXP ***");
		_tmp3_ = number_new_integer ((gint64) 0);
		result = _tmp3_;
		return result;
	}
	_tmp4_ = _number_ref0 (self);
	t1 = _tmp4_;
	_tmp5_ = log ((gdouble) BASE);
	rlb = _tmp5_;
	_tmp6_ = rlb;
	_tmp7_ = sqrt ((T * 0.48) * _tmp6_);
	_tmp8_ = self->re_exponent;
	_tmp9_ = rlb;
	q = (gint) (_tmp7_ + ((_tmp8_ * 1.44) * _tmp9_));
	_tmp10_ = q;
	if (_tmp10_ > 0) {
		gint ib;
		gint ic;
		ib = BASE << 2;
		ic = 1;
		{
			gint i;
			i = 1;
			{
				gboolean _tmp11_;
				_tmp11_ = TRUE;
				while (TRUE) {
					gboolean _tmp12_;
					gint _tmp14_;
					gint _tmp15_;
					gint _tmp16_;
					gboolean _tmp17_ = FALSE;
					gboolean _tmp18_ = FALSE;
					gint _tmp19_;
					gint _tmp20_;
					gboolean _tmp22_;
					gboolean _tmp25_;
					Number* _tmp26_;
					gint _tmp27_;
					Number* _tmp28_ = NULL;
					_tmp12_ = _tmp11_;
					if (!_tmp12_) {
						gint _tmp13_;
						_tmp13_ = i;
						i = _tmp13_ + 1;
					}
					_tmp11_ = FALSE;
					_tmp14_ = i;
					_tmp15_ = q;
					if (!(_tmp14_ <= _tmp15_)) {
						break;
					}
					_tmp16_ = ic;
					ic = _tmp16_ * 2;
					_tmp19_ = ic;
					_tmp20_ = ib;
					if (_tmp19_ < _tmp20_) {
						gint _tmp21_;
						_tmp21_ = ic;
						_tmp18_ = _tmp21_ != BASE;
					} else {
						_tmp18_ = FALSE;
					}
					_tmp22_ = _tmp18_;
					if (_tmp22_) {
						gint _tmp23_;
						gint _tmp24_;
						_tmp23_ = i;
						_tmp24_ = q;
						_tmp17_ = _tmp23_ < _tmp24_;
					} else {
						_tmp17_ = FALSE;
					}
					_tmp25_ = _tmp17_;
					if (_tmp25_) {
						continue;
					}
					_tmp26_ = t1;
					_tmp27_ = ic;
					_tmp28_ = number_divide_integer (_tmp26_, (gint64) _tmp27_);
					_number_unref0 (t1);
					t1 = _tmp28_;
					ic = 1;
				}
			}
		}
	}
	_tmp29_ = t1;
	_tmp30_ = number_is_zero (_tmp29_);
	if (_tmp30_) {
		Number* _tmp31_;
		_tmp31_ = number_new_integer ((gint64) 0);
		result = _tmp31_;
		_number_unref0 (t1);
		return result;
	}
	_tmp32_ = t1;
	_tmp33_ = number_copy (_tmp32_);
	z = _tmp33_;
	_tmp34_ = t1;
	_tmp35_ = _number_ref0 (_tmp34_);
	t2 = _tmp35_;
	{
		gint i;
		i = 2;
		{
			gboolean _tmp36_;
			_tmp36_ = TRUE;
			while (TRUE) {
				gboolean _tmp37_;
				Number* _tmp39_;
				gint _tmp40_;
				Number* _tmp41_;
				gint _tmp42_;
				Number* _tmp43_;
				Number* _tmp44_;
				Number* _tmp45_ = NULL;
				Number* _tmp46_;
				gint _tmp47_;
				Number* _tmp48_ = NULL;
				Number* _tmp49_;
				Number* _tmp50_;
				Number* _tmp51_ = NULL;
				Number* _tmp52_;
				gboolean _tmp53_ = FALSE;
				_tmp37_ = _tmp36_;
				if (!_tmp37_) {
					gint _tmp38_;
					_tmp38_ = i;
					i = _tmp38_ + 1;
				}
				_tmp36_ = FALSE;
				_tmp39_ = t2;
				_tmp40_ = _tmp39_->re_exponent;
				_tmp41_ = z;
				_tmp42_ = _tmp41_->re_exponent;
				if (!(((T + _tmp40_) - _tmp42_) > 0)) {
					break;
				}
				_tmp43_ = t1;
				_tmp44_ = t2;
				_tmp45_ = number_multiply (_tmp43_, _tmp44_);
				_number_unref0 (t2);
				t2 = _tmp45_;
				_tmp46_ = t2;
				_tmp47_ = i;
				_tmp48_ = number_divide_integer (_tmp46_, (gint64) _tmp47_);
				_number_unref0 (t2);
				t2 = _tmp48_;
				_tmp49_ = t2;
				_tmp50_ = z;
				_tmp51_ = number_add (_tmp49_, _tmp50_);
				_number_unref0 (z);
				z = _tmp51_;
				_tmp52_ = t2;
				_tmp53_ = number_is_zero (_tmp52_);
				if (_tmp53_) {
					break;
				}
			}
		}
	}
	{
		gint i;
		i = 1;
		{
			gboolean _tmp54_;
			_tmp54_ = TRUE;
			while (TRUE) {
				gboolean _tmp55_;
				gint _tmp57_;
				gint _tmp58_;
				Number* _tmp59_;
				Number* _tmp60_;
				Number* _tmp61_;
				Number* _tmp62_ = NULL;
				Number* _tmp63_;
				Number* _tmp64_;
				Number* _tmp65_ = NULL;
				_tmp55_ = _tmp54_;
				if (!_tmp55_) {
					gint _tmp56_;
					_tmp56_ = i;
					i = _tmp56_ + 1;
				}
				_tmp54_ = FALSE;
				_tmp57_ = i;
				_tmp58_ = q;
				if (!(_tmp57_ <= _tmp58_)) {
					break;
				}
				_tmp59_ = z;
				_tmp60_ = number_new_integer ((gint64) 2);
				_tmp61_ = _tmp60_;
				_tmp62_ = number_add (_tmp59_, _tmp61_);
				_number_unref0 (t1);
				t1 = _tmp62_;
				_number_unref0 (_tmp61_);
				_tmp63_ = t1;
				_tmp64_ = z;
				_tmp65_ = number_multiply (_tmp63_, _tmp64_);
				_number_unref0 (z);
				z = _tmp65_;
			}
		}
	}
	_tmp66_ = z;
	_tmp67_ = number_new_integer ((gint64) 1);
	_tmp68_ = _tmp67_;
	_tmp69_ = number_add (_tmp66_, _tmp68_);
	_tmp70_ = _tmp69_;
	_number_unref0 (_tmp68_);
	result = _tmp70_;
	_number_unref0 (t2);
	_number_unref0 (z);
	_number_unref0 (t1);
	return result;
}


static Number* number_pwr (Number* self, Number* y) {
	Number* result = NULL;
	gboolean _tmp0_ = FALSE;
	Number* _tmp5_;
	gboolean _tmp6_ = FALSE;
	Number* _tmp8_;
	Number* _tmp9_ = NULL;
	Number* _tmp10_;
	Number* _tmp11_ = NULL;
	Number* _tmp12_;
	Number* _tmp13_ = NULL;
	Number* _tmp14_;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (y != NULL, NULL);
	_tmp0_ = number_is_zero (self);
	if (_tmp0_) {
		Number* _tmp1_;
		gint _tmp2_;
		Number* _tmp4_;
		_tmp1_ = y;
		_tmp2_ = _tmp1_->re_sign;
		if (_tmp2_ < 0) {
			const gchar* _tmp3_ = NULL;
			_tmp3_ = _ ("The power of zero is undefined for a negative exponent");
			mperr (_tmp3_);
		}
		_tmp4_ = number_new_integer ((gint64) 0);
		result = _tmp4_;
		return result;
	}
	_tmp5_ = y;
	_tmp6_ = number_is_zero (_tmp5_);
	if (_tmp6_) {
		Number* _tmp7_;
		_tmp7_ = number_new_integer ((gint64) 1);
		result = _tmp7_;
		return result;
	}
	_tmp8_ = y;
	_tmp9_ = number_ln (self);
	_tmp10_ = _tmp9_;
	_tmp11_ = number_multiply (_tmp8_, _tmp10_);
	_tmp12_ = _tmp11_;
	_tmp13_ = number_epowy (_tmp12_);
	_tmp14_ = _tmp13_;
	_number_unref0 (_tmp12_);
	_number_unref0 (_tmp10_);
	result = _tmp14_;
	return result;
}


static Number* number_root_real (Number* self, gint64 n) {
	Number* result = NULL;
	gint64 _tmp0_;
	gint64 _tmp2_;
	gint64 _tmp5_;
	gint64 _tmp6_ = 0LL;
	gint64 np;
	gint64 _tmp7_;
	gint _tmp8_ = 0;
	gboolean _tmp10_ = FALSE;
	gboolean _tmp14_ = FALSE;
	gint _tmp15_;
	gboolean _tmp17_;
	gint _tmp20_;
	gint64 _tmp21_;
	gint64 ex;
	Number* _tmp22_ = NULL;
	Number* t1;
	Number* _tmp23_;
	gint64 _tmp24_;
	gint64 _tmp25_;
	gint _tmp26_;
	gdouble _tmp27_ = 0.0;
	Number* _tmp28_;
	gfloat _tmp29_ = 0.0F;
	gdouble _tmp30_ = 0.0;
	gdouble _tmp31_ = 0.0;
	gint64 _tmp32_;
	gdouble _tmp33_ = 0.0;
	gdouble approximation;
	gdouble _tmp34_;
	Number* _tmp35_;
	Number* _tmp36_;
	gint _tmp37_;
	Number* _tmp38_;
	Number* _tmp39_;
	gint _tmp40_;
	gint64 _tmp41_;
	gint it0;
	gint _tmp42_;
	gint t;
	Number* t2 = NULL;
	gboolean _tmp73_ = FALSE;
	Number* _tmp74_;
	gint _tmp75_;
	gboolean _tmp81_;
	gint64 _tmp82_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = n;
	if (_tmp0_ == ((gint64) 1)) {
		Number* _tmp1_;
		_tmp1_ = _number_ref0 (self);
		result = _tmp1_;
		return result;
	}
	_tmp2_ = n;
	if (_tmp2_ == ((gint64) 0)) {
		const gchar* _tmp3_ = NULL;
		Number* _tmp4_;
		_tmp3_ = _ ("Root must be non-zero");
		mperr (_tmp3_);
		_tmp4_ = number_new_integer ((gint64) 0);
		result = _tmp4_;
		return result;
	}
	_tmp5_ = n;
	_tmp6_ = llabs (_tmp5_);
	np = _tmp6_;
	_tmp7_ = np;
	_tmp8_ = MAX (BASE, 64);
	if (_tmp7_ > ((gint64) _tmp8_)) {
		Number* _tmp9_;
		mperr ("*** ABS (N) TOO LARGE IN CALL TO ROOT ***");
		_tmp9_ = number_new_integer ((gint64) 0);
		result = _tmp9_;
		return result;
	}
	_tmp10_ = number_is_zero (self);
	if (_tmp10_) {
		gint64 _tmp11_;
		Number* _tmp13_;
		_tmp11_ = n;
		if (_tmp11_ <= ((gint64) 0)) {
			const gchar* _tmp12_ = NULL;
			_tmp12_ = _ ("Negative root of zero is undefined");
			mperr (_tmp12_);
		}
		_tmp13_ = number_new_integer ((gint64) 0);
		result = _tmp13_;
		return result;
	}
	_tmp15_ = self->re_sign;
	if (_tmp15_ < 0) {
		gint64 _tmp16_;
		_tmp16_ = np;
		_tmp14_ = (_tmp16_ % 2) == ((gint64) 0);
	} else {
		_tmp14_ = FALSE;
	}
	_tmp17_ = _tmp14_;
	if (_tmp17_) {
		const gchar* _tmp18_ = NULL;
		Number* _tmp19_;
		_tmp18_ = _ ("nth root of negative number is undefined for even n");
		mperr (_tmp18_);
		_tmp19_ = number_new_integer ((gint64) 0);
		result = _tmp19_;
		return result;
	}
	_tmp20_ = self->re_exponent;
	_tmp21_ = np;
	ex = _tmp20_ / _tmp21_;
	_tmp22_ = number_copy (self);
	t1 = _tmp22_;
	_tmp23_ = t1;
	_tmp23_->re_exponent = 0;
	_tmp24_ = np;
	_tmp25_ = ex;
	_tmp26_ = self->re_exponent;
	_tmp27_ = log ((gdouble) BASE);
	_tmp28_ = t1;
	_tmp29_ = number_to_float (_tmp28_);
	_tmp30_ = fabs ((gdouble) _tmp29_);
	_tmp31_ = log (_tmp30_);
	_tmp32_ = np;
	_tmp33_ = exp (((((_tmp24_ * _tmp25_) - _tmp26_) * _tmp27_) - _tmp31_) / _tmp32_);
	approximation = _tmp33_;
	_tmp34_ = approximation;
	_tmp35_ = number_new_double (_tmp34_);
	_number_unref0 (t1);
	t1 = _tmp35_;
	_tmp36_ = t1;
	_tmp37_ = self->re_sign;
	_tmp36_->re_sign = _tmp37_;
	_tmp38_ = t1;
	_tmp39_ = t1;
	_tmp40_ = _tmp39_->re_exponent;
	_tmp41_ = ex;
	_tmp39_->re_exponent = _tmp40_ - ((gint) _tmp41_);
	it0 = 3;
	_tmp42_ = it0;
	t = _tmp42_;
	while (TRUE) {
		Number* _tmp43_;
		gint64 _tmp44_;
		Number* _tmp45_ = NULL;
		Number* _tmp46_;
		Number* _tmp47_ = NULL;
		Number* _tmp48_;
		Number* _tmp49_;
		Number* _tmp50_;
		Number* _tmp51_ = NULL;
		Number* _tmp52_;
		Number* _tmp53_;
		Number* _tmp54_ = NULL;
		Number* _tmp55_;
		gint64 _tmp56_;
		Number* _tmp57_ = NULL;
		Number* _tmp58_;
		Number* _tmp59_;
		Number* _tmp60_ = NULL;
		gint _tmp61_;
		gint _tmp62_;
		gint ts3;
		gint _tmp63_;
		gint ts2;
		gint _tmp71_;
		gint _tmp72_ = 0;
		_tmp43_ = t1;
		_tmp44_ = np;
		_tmp45_ = number_xpowy_integer (_tmp43_, _tmp44_);
		_number_unref0 (t2);
		t2 = _tmp45_;
		_tmp46_ = t2;
		_tmp47_ = number_multiply (self, _tmp46_);
		_number_unref0 (t2);
		t2 = _tmp47_;
		_tmp48_ = t2;
		_tmp49_ = number_new_integer ((gint64) (-1));
		_tmp50_ = _tmp49_;
		_tmp51_ = number_add (_tmp48_, _tmp50_);
		_number_unref0 (t2);
		t2 = _tmp51_;
		_number_unref0 (_tmp50_);
		_tmp52_ = t1;
		_tmp53_ = t2;
		_tmp54_ = number_multiply (_tmp52_, _tmp53_);
		_number_unref0 (t2);
		t2 = _tmp54_;
		_tmp55_ = t2;
		_tmp56_ = np;
		_tmp57_ = number_divide_integer (_tmp55_, _tmp56_);
		_number_unref0 (t2);
		t2 = _tmp57_;
		_tmp58_ = t1;
		_tmp59_ = t2;
		_tmp60_ = number_subtract (_tmp58_, _tmp59_);
		_number_unref0 (t1);
		t1 = _tmp60_;
		_tmp61_ = t;
		if (_tmp61_ >= T) {
			break;
		}
		_tmp62_ = t;
		ts3 = _tmp62_;
		_tmp63_ = t;
		ts2 = _tmp63_;
		t = T;
		{
			gboolean _tmp64_;
			_tmp64_ = TRUE;
			while (TRUE) {
				gboolean _tmp65_;
				gint _tmp68_;
				gint _tmp69_;
				gint _tmp70_;
				_tmp65_ = _tmp64_;
				if (!_tmp65_) {
					gint _tmp66_;
					gint _tmp67_;
					_tmp66_ = t;
					_tmp67_ = ts3;
					if (!(_tmp66_ > _tmp67_)) {
						break;
					}
				}
				_tmp64_ = FALSE;
				_tmp68_ = t;
				ts2 = _tmp68_;
				_tmp69_ = t;
				_tmp70_ = it0;
				t = (_tmp69_ + _tmp70_) / 2;
			}
		}
		_tmp71_ = ts2;
		_tmp72_ = MIN (_tmp71_, T);
		t = _tmp72_;
	}
	_tmp74_ = t2;
	_tmp75_ = _tmp74_->re_sign;
	if (_tmp75_ != 0) {
		Number* _tmp76_;
		gint _tmp77_;
		Number* _tmp78_;
		gint _tmp79_;
		gint _tmp80_;
		_tmp76_ = t1;
		_tmp77_ = _tmp76_->re_exponent;
		_tmp78_ = t2;
		_tmp79_ = _tmp78_->re_exponent;
		_tmp80_ = it0;
		_tmp73_ = ((_tmp77_ - _tmp79_) << 1) < (T - _tmp80_);
	} else {
		_tmp73_ = FALSE;
	}
	_tmp81_ = _tmp73_;
	if (_tmp81_) {
		mperr ("*** ERROR OCCURRED IN ROOT, NEWTON ITERATION NOT CONVERGING PROPERLY *" \
"**");
	}
	_tmp82_ = n;
	if (_tmp82_ >= ((gint64) 0)) {
		Number* _tmp83_;
		gint64 _tmp84_;
		Number* _tmp85_ = NULL;
		Number* _tmp86_;
		Number* _tmp87_ = NULL;
		_tmp83_ = t1;
		_tmp84_ = n;
		_tmp85_ = number_xpowy_integer (_tmp83_, _tmp84_ - 1);
		_number_unref0 (t1);
		t1 = _tmp85_;
		_tmp86_ = t1;
		_tmp87_ = number_multiply (self, _tmp86_);
		result = _tmp87_;
		_number_unref0 (t2);
		_number_unref0 (t1);
		return result;
	}
	result = t1;
	_number_unref0 (t2);
	return result;
}


static Number* number_ext (Number* self, gint i, gint j) {
	Number* result = NULL;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp2_ = FALSE;
	gboolean _tmp3_;
	gboolean _tmp5_;
	gint _tmp7_;
	gint _tmp8_;
	gint q;
	gint _tmp9_;
	gint _tmp10_;
	gint s;
	Number* _tmp11_ = NULL;
	Number* z;
	gint _tmp12_;
	gint _tmp13_;
	gint _tmp18_;
	gint _tmp19_;
	Number* _tmp20_;
	gint _tmp21_;
	Number* _tmp22_;
	gint _tmp23_;
	Number* _tmp24_;
	Number* _tmp25_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp2_ = number_is_zero (self);
	if (_tmp2_) {
		_tmp1_ = TRUE;
	} else {
		_tmp1_ = T <= 2;
	}
	_tmp3_ = _tmp1_;
	if (_tmp3_) {
		_tmp0_ = TRUE;
	} else {
		gint _tmp4_;
		_tmp4_ = i;
		_tmp0_ = _tmp4_ == 0;
	}
	_tmp5_ = _tmp0_;
	if (_tmp5_) {
		Number* _tmp6_;
		_tmp6_ = _number_ref0 (self);
		result = _tmp6_;
		return result;
	}
	_tmp7_ = j;
	_tmp8_ = i;
	q = ((_tmp7_ + 1) / _tmp8_) + 1;
	_tmp9_ = self->re_fraction[T - 2];
	_tmp10_ = self->re_fraction[T - 1];
	s = (BASE * _tmp9_) + _tmp10_;
	_tmp11_ = number_copy (self);
	z = _tmp11_;
	_tmp12_ = s;
	_tmp13_ = q;
	if (_tmp12_ <= _tmp13_) {
		Number* _tmp14_;
		gint _tmp15_;
		Number* _tmp16_;
		gint _tmp17_;
		_tmp14_ = z;
		_tmp14_->re_fraction[T - 2] = 0;
		_tmp15_ = _tmp14_->re_fraction[T - 2];
		_tmp16_ = z;
		_tmp16_->re_fraction[T - 1] = 0;
		_tmp17_ = _tmp16_->re_fraction[T - 1];
		result = z;
		return result;
	}
	_tmp18_ = s;
	_tmp19_ = q;
	if ((_tmp18_ + _tmp19_) < (BASE * BASE)) {
		result = z;
		return result;
	}
	_tmp20_ = z;
	_tmp20_->re_fraction[T - 2] = BASE - 1;
	_tmp21_ = _tmp20_->re_fraction[T - 2];
	_tmp22_ = z;
	_tmp22_->re_fraction[T - 1] = BASE;
	_tmp23_ = _tmp22_->re_fraction[T - 1];
	_tmp24_ = z;
	_tmp25_ = number_multiply_integer (_tmp24_, (gint64) 1);
	result = _tmp25_;
	_number_unref0 (z);
	return result;
}


static Number* number_ln_real (Number* self) {
	Number* result = NULL;
	Number* _tmp0_ = NULL;
	Number* t1;
	Number* _tmp1_;
	Number* z;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = number_copy (self);
	t1 = _tmp0_;
	_tmp1_ = number_new_integer ((gint64) 0);
	z = _tmp1_;
	{
		gint k;
		k = 0;
		{
			gboolean _tmp2_;
			_tmp2_ = TRUE;
			while (TRUE) {
				gboolean _tmp3_;
				gint _tmp5_;
				Number* _tmp6_;
				Number* _tmp7_;
				Number* _tmp8_;
				Number* _tmp9_ = NULL;
				Number* _tmp10_;
				Number* t2;
				gboolean _tmp11_ = FALSE;
				Number* _tmp12_;
				gboolean _tmp13_ = FALSE;
				gboolean _tmp16_;
				Number* _tmp23_;
				gint _tmp24_;
				gint e;
				Number* _tmp25_;
				Number* _tmp26_;
				gfloat _tmp27_ = 0.0F;
				gfloat rx;
				Number* _tmp28_;
				gint _tmp29_;
				gfloat _tmp30_;
				gdouble _tmp31_ = 0.0;
				gint _tmp32_;
				gdouble _tmp33_ = 0.0;
				gfloat rlx;
				gfloat _tmp34_;
				Number* _tmp35_;
				Number* _tmp36_;
				Number* _tmp37_;
				Number* _tmp38_ = NULL;
				Number* _tmp39_;
				Number* _tmp40_ = NULL;
				Number* _tmp41_;
				Number* _tmp42_;
				Number* _tmp43_ = NULL;
				_tmp3_ = _tmp2_;
				if (!_tmp3_) {
					gint _tmp4_;
					_tmp4_ = k;
					k = _tmp4_ + 1;
				}
				_tmp2_ = FALSE;
				_tmp5_ = k;
				if (!(_tmp5_ < 10)) {
					break;
				}
				_tmp6_ = t1;
				_tmp7_ = number_new_integer ((gint64) (-1));
				_tmp8_ = _tmp7_;
				_tmp9_ = number_add (_tmp6_, _tmp8_);
				_tmp10_ = _tmp9_;
				_number_unref0 (_tmp8_);
				t2 = _tmp10_;
				_tmp12_ = t2;
				_tmp13_ = number_is_zero (_tmp12_);
				if (_tmp13_) {
					_tmp11_ = TRUE;
				} else {
					Number* _tmp14_;
					gint _tmp15_;
					_tmp14_ = t2;
					_tmp15_ = _tmp14_->re_exponent;
					_tmp11_ = (_tmp15_ + 1) <= 0;
				}
				_tmp16_ = _tmp11_;
				if (_tmp16_) {
					Number* _tmp17_;
					Number* _tmp18_;
					Number* _tmp19_ = NULL;
					Number* _tmp20_;
					Number* _tmp21_ = NULL;
					Number* _tmp22_;
					_tmp17_ = z;
					_tmp18_ = t2;
					_tmp19_ = number_lns (_tmp18_);
					_tmp20_ = _tmp19_;
					_tmp21_ = number_add (_tmp17_, _tmp20_);
					_tmp22_ = _tmp21_;
					_number_unref0 (_tmp20_);
					result = _tmp22_;
					_number_unref0 (t2);
					_number_unref0 (z);
					_number_unref0 (t1);
					return result;
				}
				_tmp23_ = t1;
				_tmp24_ = _tmp23_->re_exponent;
				e = _tmp24_;
				_tmp25_ = t1;
				_tmp25_->re_exponent = 0;
				_tmp26_ = t1;
				_tmp27_ = number_to_float_old (_tmp26_);
				rx = _tmp27_;
				_tmp28_ = t1;
				_tmp29_ = e;
				_tmp28_->re_exponent = _tmp29_;
				_tmp30_ = rx;
				_tmp31_ = log ((gdouble) _tmp30_);
				_tmp32_ = e;
				_tmp33_ = log ((gdouble) BASE);
				rlx = (gfloat) (_tmp31_ + (_tmp32_ * _tmp33_));
				_tmp34_ = rlx;
				_tmp35_ = number_new_float (-((gfloat) _tmp34_));
				_number_unref0 (t2);
				t2 = _tmp35_;
				_tmp36_ = z;
				_tmp37_ = t2;
				_tmp38_ = number_subtract (_tmp36_, _tmp37_);
				_number_unref0 (z);
				z = _tmp38_;
				_tmp39_ = t2;
				_tmp40_ = number_epowy (_tmp39_);
				_number_unref0 (t2);
				t2 = _tmp40_;
				_tmp41_ = t1;
				_tmp42_ = t2;
				_tmp43_ = number_multiply (_tmp41_, _tmp42_);
				_number_unref0 (t1);
				t1 = _tmp43_;
				_number_unref0 (t2);
			}
		}
	}
	mperr ("*** ERROR IN LN, ITERATION NOT CONVERGING ***");
	result = z;
	_number_unref0 (t1);
	return result;
}


static gfloat number_to_float_old (Number* self) {
	gfloat result = 0.0F;
	gboolean _tmp0_ = FALSE;
	gfloat z;
	gint i;
	gfloat _tmp10_;
	gint _tmp11_;
	gint _tmp12_;
	gdouble _tmp13_ = 0.0;
	gint _tmp14_;
	g_return_val_if_fail (self != NULL, 0.0F);
	_tmp0_ = number_is_zero (self);
	if (_tmp0_) {
		result = 0.f;
		return result;
	}
	z = 0.f;
	i = 0;
	{
		gboolean _tmp1_;
		_tmp1_ = TRUE;
		while (TRUE) {
			gboolean _tmp2_;
			gint _tmp4_;
			gfloat _tmp5_;
			gint _tmp6_;
			gint _tmp7_;
			gfloat _tmp8_;
			gfloat _tmp9_;
			_tmp2_ = _tmp1_;
			if (!_tmp2_) {
				gint _tmp3_;
				_tmp3_ = i;
				i = _tmp3_ + 1;
			}
			_tmp1_ = FALSE;
			_tmp4_ = i;
			if (!(_tmp4_ < T)) {
				break;
			}
			_tmp5_ = z;
			_tmp6_ = i;
			_tmp7_ = self->re_fraction[_tmp6_];
			z = (BASE * _tmp5_) + _tmp7_;
			_tmp8_ = z;
			_tmp9_ = z;
			if ((_tmp8_ + 1.0f) <= _tmp9_) {
				break;
			}
		}
	}
	_tmp10_ = z;
	_tmp11_ = self->re_exponent;
	_tmp12_ = i;
	_tmp13_ = number_mppow_ri (self, (gfloat) BASE, (_tmp11_ - _tmp12_) - 1);
	z = (gfloat) (_tmp10_ * _tmp13_);
	_tmp14_ = self->re_sign;
	if (_tmp14_ < 0) {
		gfloat _tmp15_;
		_tmp15_ = z;
		result = -_tmp15_;
		return result;
	} else {
		result = z;
		return result;
	}
}


static gdouble number_mppow_ri (Number* self, gfloat ap, gint bp) {
	gdouble result = 0.0;
	gint _tmp0_;
	gint _tmp1_;
	gdouble pow;
	g_return_val_if_fail (self != NULL, 0.0);
	_tmp0_ = bp;
	if (_tmp0_ == 0) {
		result = (gdouble) 1.0f;
		return result;
	}
	_tmp1_ = bp;
	if (_tmp1_ < 0) {
		gfloat _tmp2_;
		gint _tmp3_;
		gfloat _tmp4_;
		_tmp2_ = ap;
		if (_tmp2_ == ((gfloat) 0)) {
			result = (gdouble) 1.0f;
			return result;
		}
		_tmp3_ = bp;
		bp = -_tmp3_;
		_tmp4_ = ap;
		ap = 1 / _tmp4_;
	}
	pow = 1.0;
	while (TRUE) {
		gint _tmp5_;
		gint _tmp8_;
		gint _tmp9_;
		_tmp5_ = bp;
		if ((_tmp5_ & 01) != 0) {
			gdouble _tmp6_;
			gfloat _tmp7_;
			_tmp6_ = pow;
			_tmp7_ = ap;
			pow = _tmp6_ * _tmp7_;
		}
		_tmp8_ = bp;
		bp = _tmp8_ >> 1;
		_tmp9_ = bp;
		if (_tmp9_ != 0) {
			gfloat _tmp10_;
			gfloat _tmp11_;
			_tmp10_ = ap;
			_tmp11_ = ap;
			ap = _tmp10_ * _tmp11_;
		} else {
			break;
		}
	}
	result = pow;
	return result;
}


static Number* number_lns (Number* self) {
	Number* result = NULL;
	gboolean _tmp0_ = FALSE;
	Number* _tmp2_ = NULL;
	Number* t2;
	Number* _tmp3_ = NULL;
	Number* t1;
	Number* _tmp4_;
	Number* _tmp5_;
	Number* _tmp6_;
	Number* _tmp7_ = NULL;
	Number* _tmp8_;
	Number* _tmp9_ = NULL;
	Number* _tmp10_;
	Number* _tmp11_;
	Number* _tmp12_;
	Number* _tmp13_ = NULL;
	Number* _tmp14_;
	Number* _tmp15_ = NULL;
	Number* _tmp16_;
	Number* _tmp17_;
	Number* _tmp18_;
	Number* _tmp19_ = NULL;
	Number* _tmp20_;
	Number* _tmp21_ = NULL;
	Number* z;
	gint it0;
	gint _tmp22_;
	gint t;
	Number* t3 = NULL;
	gboolean _tmp52_ = FALSE;
	Number* _tmp53_;
	gint _tmp54_;
	gboolean _tmp58_;
	Number* _tmp59_;
	Number* _tmp60_;
	gint _tmp61_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = number_is_zero (self);
	if (_tmp0_) {
		Number* _tmp1_;
		_tmp1_ = _number_ref0 (self);
		result = _tmp1_;
		return result;
	}
	_tmp2_ = number_copy (self);
	t2 = _tmp2_;
	_tmp3_ = number_divide_integer (self, (gint64) 4);
	t1 = _tmp3_;
	_tmp4_ = t1;
	_tmp5_ = number_new_fraction ((gint64) (-1), (gint64) 3);
	_tmp6_ = _tmp5_;
	_tmp7_ = number_add (_tmp4_, _tmp6_);
	_number_unref0 (t1);
	t1 = _tmp7_;
	_number_unref0 (_tmp6_);
	_tmp8_ = t1;
	_tmp9_ = number_multiply (self, _tmp8_);
	_number_unref0 (t1);
	t1 = _tmp9_;
	_tmp10_ = t1;
	_tmp11_ = number_new_fraction ((gint64) 1, (gint64) 2);
	_tmp12_ = _tmp11_;
	_tmp13_ = number_add (_tmp10_, _tmp12_);
	_number_unref0 (t1);
	t1 = _tmp13_;
	_number_unref0 (_tmp12_);
	_tmp14_ = t1;
	_tmp15_ = number_multiply (self, _tmp14_);
	_number_unref0 (t1);
	t1 = _tmp15_;
	_tmp16_ = t1;
	_tmp17_ = number_new_integer ((gint64) (-1));
	_tmp18_ = _tmp17_;
	_tmp19_ = number_add (_tmp16_, _tmp18_);
	_number_unref0 (t1);
	t1 = _tmp19_;
	_number_unref0 (_tmp18_);
	_tmp20_ = t1;
	_tmp21_ = number_multiply (self, _tmp20_);
	z = _tmp21_;
	it0 = 5;
	_tmp22_ = it0;
	t = _tmp22_;
	while (TRUE) {
		Number* _tmp23_;
		Number* _tmp24_ = NULL;
		Number* _tmp25_;
		Number* _tmp26_;
		Number* _tmp27_;
		Number* _tmp28_ = NULL;
		Number* _tmp29_;
		Number* _tmp30_;
		Number* _tmp31_ = NULL;
		Number* _tmp32_;
		Number* _tmp33_;
		Number* _tmp34_ = NULL;
		Number* _tmp35_;
		Number* _tmp36_;
		Number* _tmp37_ = NULL;
		Number* _tmp38_;
		Number* _tmp39_;
		Number* _tmp40_ = NULL;
		gint _tmp41_;
		gint _tmp42_;
		gint ts3;
		gint _tmp43_;
		gint ts2;
		gint _tmp51_;
		_tmp23_ = z;
		_tmp24_ = number_epowy (_tmp23_);
		_number_unref0 (t3);
		t3 = _tmp24_;
		_tmp25_ = t3;
		_tmp26_ = number_new_integer ((gint64) (-1));
		_tmp27_ = _tmp26_;
		_tmp28_ = number_add (_tmp25_, _tmp27_);
		_number_unref0 (t3);
		t3 = _tmp28_;
		_number_unref0 (_tmp27_);
		_tmp29_ = t2;
		_tmp30_ = t3;
		_tmp31_ = number_multiply (_tmp29_, _tmp30_);
		_number_unref0 (t1);
		t1 = _tmp31_;
		_tmp32_ = t3;
		_tmp33_ = t1;
		_tmp34_ = number_add (_tmp32_, _tmp33_);
		_number_unref0 (t3);
		t3 = _tmp34_;
		_tmp35_ = t2;
		_tmp36_ = t3;
		_tmp37_ = number_add (_tmp35_, _tmp36_);
		_number_unref0 (t3);
		t3 = _tmp37_;
		_tmp38_ = z;
		_tmp39_ = t3;
		_tmp40_ = number_subtract (_tmp38_, _tmp39_);
		_number_unref0 (z);
		z = _tmp40_;
		_tmp41_ = t;
		if (_tmp41_ >= T) {
			break;
		}
		_tmp42_ = t;
		ts3 = _tmp42_;
		_tmp43_ = t;
		ts2 = _tmp43_;
		t = T;
		{
			gboolean _tmp44_;
			_tmp44_ = TRUE;
			while (TRUE) {
				gboolean _tmp45_;
				gint _tmp48_;
				gint _tmp49_;
				gint _tmp50_;
				_tmp45_ = _tmp44_;
				if (!_tmp45_) {
					gint _tmp46_;
					gint _tmp47_;
					_tmp46_ = t;
					_tmp47_ = ts3;
					if (!(_tmp46_ > _tmp47_)) {
						break;
					}
				}
				_tmp44_ = FALSE;
				_tmp48_ = t;
				ts2 = _tmp48_;
				_tmp49_ = t;
				_tmp50_ = it0;
				t = (_tmp49_ + _tmp50_) / 2;
			}
		}
		_tmp51_ = ts2;
		t = _tmp51_;
	}
	_tmp53_ = t3;
	_tmp54_ = _tmp53_->re_sign;
	if (_tmp54_ != 0) {
		Number* _tmp55_;
		gint _tmp56_;
		gint _tmp57_;
		_tmp55_ = t3;
		_tmp56_ = _tmp55_->re_exponent;
		_tmp57_ = it0;
		_tmp52_ = (_tmp56_ << 1) > (_tmp57_ - T);
	} else {
		_tmp52_ = FALSE;
	}
	_tmp58_ = _tmp52_;
	if (_tmp58_) {
		mperr ("*** ERROR OCCURRED IN LNS, NEWTON ITERATION NOT CONVERGING PROPERLY **" \
"*");
	}
	_tmp59_ = z;
	_tmp60_ = z;
	_tmp61_ = _tmp60_->re_sign;
	_tmp59_->re_sign = -_tmp61_;
	result = z;
	_number_unref0 (t3);
	_number_unref0 (t1);
	_number_unref0 (t2);
	return result;
}


static gint* _vala_array_dup1 (gint* self, int length) {
	return g_memdup (self, length * sizeof (gint));
}


static gint* _vala_array_dup2 (gint* self, int length) {
	return g_memdup (self, length * sizeof (gint));
}


static gint* _vala_array_dup3 (gint* self, int length) {
	return g_memdup (self, length * sizeof (gint));
}


static gint* _vala_array_dup4 (gint* self, int length) {
	return g_memdup (self, length * sizeof (gint));
}


static Number* number_add_real (Number* self, gint y_sign, Number* y) {
	Number* result = NULL;
	gint _tmp0_;
	gint _tmp1_;
	gint re_sign_prod;
	gboolean _tmp2_ = FALSE;
	gint _tmp13_;
	Number* _tmp14_;
	gint _tmp15_;
	gint exp_diff;
	gint _tmp16_;
	gint _tmp17_ = 0;
	gint med;
	gboolean x_largest;
	gint _tmp18_;
	Number* _tmp35_;
	Number* z;
	gint* big_fraction = NULL;
	gint big_fraction_length1 = 0;
	gint _big_fraction_size_ = 0;
	gint* small_fraction = NULL;
	gint small_fraction_length1 = 0;
	gint _small_fraction_size_ = 0;
	gboolean _tmp36_;
	gint _tmp60_;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (y != NULL, NULL);
	_tmp0_ = y_sign;
	_tmp1_ = self->re_sign;
	re_sign_prod = _tmp0_ * _tmp1_;
	_tmp2_ = number_is_zero (self);
	if (_tmp2_) {
		gint _tmp3_;
		Number* _tmp4_;
		gint _tmp5_;
		_tmp3_ = y_sign;
		_tmp4_ = y;
		_tmp5_ = _tmp4_->re_sign;
		if (_tmp3_ != _tmp5_) {
			Number* _tmp6_;
			Number* _tmp7_ = NULL;
			_tmp6_ = y;
			_tmp7_ = number_invert_sign (_tmp6_);
			result = _tmp7_;
			return result;
		} else {
			Number* _tmp8_;
			Number* _tmp9_;
			_tmp8_ = y;
			_tmp9_ = _number_ref0 (_tmp8_);
			result = _tmp9_;
			return result;
		}
	} else {
		Number* _tmp10_;
		gboolean _tmp11_ = FALSE;
		_tmp10_ = y;
		_tmp11_ = number_is_zero (_tmp10_);
		if (_tmp11_) {
			Number* _tmp12_;
			_tmp12_ = _number_ref0 (self);
			result = _tmp12_;
			return result;
		}
	}
	_tmp13_ = self->re_exponent;
	_tmp14_ = y;
	_tmp15_ = _tmp14_->re_exponent;
	exp_diff = _tmp13_ - _tmp15_;
	_tmp16_ = exp_diff;
	_tmp17_ = abs (_tmp16_);
	med = _tmp17_;
	x_largest = FALSE;
	_tmp18_ = exp_diff;
	if (_tmp18_ < 0) {
		x_largest = FALSE;
	} else {
		gint _tmp19_;
		_tmp19_ = exp_diff;
		if (_tmp19_ > 0) {
			x_largest = TRUE;
		} else {
			gint _tmp20_;
			_tmp20_ = re_sign_prod;
			if (_tmp20_ < 0) {
				gint j = 0;
				gint _tmp33_;
				{
					gboolean _tmp21_;
					j = 0;
					_tmp21_ = TRUE;
					while (TRUE) {
						gboolean _tmp22_;
						gint _tmp24_;
						gint _tmp25_;
						gint _tmp26_;
						Number* _tmp27_;
						gint _tmp28_;
						gint _tmp29_;
						gint i;
						gint _tmp30_;
						_tmp22_ = _tmp21_;
						if (!_tmp22_) {
							gint _tmp23_;
							_tmp23_ = j;
							j = _tmp23_ + 1;
						}
						_tmp21_ = FALSE;
						_tmp24_ = j;
						if (!(_tmp24_ < T)) {
							break;
						}
						_tmp25_ = j;
						_tmp26_ = self->re_fraction[_tmp25_];
						_tmp27_ = y;
						_tmp28_ = j;
						_tmp29_ = _tmp27_->re_fraction[_tmp28_];
						i = _tmp26_ - _tmp29_;
						_tmp30_ = i;
						if (_tmp30_ != 0) {
							gint _tmp31_;
							_tmp31_ = i;
							if (_tmp31_ < 0) {
								x_largest = FALSE;
							} else {
								gint _tmp32_;
								_tmp32_ = i;
								if (_tmp32_ > 0) {
									x_largest = TRUE;
								}
							}
							break;
						}
					}
				}
				_tmp33_ = j;
				if (_tmp33_ >= T) {
					Number* _tmp34_;
					_tmp34_ = number_new_integer ((gint64) 0);
					result = _tmp34_;
					return result;
				}
			}
		}
	}
	_tmp35_ = number_new_integer ((gint64) 0);
	z = _tmp35_;
	_tmp36_ = x_largest;
	if (_tmp36_) {
		Number* _tmp37_;
		gint _tmp38_;
		Number* _tmp39_;
		gint _tmp40_;
		gint* _tmp41_;
		gint _tmp41__length1;
		Number* _tmp42_;
		gint* _tmp43_;
		gint _tmp43__length1;
		_tmp37_ = z;
		_tmp38_ = self->re_sign;
		_tmp37_->re_sign = _tmp38_;
		_tmp39_ = z;
		_tmp40_ = self->re_exponent;
		_tmp39_->re_exponent = _tmp40_;
		_tmp41_ = (self->re_fraction != NULL) ? _vala_array_dup1 (self->re_fraction, 1000) : ((gpointer) self->re_fraction);
		_tmp41__length1 = 1000;
		big_fraction = (g_free (big_fraction), NULL);
		big_fraction = _tmp41_;
		big_fraction_length1 = _tmp41__length1;
		_big_fraction_size_ = big_fraction_length1;
		_tmp42_ = y;
		_tmp43_ = (_tmp42_->re_fraction != NULL) ? _vala_array_dup2 (_tmp42_->re_fraction, 1000) : ((gpointer) _tmp42_->re_fraction);
		_tmp43__length1 = 1000;
		small_fraction = (g_free (small_fraction), NULL);
		small_fraction = _tmp43_;
		small_fraction_length1 = _tmp43__length1;
		_small_fraction_size_ = small_fraction_length1;
	} else {
		Number* _tmp44_;
		gint _tmp45_;
		Number* _tmp46_;
		Number* _tmp47_;
		gint _tmp48_;
		Number* _tmp49_;
		gint* _tmp50_;
		gint _tmp50__length1;
		gint* _tmp51_;
		gint _tmp51__length1;
		_tmp44_ = z;
		_tmp45_ = y_sign;
		_tmp44_->re_sign = _tmp45_;
		_tmp46_ = z;
		_tmp47_ = y;
		_tmp48_ = _tmp47_->re_exponent;
		_tmp46_->re_exponent = _tmp48_;
		_tmp49_ = y;
		_tmp50_ = (_tmp49_->re_fraction != NULL) ? _vala_array_dup3 (_tmp49_->re_fraction, 1000) : ((gpointer) _tmp49_->re_fraction);
		_tmp50__length1 = 1000;
		big_fraction = (g_free (big_fraction), NULL);
		big_fraction = _tmp50_;
		big_fraction_length1 = _tmp50__length1;
		_big_fraction_size_ = big_fraction_length1;
		_tmp51_ = (self->re_fraction != NULL) ? _vala_array_dup4 (self->re_fraction, 1000) : ((gpointer) self->re_fraction);
		_tmp51__length1 = 1000;
		small_fraction = (g_free (small_fraction), NULL);
		small_fraction = _tmp51_;
		small_fraction_length1 = _tmp51__length1;
		_small_fraction_size_ = small_fraction_length1;
	}
	{
		gint i;
		i = 3;
		{
			gboolean _tmp52_;
			_tmp52_ = TRUE;
			while (TRUE) {
				gboolean _tmp53_;
				gint _tmp55_;
				gint _tmp56_;
				Number* _tmp57_;
				gint _tmp58_;
				gint _tmp59_;
				_tmp53_ = _tmp52_;
				if (!_tmp53_) {
					gint _tmp54_;
					_tmp54_ = i;
					i = _tmp54_ - 1;
				}
				_tmp52_ = FALSE;
				_tmp55_ = i;
				_tmp56_ = med;
				if (!(_tmp55_ >= _tmp56_)) {
					break;
				}
				_tmp57_ = z;
				_tmp58_ = i;
				_tmp57_->re_fraction[T + _tmp58_] = 0;
				_tmp59_ = _tmp57_->re_fraction[T + _tmp58_];
			}
		}
	}
	_tmp60_ = re_sign_prod;
	if (_tmp60_ >= 0) {
		gint _tmp61_;
		gint i;
		gint c;
		gint _tmp124_;
		_tmp61_ = med;
		if ((T + 3) < _tmp61_) {
			const gchar* _tmp62_ = NULL;
			Number* _tmp63_;
			_tmp62_ = _ ("Overflow: the result couldn't be calculated");
			mperr (_tmp62_);
			_tmp63_ = number_new_integer ((gint64) 0);
			result = _tmp63_;
			small_fraction = (g_free (small_fraction), NULL);
			big_fraction = (g_free (big_fraction), NULL);
			_number_unref0 (z);
			return result;
		}
		i = 0;
		{
			gboolean _tmp64_;
			i = T + 3;
			_tmp64_ = TRUE;
			while (TRUE) {
				gboolean _tmp65_;
				gint _tmp67_;
				Number* _tmp68_;
				gint _tmp69_;
				gint* _tmp70_;
				gint _tmp70__length1;
				gint _tmp71_;
				gint _tmp72_;
				gint _tmp73_;
				gint _tmp74_;
				_tmp65_ = _tmp64_;
				if (!_tmp65_) {
					gint _tmp66_;
					_tmp66_ = i;
					i = _tmp66_ - 1;
				}
				_tmp64_ = FALSE;
				_tmp67_ = i;
				if (!(_tmp67_ >= T)) {
					break;
				}
				_tmp68_ = z;
				_tmp69_ = i;
				_tmp70_ = small_fraction;
				_tmp70__length1 = small_fraction_length1;
				_tmp71_ = i;
				_tmp72_ = med;
				_tmp73_ = _tmp70_[_tmp71_ - _tmp72_];
				_tmp68_->re_fraction[_tmp69_] = _tmp73_;
				_tmp74_ = _tmp68_->re_fraction[_tmp69_];
			}
		}
		c = 0;
		{
			gboolean _tmp75_;
			_tmp75_ = TRUE;
			while (TRUE) {
				gboolean _tmp76_;
				gint _tmp78_;
				gint _tmp79_;
				gint* _tmp80_;
				gint _tmp80__length1;
				gint _tmp81_;
				gint _tmp82_;
				gint* _tmp83_;
				gint _tmp83__length1;
				gint _tmp84_;
				gint _tmp85_;
				gint _tmp86_;
				gint _tmp87_;
				gint _tmp88_;
				_tmp76_ = _tmp75_;
				if (!_tmp76_) {
					gint _tmp77_;
					_tmp77_ = i;
					i = _tmp77_ - 1;
				}
				_tmp75_ = FALSE;
				_tmp78_ = i;
				_tmp79_ = med;
				if (!(_tmp78_ >= _tmp79_)) {
					break;
				}
				_tmp80_ = big_fraction;
				_tmp80__length1 = big_fraction_length1;
				_tmp81_ = i;
				_tmp82_ = _tmp80_[_tmp81_];
				_tmp83_ = small_fraction;
				_tmp83__length1 = small_fraction_length1;
				_tmp84_ = i;
				_tmp85_ = med;
				_tmp86_ = _tmp83_[_tmp84_ - _tmp85_];
				_tmp87_ = c;
				c = (_tmp82_ + _tmp86_) + _tmp87_;
				_tmp88_ = c;
				if (_tmp88_ < BASE) {
					Number* _tmp89_;
					gint _tmp90_;
					gint _tmp91_;
					gint _tmp92_;
					_tmp89_ = z;
					_tmp90_ = i;
					_tmp91_ = c;
					_tmp89_->re_fraction[_tmp90_] = _tmp91_;
					_tmp92_ = _tmp89_->re_fraction[_tmp90_];
					c = 0;
				} else {
					Number* _tmp93_;
					gint _tmp94_;
					gint _tmp95_;
					gint _tmp96_;
					_tmp93_ = z;
					_tmp94_ = i;
					_tmp95_ = c;
					_tmp93_->re_fraction[_tmp94_] = _tmp95_ - BASE;
					_tmp96_ = _tmp93_->re_fraction[_tmp94_];
					c = 1;
				}
			}
		}
		{
			gboolean _tmp97_;
			_tmp97_ = TRUE;
			while (TRUE) {
				gboolean _tmp98_;
				gint _tmp100_;
				gint* _tmp101_;
				gint _tmp101__length1;
				gint _tmp102_;
				gint _tmp103_;
				gint _tmp104_;
				gint _tmp105_;
				Number* _tmp121_;
				gint _tmp122_;
				gint _tmp123_;
				_tmp98_ = _tmp97_;
				if (!_tmp98_) {
					gint _tmp99_;
					_tmp99_ = i;
					i = _tmp99_ - 1;
				}
				_tmp97_ = FALSE;
				_tmp100_ = i;
				if (!(_tmp100_ >= 0)) {
					break;
				}
				_tmp101_ = big_fraction;
				_tmp101__length1 = big_fraction_length1;
				_tmp102_ = i;
				_tmp103_ = _tmp101_[_tmp102_];
				_tmp104_ = c;
				c = _tmp103_ + _tmp104_;
				_tmp105_ = c;
				if (_tmp105_ < BASE) {
					Number* _tmp106_;
					gint _tmp107_;
					gint _tmp108_;
					gint _tmp109_;
					gint _tmp110_;
					_tmp106_ = z;
					_tmp107_ = i;
					_tmp108_ = c;
					_tmp106_->re_fraction[_tmp107_] = _tmp108_;
					_tmp109_ = _tmp106_->re_fraction[_tmp107_];
					_tmp110_ = i;
					i = _tmp110_ - 1;
					{
						gboolean _tmp111_;
						_tmp111_ = TRUE;
						while (TRUE) {
							gboolean _tmp112_;
							gint _tmp114_;
							Number* _tmp115_;
							gint _tmp116_;
							gint* _tmp117_;
							gint _tmp117__length1;
							gint _tmp118_;
							gint _tmp119_;
							gint _tmp120_;
							_tmp112_ = _tmp111_;
							if (!_tmp112_) {
								gint _tmp113_;
								_tmp113_ = i;
								i = _tmp113_ - 1;
							}
							_tmp111_ = FALSE;
							_tmp114_ = i;
							if (!(_tmp114_ >= 0)) {
								break;
							}
							_tmp115_ = z;
							_tmp116_ = i;
							_tmp117_ = big_fraction;
							_tmp117__length1 = big_fraction_length1;
							_tmp118_ = i;
							_tmp119_ = _tmp117_[_tmp118_];
							_tmp115_->re_fraction[_tmp116_] = _tmp119_;
							_tmp120_ = _tmp115_->re_fraction[_tmp116_];
						}
					}
					c = 0;
					break;
				}
				_tmp121_ = z;
				_tmp122_ = i;
				_tmp121_->re_fraction[_tmp122_] = 0;
				_tmp123_ = _tmp121_->re_fraction[_tmp122_];
				c = 1;
			}
		}
		_tmp124_ = c;
		if (_tmp124_ != 0) {
			Number* _tmp135_;
			gint _tmp136_;
			Number* _tmp137_;
			gint _tmp138_;
			{
				gint j;
				j = T + 3;
				{
					gboolean _tmp125_;
					_tmp125_ = TRUE;
					while (TRUE) {
						gboolean _tmp126_;
						gint _tmp128_;
						Number* _tmp129_;
						gint _tmp130_;
						Number* _tmp131_;
						gint _tmp132_;
						gint _tmp133_;
						gint _tmp134_;
						_tmp126_ = _tmp125_;
						if (!_tmp126_) {
							gint _tmp127_;
							_tmp127_ = j;
							j = _tmp127_ - 1;
						}
						_tmp125_ = FALSE;
						_tmp128_ = j;
						if (!(_tmp128_ > 0)) {
							break;
						}
						_tmp129_ = z;
						_tmp130_ = j;
						_tmp131_ = z;
						_tmp132_ = j;
						_tmp133_ = _tmp131_->re_fraction[_tmp132_ - 1];
						_tmp129_->re_fraction[_tmp130_] = _tmp133_;
						_tmp134_ = _tmp129_->re_fraction[_tmp130_];
					}
				}
			}
			_tmp135_ = z;
			_tmp135_->re_fraction[0] = 1;
			_tmp136_ = _tmp135_->re_fraction[0];
			_tmp137_ = z;
			_tmp138_ = _tmp137_->re_exponent;
			_tmp137_->re_exponent = _tmp138_ + 1;
		}
	} else {
		gint c;
		gint i;
		c = 0;
		i = 0;
		{
			gint _tmp139_;
			gboolean _tmp140_;
			_tmp139_ = med;
			i = (T + _tmp139_) - 1;
			_tmp140_ = TRUE;
			while (TRUE) {
				gboolean _tmp141_;
				gint _tmp143_;
				Number* _tmp144_;
				gint _tmp145_;
				gint _tmp146_;
				gint* _tmp147_;
				gint _tmp147__length1;
				gint _tmp148_;
				gint _tmp149_;
				gint _tmp150_;
				gint _tmp151_;
				Number* _tmp152_;
				gint _tmp153_;
				gint _tmp154_;
				_tmp141_ = _tmp140_;
				if (!_tmp141_) {
					gint _tmp142_;
					_tmp142_ = i;
					i = _tmp142_ - 1;
				}
				_tmp140_ = FALSE;
				_tmp143_ = i;
				if (!(_tmp143_ >= T)) {
					break;
				}
				_tmp144_ = z;
				_tmp145_ = i;
				_tmp146_ = c;
				_tmp147_ = small_fraction;
				_tmp147__length1 = small_fraction_length1;
				_tmp148_ = i;
				_tmp149_ = med;
				_tmp150_ = _tmp147_[_tmp148_ - _tmp149_];
				_tmp144_->re_fraction[_tmp145_] = _tmp146_ - _tmp150_;
				_tmp151_ = _tmp144_->re_fraction[_tmp145_];
				c = 0;
				_tmp152_ = z;
				_tmp153_ = i;
				_tmp154_ = _tmp152_->re_fraction[_tmp153_];
				if (_tmp154_ < 0) {
					Number* _tmp155_;
					gint _tmp156_;
					gint _tmp157_;
					c = -1;
					_tmp155_ = z;
					_tmp156_ = i;
					_tmp155_->re_fraction[_tmp156_] += BASE;
					_tmp157_ = _tmp155_->re_fraction[_tmp156_];
				}
			}
		}
		{
			gboolean _tmp158_;
			_tmp158_ = TRUE;
			while (TRUE) {
				gboolean _tmp159_;
				gint _tmp161_;
				gint _tmp162_;
				gint* _tmp163_;
				gint _tmp163__length1;
				gint _tmp164_;
				gint _tmp165_;
				gint _tmp166_;
				gint* _tmp167_;
				gint _tmp167__length1;
				gint _tmp168_;
				gint _tmp169_;
				gint _tmp170_;
				gint _tmp171_;
				_tmp159_ = _tmp158_;
				if (!_tmp159_) {
					gint _tmp160_;
					_tmp160_ = i;
					i = _tmp160_ - 1;
				}
				_tmp158_ = FALSE;
				_tmp161_ = i;
				_tmp162_ = med;
				if (!(_tmp161_ >= _tmp162_)) {
					break;
				}
				_tmp163_ = big_fraction;
				_tmp163__length1 = big_fraction_length1;
				_tmp164_ = i;
				_tmp165_ = _tmp163_[_tmp164_];
				_tmp166_ = c;
				_tmp167_ = small_fraction;
				_tmp167__length1 = small_fraction_length1;
				_tmp168_ = i;
				_tmp169_ = med;
				_tmp170_ = _tmp167_[_tmp168_ - _tmp169_];
				c = (_tmp165_ + _tmp166_) - _tmp170_;
				_tmp171_ = c;
				if (_tmp171_ >= 0) {
					Number* _tmp172_;
					gint _tmp173_;
					gint _tmp174_;
					gint _tmp175_;
					_tmp172_ = z;
					_tmp173_ = i;
					_tmp174_ = c;
					_tmp172_->re_fraction[_tmp173_] = _tmp174_;
					_tmp175_ = _tmp172_->re_fraction[_tmp173_];
					c = 0;
				} else {
					Number* _tmp176_;
					gint _tmp177_;
					gint _tmp178_;
					gint _tmp179_;
					_tmp176_ = z;
					_tmp177_ = i;
					_tmp178_ = c;
					_tmp176_->re_fraction[_tmp177_] = _tmp178_ + BASE;
					_tmp179_ = _tmp176_->re_fraction[_tmp177_];
					c = -1;
				}
			}
		}
		{
			gboolean _tmp180_;
			_tmp180_ = TRUE;
			while (TRUE) {
				gboolean _tmp181_;
				gint _tmp183_;
				gint* _tmp184_;
				gint _tmp184__length1;
				gint _tmp185_;
				gint _tmp186_;
				gint _tmp187_;
				gint _tmp188_;
				Number* _tmp204_;
				gint _tmp205_;
				gint _tmp206_;
				gint _tmp207_;
				_tmp181_ = _tmp180_;
				if (!_tmp181_) {
					gint _tmp182_;
					_tmp182_ = i;
					i = _tmp182_ - 1;
				}
				_tmp180_ = FALSE;
				_tmp183_ = i;
				if (!(_tmp183_ >= 0)) {
					break;
				}
				_tmp184_ = big_fraction;
				_tmp184__length1 = big_fraction_length1;
				_tmp185_ = i;
				_tmp186_ = _tmp184_[_tmp185_];
				_tmp187_ = c;
				c = _tmp186_ + _tmp187_;
				_tmp188_ = c;
				if (_tmp188_ >= 0) {
					Number* _tmp189_;
					gint _tmp190_;
					gint _tmp191_;
					gint _tmp192_;
					gint _tmp193_;
					_tmp189_ = z;
					_tmp190_ = i;
					_tmp191_ = c;
					_tmp189_->re_fraction[_tmp190_] = _tmp191_;
					_tmp192_ = _tmp189_->re_fraction[_tmp190_];
					_tmp193_ = i;
					i = _tmp193_ - 1;
					{
						gboolean _tmp194_;
						_tmp194_ = TRUE;
						while (TRUE) {
							gboolean _tmp195_;
							gint _tmp197_;
							Number* _tmp198_;
							gint _tmp199_;
							gint* _tmp200_;
							gint _tmp200__length1;
							gint _tmp201_;
							gint _tmp202_;
							gint _tmp203_;
							_tmp195_ = _tmp194_;
							if (!_tmp195_) {
								gint _tmp196_;
								_tmp196_ = i;
								i = _tmp196_ - 1;
							}
							_tmp194_ = FALSE;
							_tmp197_ = i;
							if (!(_tmp197_ >= 0)) {
								break;
							}
							_tmp198_ = z;
							_tmp199_ = i;
							_tmp200_ = big_fraction;
							_tmp200__length1 = big_fraction_length1;
							_tmp201_ = i;
							_tmp202_ = _tmp200_[_tmp201_];
							_tmp198_->re_fraction[_tmp199_] = _tmp202_;
							_tmp203_ = _tmp198_->re_fraction[_tmp199_];
						}
					}
					break;
				}
				_tmp204_ = z;
				_tmp205_ = i;
				_tmp206_ = c;
				_tmp204_->re_fraction[_tmp205_] = _tmp206_ + BASE;
				_tmp207_ = _tmp204_->re_fraction[_tmp205_];
				c = -1;
			}
		}
	}
	mp_normalize (&z);
	result = z;
	small_fraction = (g_free (small_fraction), NULL);
	big_fraction = (g_free (big_fraction), NULL);
	return result;
}


static Number* number_multiply_real (Number* self, Number* y) {
	Number* result = NULL;
	gboolean _tmp0_ = FALSE;
	gint _tmp1_;
	gboolean _tmp4_;
	Number* _tmp6_;
	Number* z;
	Number* _tmp7_;
	gint _tmp8_;
	Number* _tmp9_;
	gint _tmp10_;
	Number* _tmp11_;
	gint _tmp12_;
	Number* _tmp13_;
	gint _tmp14_;
	Number* _tmp15_;
	Number* r;
	gint c;
	gint _tmp62_;
	Number* _tmp81_;
	Number* _tmp82_;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (y != NULL, NULL);
	_tmp1_ = self->re_sign;
	if (_tmp1_ == 0) {
		_tmp0_ = TRUE;
	} else {
		Number* _tmp2_;
		gint _tmp3_;
		_tmp2_ = y;
		_tmp3_ = _tmp2_->re_sign;
		_tmp0_ = _tmp3_ == 0;
	}
	_tmp4_ = _tmp0_;
	if (_tmp4_) {
		Number* _tmp5_;
		_tmp5_ = number_new_integer ((gint64) 0);
		result = _tmp5_;
		return result;
	}
	_tmp6_ = number_new_integer ((gint64) 0);
	z = _tmp6_;
	_tmp7_ = z;
	_tmp8_ = self->re_sign;
	_tmp9_ = y;
	_tmp10_ = _tmp9_->re_sign;
	_tmp7_->re_sign = _tmp8_ * _tmp10_;
	_tmp11_ = z;
	_tmp12_ = self->re_exponent;
	_tmp13_ = y;
	_tmp14_ = _tmp13_->re_exponent;
	_tmp11_->re_exponent = _tmp12_ + _tmp14_;
	_tmp15_ = number_new_integer ((gint64) 0);
	r = _tmp15_;
	c = 8;
	{
		gint i;
		i = 0;
		{
			gboolean _tmp16_;
			_tmp16_ = TRUE;
			while (TRUE) {
				gboolean _tmp17_;
				gint _tmp19_;
				gint _tmp20_;
				gint _tmp21_;
				gint xi;
				gint _tmp22_;
				gint _tmp37_;
				gint _tmp38_;
				gboolean _tmp39_ = FALSE;
				gint _tmp40_;
				gboolean _tmp42_;
				gint _tmp60_;
				_tmp17_ = _tmp16_;
				if (!_tmp17_) {
					gint _tmp18_;
					_tmp18_ = i;
					i = _tmp18_ + 1;
				}
				_tmp16_ = FALSE;
				_tmp19_ = i;
				if (!(_tmp19_ < T)) {
					break;
				}
				_tmp20_ = i;
				_tmp21_ = self->re_fraction[_tmp20_];
				xi = _tmp21_;
				_tmp22_ = xi;
				if (_tmp22_ == 0) {
					continue;
				}
				{
					gint j;
					j = 0;
					{
						gboolean _tmp23_;
						_tmp23_ = TRUE;
						while (TRUE) {
							gboolean _tmp24_;
							gint _tmp26_;
							gint _tmp27_;
							gint _tmp28_ = 0;
							Number* _tmp29_;
							gint _tmp30_;
							gint _tmp31_;
							gint _tmp32_;
							Number* _tmp33_;
							gint _tmp34_;
							gint _tmp35_;
							gint _tmp36_;
							_tmp24_ = _tmp23_;
							if (!_tmp24_) {
								gint _tmp25_;
								_tmp25_ = j;
								j = _tmp25_ + 1;
							}
							_tmp23_ = FALSE;
							_tmp26_ = j;
							_tmp27_ = i;
							_tmp28_ = MIN (T, (T + 3) - _tmp27_);
							if (!(_tmp26_ < _tmp28_)) {
								break;
							}
							_tmp29_ = r;
							_tmp30_ = i;
							_tmp31_ = j;
							_tmp32_ = xi;
							_tmp33_ = y;
							_tmp34_ = j;
							_tmp35_ = _tmp33_->re_fraction[_tmp34_];
							_tmp29_->re_fraction[(_tmp30_ + _tmp31_) + 1] += _tmp32_ * _tmp35_;
							_tmp36_ = _tmp29_->re_fraction[(_tmp30_ + _tmp31_) + 1];
						}
					}
				}
				_tmp37_ = c;
				c = _tmp37_ - 1;
				_tmp38_ = c;
				if (_tmp38_ > 0) {
					continue;
				}
				_tmp40_ = xi;
				if (_tmp40_ < 0) {
					_tmp39_ = TRUE;
				} else {
					gint _tmp41_;
					_tmp41_ = xi;
					_tmp39_ = _tmp41_ >= BASE;
				}
				_tmp42_ = _tmp39_;
				if (_tmp42_) {
					Number* _tmp43_;
					mperr ("*** ILLEGAL BASE B DIGIT IN CALL TO MULTIPLY, POSSIBLE OVERWRITING PRO" \
"BLEM ***");
					_tmp43_ = number_new_integer ((gint64) 0);
					result = _tmp43_;
					_number_unref0 (r);
					_number_unref0 (z);
					return result;
				}
				{
					gint j;
					j = T + 3;
					{
						gboolean _tmp44_;
						_tmp44_ = TRUE;
						while (TRUE) {
							gboolean _tmp45_;
							gint _tmp47_;
							Number* _tmp48_;
							gint _tmp49_;
							gint _tmp50_;
							gint _tmp51_;
							gint ri;
							gint _tmp52_;
							gint _tmp54_;
							Number* _tmp55_;
							gint _tmp56_;
							gint _tmp57_;
							gint _tmp58_;
							gint _tmp59_;
							_tmp45_ = _tmp44_;
							if (!_tmp45_) {
								gint _tmp46_;
								_tmp46_ = j;
								j = _tmp46_ - 1;
							}
							_tmp44_ = FALSE;
							_tmp47_ = j;
							if (!(_tmp47_ >= 0)) {
								break;
							}
							_tmp48_ = r;
							_tmp49_ = j;
							_tmp50_ = _tmp48_->re_fraction[_tmp49_];
							_tmp51_ = c;
							ri = _tmp50_ + _tmp51_;
							_tmp52_ = ri;
							if (_tmp52_ < 0) {
								Number* _tmp53_;
								mperr ("*** INTEGER OVERFLOW IN MULTIPLY, B TOO LARGE ***");
								_tmp53_ = number_new_integer ((gint64) 0);
								result = _tmp53_;
								_number_unref0 (r);
								_number_unref0 (z);
								return result;
							}
							_tmp54_ = ri;
							c = _tmp54_ / BASE;
							_tmp55_ = r;
							_tmp56_ = j;
							_tmp57_ = ri;
							_tmp58_ = c;
							_tmp55_->re_fraction[_tmp56_] = _tmp57_ - (BASE * _tmp58_);
							_tmp59_ = _tmp55_->re_fraction[_tmp56_];
						}
					}
				}
				_tmp60_ = c;
				if (_tmp60_ != 0) {
					Number* _tmp61_;
					mperr ("*** ILLEGAL BASE B DIGIT IN CALL TO MULTIPLY, POSSIBLE OVERWRITING PRO" \
"BLEM ***");
					_tmp61_ = number_new_integer ((gint64) 0);
					result = _tmp61_;
					_number_unref0 (r);
					_number_unref0 (z);
					return result;
				}
				c = 8;
			}
		}
	}
	_tmp62_ = c;
	if (_tmp62_ != 8) {
		gint _tmp79_;
		c = 0;
		{
			gint i;
			i = T + 3;
			{
				gboolean _tmp63_;
				_tmp63_ = TRUE;
				while (TRUE) {
					gboolean _tmp64_;
					gint _tmp66_;
					Number* _tmp67_;
					gint _tmp68_;
					gint _tmp69_;
					gint _tmp70_;
					gint ri;
					gint _tmp71_;
					gint _tmp73_;
					Number* _tmp74_;
					gint _tmp75_;
					gint _tmp76_;
					gint _tmp77_;
					gint _tmp78_;
					_tmp64_ = _tmp63_;
					if (!_tmp64_) {
						gint _tmp65_;
						_tmp65_ = i;
						i = _tmp65_ - 1;
					}
					_tmp63_ = FALSE;
					_tmp66_ = i;
					if (!(_tmp66_ >= 0)) {
						break;
					}
					_tmp67_ = r;
					_tmp68_ = i;
					_tmp69_ = _tmp67_->re_fraction[_tmp68_];
					_tmp70_ = c;
					ri = _tmp69_ + _tmp70_;
					_tmp71_ = ri;
					if (_tmp71_ < 0) {
						Number* _tmp72_;
						mperr ("*** INTEGER OVERFLOW IN MULTIPLY, B TOO LARGE ***");
						_tmp72_ = number_new_integer ((gint64) 0);
						result = _tmp72_;
						_number_unref0 (r);
						_number_unref0 (z);
						return result;
					}
					_tmp73_ = ri;
					c = _tmp73_ / BASE;
					_tmp74_ = r;
					_tmp75_ = i;
					_tmp76_ = ri;
					_tmp77_ = c;
					_tmp74_->re_fraction[_tmp75_] = _tmp76_ - (BASE * _tmp77_);
					_tmp78_ = _tmp74_->re_fraction[_tmp75_];
				}
			}
		}
		_tmp79_ = c;
		if (_tmp79_ != 0) {
			Number* _tmp80_;
			mperr ("*** ILLEGAL BASE B DIGIT IN CALL TO MULTIPLY, POSSIBLE OVERWRITING PRO" \
"BLEM ***");
			_tmp80_ = number_new_integer ((gint64) 0);
			result = _tmp80_;
			_number_unref0 (r);
			_number_unref0 (z);
			return result;
		}
	}
	_tmp81_ = z;
	_tmp81_->im_sign = 0;
	_tmp82_ = z;
	_tmp82_->im_exponent = 0;
	{
		gint i;
		i = 0;
		{
			gboolean _tmp83_;
			_tmp83_ = TRUE;
			while (TRUE) {
				gboolean _tmp84_;
				gint _tmp86_;
				Number* _tmp87_;
				Number* _tmp88_;
				gint _tmp89_;
				gint _tmp90_;
				_tmp84_ = _tmp83_;
				if (!_tmp84_) {
					gint _tmp85_;
					_tmp85_ = i;
					i = _tmp85_ + 1;
				}
				_tmp83_ = FALSE;
				_tmp86_ = i;
				_tmp87_ = z;
				if (!(_tmp86_ < 1000)) {
					break;
				}
				_tmp88_ = z;
				_tmp89_ = i;
				_tmp88_->im_fraction[_tmp89_] = 0;
				_tmp90_ = _tmp88_->im_fraction[_tmp89_];
			}
		}
	}
	{
		gint i;
		i = 0;
		{
			gboolean _tmp91_;
			_tmp91_ = TRUE;
			while (TRUE) {
				gboolean _tmp92_;
				gint _tmp94_;
				Number* _tmp95_;
				gint _tmp96_;
				Number* _tmp97_;
				gint _tmp98_;
				gint _tmp99_;
				gint _tmp100_;
				_tmp92_ = _tmp91_;
				if (!_tmp92_) {
					gint _tmp93_;
					_tmp93_ = i;
					i = _tmp93_ + 1;
				}
				_tmp91_ = FALSE;
				_tmp94_ = i;
				if (!(_tmp94_ < SIZE)) {
					break;
				}
				_tmp95_ = z;
				_tmp96_ = i;
				_tmp97_ = r;
				_tmp98_ = i;
				_tmp99_ = _tmp97_->re_fraction[_tmp98_];
				_tmp95_->re_fraction[_tmp96_] = _tmp99_;
				_tmp100_ = _tmp95_->re_fraction[_tmp96_];
			}
		}
	}
	mp_normalize (&z);
	result = z;
	_number_unref0 (r);
	return result;
}


static Number* number_multiply_integer_real (Number* self, gint64 y) {
	Number* result = NULL;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp3_;
	Number* _tmp5_;
	Number* z;
	gint64 _tmp6_;
	Number* _tmp12_;
	gint _tmp13_;
	gint64 c;
	gint64 _tmp14_;
	gint _tmp15_ = 0;
	gint64 _tmp88_;
	Number* _tmp90_;
	Number* _tmp91_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp1_ = number_is_zero (self);
	if (_tmp1_) {
		_tmp0_ = TRUE;
	} else {
		gint64 _tmp2_;
		_tmp2_ = y;
		_tmp0_ = _tmp2_ == ((gint64) 0);
	}
	_tmp3_ = _tmp0_;
	if (_tmp3_) {
		Number* _tmp4_;
		_tmp4_ = number_new_integer ((gint64) 0);
		result = _tmp4_;
		return result;
	}
	_tmp5_ = number_new_integer ((gint64) 0);
	z = _tmp5_;
	_tmp6_ = y;
	if (_tmp6_ < ((gint64) 0)) {
		gint64 _tmp7_;
		Number* _tmp8_;
		gint _tmp9_;
		_tmp7_ = y;
		y = -_tmp7_;
		_tmp8_ = z;
		_tmp9_ = self->re_sign;
		_tmp8_->re_sign = -_tmp9_;
	} else {
		Number* _tmp10_;
		gint _tmp11_;
		_tmp10_ = z;
		_tmp11_ = self->re_sign;
		_tmp10_->re_sign = _tmp11_;
	}
	_tmp12_ = z;
	_tmp13_ = self->re_exponent;
	_tmp12_->re_exponent = _tmp13_ + 4;
	c = (gint64) 0;
	_tmp14_ = y;
	_tmp15_ = MAX (BASE << 3, 32767 / BASE);
	if (_tmp14_ >= ((gint64) _tmp15_)) {
		gint64 _tmp16_;
		gint64 j1;
		gint64 _tmp17_;
		gint64 _tmp18_;
		gint64 j2;
		_tmp16_ = y;
		j1 = _tmp16_ / BASE;
		_tmp17_ = y;
		_tmp18_ = j1;
		j2 = _tmp17_ - (_tmp18_ * BASE);
		{
			gint i;
			i = T + 3;
			{
				gboolean _tmp19_;
				_tmp19_ = TRUE;
				while (TRUE) {
					gboolean _tmp20_;
					gint _tmp22_;
					gint64 _tmp23_;
					gint64 c1;
					gint64 _tmp24_;
					gint64 _tmp25_;
					gint64 c2;
					gint ix;
					gint _tmp26_;
					gint64 _tmp29_;
					gint _tmp30_;
					gint64 _tmp31_;
					gint64 t;
					gint64 _tmp32_;
					gint64 is;
					gint64 _tmp33_;
					gint _tmp34_;
					gint64 _tmp35_;
					gint64 _tmp36_;
					Number* _tmp37_;
					gint _tmp38_;
					gint64 _tmp39_;
					gint64 _tmp40_;
					gint _tmp41_;
					_tmp20_ = _tmp19_;
					if (!_tmp20_) {
						gint _tmp21_;
						_tmp21_ = i;
						i = _tmp21_ - 1;
					}
					_tmp19_ = FALSE;
					_tmp22_ = i;
					if (!(_tmp22_ >= 0)) {
						break;
					}
					_tmp23_ = c;
					c1 = _tmp23_ / BASE;
					_tmp24_ = c;
					_tmp25_ = c1;
					c2 = _tmp24_ - (BASE * _tmp25_);
					ix = 0;
					_tmp26_ = i;
					if (_tmp26_ > 3) {
						gint _tmp27_;
						gint _tmp28_;
						_tmp27_ = i;
						_tmp28_ = self->re_fraction[_tmp27_ - 4];
						ix = _tmp28_;
					}
					_tmp29_ = j2;
					_tmp30_ = ix;
					_tmp31_ = c2;
					t = (_tmp29_ * _tmp30_) + _tmp31_;
					_tmp32_ = t;
					is = _tmp32_ / BASE;
					_tmp33_ = j1;
					_tmp34_ = ix;
					_tmp35_ = c1;
					_tmp36_ = is;
					c = ((_tmp33_ * _tmp34_) + _tmp35_) + _tmp36_;
					_tmp37_ = z;
					_tmp38_ = i;
					_tmp39_ = t;
					_tmp40_ = is;
					_tmp37_->re_fraction[_tmp38_] = (gint) (_tmp39_ - (BASE * _tmp40_));
					_tmp41_ = _tmp37_->re_fraction[_tmp38_];
				}
			}
		}
	} else {
		gint64 ri;
		gint64 _tmp56_;
		ri = (gint64) 0;
		{
			gint i;
			i = T + 3;
			{
				gboolean _tmp42_;
				_tmp42_ = TRUE;
				while (TRUE) {
					gboolean _tmp43_;
					gint _tmp45_;
					gint64 _tmp46_;
					gint _tmp47_;
					gint _tmp48_;
					gint64 _tmp49_;
					gint64 _tmp50_;
					Number* _tmp51_;
					gint _tmp52_;
					gint64 _tmp53_;
					gint64 _tmp54_;
					gint _tmp55_;
					_tmp43_ = _tmp42_;
					if (!_tmp43_) {
						gint _tmp44_;
						_tmp44_ = i;
						i = _tmp44_ - 1;
					}
					_tmp42_ = FALSE;
					_tmp45_ = i;
					if (!(_tmp45_ >= 4)) {
						break;
					}
					_tmp46_ = y;
					_tmp47_ = i;
					_tmp48_ = self->re_fraction[_tmp47_ - 4];
					_tmp49_ = c;
					ri = (_tmp46_ * _tmp48_) + _tmp49_;
					_tmp50_ = ri;
					c = _tmp50_ / BASE;
					_tmp51_ = z;
					_tmp52_ = i;
					_tmp53_ = ri;
					_tmp54_ = c;
					_tmp51_->re_fraction[_tmp52_] = (gint) (_tmp53_ - (BASE * _tmp54_));
					_tmp55_ = _tmp51_->re_fraction[_tmp52_];
				}
			}
		}
		_tmp56_ = ri;
		if (_tmp56_ < ((gint64) 0)) {
			Number* _tmp57_;
			mperr ("*** INTEGER OVERFLOW IN multiply_integer, B TOO LARGE ***");
			_tmp57_ = number_new_integer ((gint64) 0);
			result = _tmp57_;
			_number_unref0 (z);
			return result;
		}
		{
			gint i;
			i = 3;
			{
				gboolean _tmp58_;
				_tmp58_ = TRUE;
				while (TRUE) {
					gboolean _tmp59_;
					gint _tmp61_;
					gint64 _tmp62_;
					gint64 t;
					gint64 _tmp63_;
					Number* _tmp64_;
					gint _tmp65_;
					gint64 _tmp66_;
					gint64 _tmp67_;
					gint _tmp68_;
					_tmp59_ = _tmp58_;
					if (!_tmp59_) {
						gint _tmp60_;
						_tmp60_ = i;
						i = _tmp60_ - 1;
					}
					_tmp58_ = FALSE;
					_tmp61_ = i;
					if (!(_tmp61_ >= 0)) {
						break;
					}
					_tmp62_ = c;
					t = _tmp62_;
					_tmp63_ = t;
					c = _tmp63_ / BASE;
					_tmp64_ = z;
					_tmp65_ = i;
					_tmp66_ = t;
					_tmp67_ = c;
					_tmp64_->re_fraction[_tmp65_] = (gint) (_tmp66_ - (BASE * _tmp67_));
					_tmp68_ = _tmp64_->re_fraction[_tmp65_];
				}
			}
		}
	}
	while (TRUE) {
		gint64 _tmp69_;
		gint64 _tmp80_;
		gint64 t;
		gint64 _tmp81_;
		Number* _tmp82_;
		gint64 _tmp83_;
		gint64 _tmp84_;
		gint _tmp85_;
		Number* _tmp86_;
		gint _tmp87_;
		_tmp69_ = c;
		if (!(_tmp69_ != ((gint64) 0))) {
			break;
		}
		{
			gint i;
			i = T + 3;
			{
				gboolean _tmp70_;
				_tmp70_ = TRUE;
				while (TRUE) {
					gboolean _tmp71_;
					gint _tmp73_;
					Number* _tmp74_;
					gint _tmp75_;
					Number* _tmp76_;
					gint _tmp77_;
					gint _tmp78_;
					gint _tmp79_;
					_tmp71_ = _tmp70_;
					if (!_tmp71_) {
						gint _tmp72_;
						_tmp72_ = i;
						i = _tmp72_ - 1;
					}
					_tmp70_ = FALSE;
					_tmp73_ = i;
					if (!(_tmp73_ >= 1)) {
						break;
					}
					_tmp74_ = z;
					_tmp75_ = i;
					_tmp76_ = z;
					_tmp77_ = i;
					_tmp78_ = _tmp76_->re_fraction[_tmp77_ - 1];
					_tmp74_->re_fraction[_tmp75_] = _tmp78_;
					_tmp79_ = _tmp74_->re_fraction[_tmp75_];
				}
			}
		}
		_tmp80_ = c;
		t = _tmp80_;
		_tmp81_ = t;
		c = _tmp81_ / BASE;
		_tmp82_ = z;
		_tmp83_ = t;
		_tmp84_ = c;
		_tmp82_->re_fraction[0] = (gint) (_tmp83_ - (BASE * _tmp84_));
		_tmp85_ = _tmp82_->re_fraction[0];
		_tmp86_ = z;
		_tmp87_ = _tmp86_->re_exponent;
		_tmp86_->re_exponent = _tmp87_ + 1;
	}
	_tmp88_ = c;
	if (_tmp88_ < ((gint64) 0)) {
		Number* _tmp89_;
		mperr ("*** INTEGER OVERFLOW IN multiply_integer, B TOO LARGE ***");
		_tmp89_ = number_new_integer ((gint64) 0);
		result = _tmp89_;
		_number_unref0 (z);
		return result;
	}
	_tmp90_ = z;
	_tmp90_->im_sign = 0;
	_tmp91_ = z;
	_tmp91_->im_exponent = 0;
	{
		gint i;
		i = 0;
		{
			gboolean _tmp92_;
			_tmp92_ = TRUE;
			while (TRUE) {
				gboolean _tmp93_;
				gint _tmp95_;
				Number* _tmp96_;
				Number* _tmp97_;
				gint _tmp98_;
				gint _tmp99_;
				_tmp93_ = _tmp92_;
				if (!_tmp93_) {
					gint _tmp94_;
					_tmp94_ = i;
					i = _tmp94_ + 1;
				}
				_tmp92_ = FALSE;
				_tmp95_ = i;
				_tmp96_ = z;
				if (!(_tmp95_ < 1000)) {
					break;
				}
				_tmp97_ = z;
				_tmp98_ = i;
				_tmp97_->im_fraction[_tmp98_] = 0;
				_tmp99_ = _tmp97_->im_fraction[_tmp98_];
			}
		}
	}
	mp_normalize (&z);
	result = z;
	return result;
}


static Number* number_reciprocal_real (Number* self) {
	Number* result = NULL;
	gboolean _tmp0_ = FALSE;
	Number* _tmp3_ = NULL;
	Number* t1;
	Number* _tmp4_;
	Number* _tmp5_;
	gdouble _tmp6_ = 0.0;
	Number* _tmp7_;
	Number* _tmp8_;
	Number* _tmp9_;
	gint _tmp10_;
	gint _tmp11_;
	gint t;
	gint _tmp12_;
	gint it0;
	Number* t2 = NULL;
	gboolean _tmp36_ = FALSE;
	Number* _tmp37_;
	gint _tmp38_;
	gboolean _tmp44_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = number_is_zero (self);
	if (_tmp0_) {
		const gchar* _tmp1_ = NULL;
		Number* _tmp2_;
		_tmp1_ = _ ("Reciprocal of zero is undefined");
		mperr (_tmp1_);
		_tmp2_ = number_new_integer ((gint64) 0);
		result = _tmp2_;
		return result;
	}
	_tmp3_ = number_copy (self);
	t1 = _tmp3_;
	_tmp4_ = t1;
	_tmp4_->re_exponent = 0;
	_tmp5_ = t1;
	_tmp6_ = number_to_double (_tmp5_);
	_tmp7_ = number_new_double (1.0 / _tmp6_);
	_number_unref0 (t1);
	t1 = _tmp7_;
	_tmp8_ = t1;
	_tmp9_ = t1;
	_tmp10_ = _tmp9_->re_exponent;
	_tmp11_ = self->re_exponent;
	_tmp9_->re_exponent = _tmp10_ - _tmp11_;
	t = 3;
	_tmp12_ = t;
	it0 = _tmp12_;
	while (TRUE) {
		Number* _tmp13_;
		Number* _tmp14_ = NULL;
		Number* _tmp15_;
		Number* _tmp16_;
		Number* _tmp17_;
		Number* _tmp18_ = NULL;
		Number* _tmp19_;
		Number* _tmp20_;
		Number* _tmp21_ = NULL;
		Number* _tmp22_;
		Number* _tmp23_;
		Number* _tmp24_ = NULL;
		gint _tmp25_;
		gint _tmp26_;
		gint ts3;
		gint ts2;
		gint _tmp34_;
		gint _tmp35_ = 0;
		_tmp13_ = t1;
		_tmp14_ = number_multiply (self, _tmp13_);
		_number_unref0 (t2);
		t2 = _tmp14_;
		_tmp15_ = t2;
		_tmp16_ = number_new_integer ((gint64) (-1));
		_tmp17_ = _tmp16_;
		_tmp18_ = number_add (_tmp15_, _tmp17_);
		_number_unref0 (t2);
		t2 = _tmp18_;
		_number_unref0 (_tmp17_);
		_tmp19_ = t1;
		_tmp20_ = t2;
		_tmp21_ = number_multiply (_tmp19_, _tmp20_);
		_number_unref0 (t2);
		t2 = _tmp21_;
		_tmp22_ = t1;
		_tmp23_ = t2;
		_tmp24_ = number_subtract (_tmp22_, _tmp23_);
		_number_unref0 (t1);
		t1 = _tmp24_;
		_tmp25_ = t;
		if (_tmp25_ >= T) {
			break;
		}
		_tmp26_ = t;
		ts3 = _tmp26_;
		ts2 = 0;
		t = T;
		{
			gboolean _tmp27_;
			_tmp27_ = TRUE;
			while (TRUE) {
				gboolean _tmp28_;
				gint _tmp31_;
				gint _tmp32_;
				gint _tmp33_;
				_tmp28_ = _tmp27_;
				if (!_tmp28_) {
					gint _tmp29_;
					gint _tmp30_;
					_tmp29_ = t;
					_tmp30_ = ts3;
					if (!(_tmp29_ > _tmp30_)) {
						break;
					}
				}
				_tmp27_ = FALSE;
				_tmp31_ = t;
				ts2 = _tmp31_;
				_tmp32_ = t;
				_tmp33_ = it0;
				t = (_tmp32_ + _tmp33_) / 2;
			}
		}
		_tmp34_ = ts2;
		_tmp35_ = MIN (_tmp34_, T);
		t = _tmp35_;
	}
	_tmp37_ = t2;
	_tmp38_ = _tmp37_->re_sign;
	if (_tmp38_ != 0) {
		Number* _tmp39_;
		gint _tmp40_;
		Number* _tmp41_;
		gint _tmp42_;
		gint _tmp43_;
		_tmp39_ = t1;
		_tmp40_ = _tmp39_->re_exponent;
		_tmp41_ = t2;
		_tmp42_ = _tmp41_->re_exponent;
		_tmp43_ = it0;
		_tmp36_ = ((_tmp40_ - _tmp42_) << 1) < (T - _tmp43_);
	} else {
		_tmp36_ = FALSE;
	}
	_tmp44_ = _tmp36_;
	if (_tmp44_) {
		mperr ("*** ERROR OCCURRED IN RECIPROCAL, NEWTON ITERATION NOT CONVERGING PROP" \
"ERLY ***");
	}
	result = t1;
	_number_unref0 (t2);
	return result;
}


static Number* number_divide_integer_real (Number* self, gint64 y) {
	Number* result = NULL;
	gint64 _tmp0_;
	gboolean _tmp3_ = FALSE;
	gboolean _tmp5_ = FALSE;
	gint64 _tmp6_;
	gboolean _tmp8_;
	Number* _tmp12_;
	Number* z;
	gint64 _tmp13_;
	Number* _tmp19_;
	gint _tmp20_;
	gint64 c;
	gint64 i;
	gint _tmp21_ = 0;
	gint b2;
	gint64 _tmp22_;
	gint _tmp23_;
	gint64 _tmp87_;
	gint64 j1;
	gint64 _tmp88_;
	gint64 _tmp89_;
	gint64 j2;
	gint c2;
	Number* _tmp110_;
	Number* _tmp111_;
	gint _tmp112_;
	gint64 _tmp113_;
	gint64 _tmp114_;
	Number* _tmp153_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = y;
	if (_tmp0_ == ((gint64) 0)) {
		const gchar* _tmp1_ = NULL;
		Number* _tmp2_;
		_tmp1_ = _ ("Division by zero is undefined");
		mperr (_tmp1_);
		_tmp2_ = number_new_integer ((gint64) 0);
		result = _tmp2_;
		return result;
	}
	_tmp3_ = number_is_zero (self);
	if (_tmp3_) {
		Number* _tmp4_;
		_tmp4_ = number_new_integer ((gint64) 0);
		result = _tmp4_;
		return result;
	}
	_tmp6_ = y;
	if (_tmp6_ == ((gint64) 1)) {
		_tmp5_ = TRUE;
	} else {
		gint64 _tmp7_;
		_tmp7_ = y;
		_tmp5_ = _tmp7_ == ((gint64) (-1));
	}
	_tmp8_ = _tmp5_;
	if (_tmp8_) {
		gint64 _tmp9_;
		_tmp9_ = y;
		if (_tmp9_ < ((gint64) 0)) {
			Number* _tmp10_ = NULL;
			_tmp10_ = number_invert_sign (self);
			result = _tmp10_;
			return result;
		} else {
			Number* _tmp11_;
			_tmp11_ = _number_ref0 (self);
			result = _tmp11_;
			return result;
		}
	}
	_tmp12_ = number_new_integer ((gint64) 0);
	z = _tmp12_;
	_tmp13_ = y;
	if (_tmp13_ < ((gint64) 0)) {
		gint64 _tmp14_;
		Number* _tmp15_;
		gint _tmp16_;
		_tmp14_ = y;
		y = -_tmp14_;
		_tmp15_ = z;
		_tmp16_ = self->re_sign;
		_tmp15_->re_sign = -_tmp16_;
	} else {
		Number* _tmp17_;
		gint _tmp18_;
		_tmp17_ = z;
		_tmp18_ = self->re_sign;
		_tmp17_->re_sign = _tmp18_;
	}
	_tmp19_ = z;
	_tmp20_ = self->re_exponent;
	_tmp19_->re_exponent = _tmp20_;
	c = (gint64) 0;
	i = (gint64) 0;
	_tmp21_ = MAX (BASE << 3, 32767 / BASE);
	b2 = _tmp21_;
	_tmp22_ = y;
	_tmp23_ = b2;
	if (_tmp22_ < ((gint64) _tmp23_)) {
		gint64 r1;
		Number* _tmp37_;
		Number* _tmp38_;
		gint _tmp39_;
		gint64 _tmp40_;
		Number* _tmp41_;
		gint64 _tmp42_;
		gint _tmp43_;
		gint64 _tmp44_;
		gint64 _tmp45_;
		gint64 _tmp46_;
		gint64 kh;
		gint64 _tmp47_;
		gint64 _tmp85_;
		r1 = (gint64) 0;
		{
			gboolean _tmp24_;
			_tmp24_ = TRUE;
			while (TRUE) {
				gboolean _tmp25_;
				gint64 _tmp27_;
				gint64 _tmp28_;
				gint64 _tmp32_;
				gint64 _tmp33_;
				gint64 _tmp34_;
				gint64 _tmp35_;
				_tmp25_ = _tmp24_;
				if (!_tmp25_) {
					gint64 _tmp26_;
					_tmp26_ = r1;
					if (!(_tmp26_ == ((gint64) 0))) {
						break;
					}
				}
				_tmp24_ = FALSE;
				_tmp27_ = c;
				c = BASE * _tmp27_;
				_tmp28_ = i;
				if (_tmp28_ < ((gint64) T)) {
					gint64 _tmp29_;
					gint64 _tmp30_;
					gint _tmp31_;
					_tmp29_ = c;
					_tmp30_ = i;
					_tmp31_ = self->re_fraction[_tmp30_];
					c = _tmp29_ + _tmp31_;
				}
				_tmp32_ = i;
				i = _tmp32_ + 1;
				_tmp33_ = c;
				_tmp34_ = y;
				r1 = _tmp33_ / _tmp34_;
				_tmp35_ = r1;
				if (_tmp35_ < ((gint64) 0)) {
					Number* _tmp36_;
					mperr ("*** INTEGER OVERFLOW IN DIVIDE_INTEGER, B TOO LARGE ***");
					_tmp36_ = number_new_integer ((gint64) 0);
					result = _tmp36_;
					_number_unref0 (z);
					return result;
				}
			}
		}
		_tmp37_ = z;
		_tmp38_ = z;
		_tmp39_ = _tmp38_->re_exponent;
		_tmp40_ = i;
		_tmp38_->re_exponent = _tmp39_ + ((gint) (1 - _tmp40_));
		_tmp41_ = z;
		_tmp42_ = r1;
		_tmp41_->re_fraction[0] = (gint) _tmp42_;
		_tmp43_ = _tmp41_->re_fraction[0];
		_tmp44_ = c;
		_tmp45_ = y;
		_tmp46_ = r1;
		c = BASE * (_tmp44_ - (_tmp45_ * _tmp46_));
		kh = (gint64) 1;
		_tmp47_ = i;
		if (_tmp47_ < ((gint64) T)) {
			gint64 _tmp48_;
			gint64 _tmp68_;
			_tmp48_ = i;
			kh = (T + 1) - _tmp48_;
			{
				gint k;
				k = 1;
				{
					gboolean _tmp49_;
					_tmp49_ = TRUE;
					while (TRUE) {
						gboolean _tmp50_;
						gint _tmp52_;
						gint64 _tmp53_;
						gint64 _tmp54_;
						gint64 _tmp55_;
						gint _tmp56_;
						Number* _tmp57_;
						gint _tmp58_;
						gint64 _tmp59_;
						gint64 _tmp60_;
						gint _tmp61_;
						gint64 _tmp62_;
						gint64 _tmp63_;
						Number* _tmp64_;
						gint _tmp65_;
						gint _tmp66_;
						gint64 _tmp67_;
						_tmp50_ = _tmp49_;
						if (!_tmp50_) {
							gint _tmp51_;
							_tmp51_ = k;
							k = _tmp51_ + 1;
						}
						_tmp49_ = FALSE;
						_tmp52_ = k;
						_tmp53_ = kh;
						if (!(((gint64) _tmp52_) < _tmp53_)) {
							break;
						}
						_tmp54_ = c;
						_tmp55_ = i;
						_tmp56_ = self->re_fraction[_tmp55_];
						c = _tmp54_ + _tmp56_;
						_tmp57_ = z;
						_tmp58_ = k;
						_tmp59_ = c;
						_tmp60_ = y;
						_tmp57_->re_fraction[_tmp58_] = (gint) (_tmp59_ / _tmp60_);
						_tmp61_ = _tmp57_->re_fraction[_tmp58_];
						_tmp62_ = c;
						_tmp63_ = y;
						_tmp64_ = z;
						_tmp65_ = k;
						_tmp66_ = _tmp64_->re_fraction[_tmp65_];
						c = BASE * (_tmp62_ - (_tmp63_ * _tmp66_));
						_tmp67_ = i;
						i = _tmp67_ + 1;
					}
				}
			}
			_tmp68_ = c;
			if (_tmp68_ < ((gint64) 0)) {
				Number* _tmp69_;
				mperr ("*** INTEGER OVERFLOW IN DIVIDE_INTEGER, B TOO LARGE ***");
				_tmp69_ = number_new_integer ((gint64) 0);
				result = _tmp69_;
				_number_unref0 (z);
				return result;
			}
		}
		{
			gint64 _tmp70_;
			gint64 k;
			_tmp70_ = kh;
			k = _tmp70_;
			{
				gboolean _tmp71_;
				_tmp71_ = TRUE;
				while (TRUE) {
					gboolean _tmp72_;
					gint64 _tmp74_;
					Number* _tmp75_;
					gint64 _tmp76_;
					gint64 _tmp77_;
					gint64 _tmp78_;
					gint _tmp79_;
					gint64 _tmp80_;
					gint64 _tmp81_;
					Number* _tmp82_;
					gint64 _tmp83_;
					gint _tmp84_;
					_tmp72_ = _tmp71_;
					if (!_tmp72_) {
						gint64 _tmp73_;
						_tmp73_ = k;
						k = _tmp73_ + 1;
					}
					_tmp71_ = FALSE;
					_tmp74_ = k;
					if (!(_tmp74_ < ((gint64) (T + 4)))) {
						break;
					}
					_tmp75_ = z;
					_tmp76_ = k;
					_tmp77_ = c;
					_tmp78_ = y;
					_tmp75_->re_fraction[_tmp76_] = (gint) (_tmp77_ / _tmp78_);
					_tmp79_ = _tmp75_->re_fraction[_tmp76_];
					_tmp80_ = c;
					_tmp81_ = y;
					_tmp82_ = z;
					_tmp83_ = k;
					_tmp84_ = _tmp82_->re_fraction[_tmp83_];
					c = BASE * (_tmp80_ - (_tmp81_ * _tmp84_));
				}
			}
		}
		_tmp85_ = c;
		if (_tmp85_ < ((gint64) 0)) {
			Number* _tmp86_;
			mperr ("*** INTEGER OVERFLOW IN DIVIDE_INTEGER, B TOO LARGE ***");
			_tmp86_ = number_new_integer ((gint64) 0);
			result = _tmp86_;
			_number_unref0 (z);
			return result;
		}
		mp_normalize (&z);
		result = z;
		return result;
	}
	_tmp87_ = y;
	j1 = _tmp87_ / BASE;
	_tmp88_ = y;
	_tmp89_ = j1;
	j2 = _tmp88_ - (_tmp89_ * BASE);
	c2 = 0;
	{
		gboolean _tmp90_;
		_tmp90_ = TRUE;
		while (TRUE) {
			gboolean _tmp91_;
			gint64 _tmp102_;
			gint _tmp103_;
			gint _tmp104_ = 0;
			gint64 _tmp105_;
			gint _tmp108_;
			gint64 _tmp109_;
			_tmp91_ = _tmp90_;
			if (!_tmp91_) {
				gboolean _tmp92_ = FALSE;
				gint64 _tmp93_;
				gint64 _tmp94_;
				gboolean _tmp101_;
				_tmp93_ = c;
				_tmp94_ = j1;
				if (_tmp93_ < _tmp94_) {
					_tmp92_ = TRUE;
				} else {
					gboolean _tmp95_ = FALSE;
					gint64 _tmp96_;
					gint64 _tmp97_;
					gboolean _tmp100_;
					_tmp96_ = c;
					_tmp97_ = j1;
					if (_tmp96_ == _tmp97_) {
						gint _tmp98_;
						gint64 _tmp99_;
						_tmp98_ = c2;
						_tmp99_ = j2;
						_tmp95_ = ((gint64) _tmp98_) < _tmp99_;
					} else {
						_tmp95_ = FALSE;
					}
					_tmp100_ = _tmp95_;
					_tmp92_ = _tmp100_;
				}
				_tmp101_ = _tmp92_;
				if (!_tmp101_) {
					break;
				}
			}
			_tmp90_ = FALSE;
			_tmp102_ = c;
			_tmp103_ = c2;
			c = (BASE * _tmp102_) + _tmp103_;
			_tmp105_ = i;
			if (_tmp105_ < ((gint64) T)) {
				gint64 _tmp106_;
				gint _tmp107_;
				_tmp106_ = i;
				_tmp107_ = self->re_fraction[_tmp106_];
				_tmp104_ = _tmp107_;
			} else {
				_tmp104_ = 0;
			}
			_tmp108_ = _tmp104_;
			c2 = _tmp108_;
			_tmp109_ = i;
			i = _tmp109_ + 1;
		}
	}
	_tmp110_ = z;
	_tmp111_ = z;
	_tmp112_ = _tmp111_->re_exponent;
	_tmp113_ = i;
	_tmp111_->re_exponent = _tmp112_ + ((gint) (1 - _tmp113_));
	_tmp114_ = i;
	i = _tmp114_ - 1;
	{
		gint k;
		k = 1;
		{
			gboolean _tmp115_;
			_tmp115_ = TRUE;
			while (TRUE) {
				gboolean _tmp116_;
				gint _tmp118_;
				gint64 _tmp119_;
				gint64 _tmp120_;
				gint64 ir;
				gint64 _tmp121_;
				gint64 _tmp122_;
				gint64 _tmp123_;
				gint64 iq;
				gint64 _tmp124_;
				gint _tmp125_;
				gint64 _tmp129_;
				gint64 _tmp130_;
				gint64 _tmp131_;
				gint64 _tmp132_;
				gint64 _tmp136_;
				gint64 _tmp140_;
				gint64 _tmp141_;
				gint64 _tmp142_;
				gint64 iqj;
				Number* _tmp143_;
				gint _tmp144_;
				gint64 _tmp145_;
				gint64 _tmp146_;
				gint _tmp147_;
				gint64 _tmp148_;
				gint64 _tmp149_;
				gint64 _tmp150_;
				gint64 _tmp151_;
				_tmp116_ = _tmp115_;
				if (!_tmp116_) {
					gint _tmp117_;
					_tmp117_ = k;
					k = _tmp117_ + 1;
				}
				_tmp115_ = FALSE;
				_tmp118_ = k;
				if (!(_tmp118_ <= (T + 4))) {
					break;
				}
				_tmp119_ = c;
				_tmp120_ = j1;
				ir = _tmp119_ / (_tmp120_ + 1);
				_tmp121_ = c;
				_tmp122_ = ir;
				_tmp123_ = j1;
				iq = _tmp121_ - (_tmp122_ * _tmp123_);
				_tmp124_ = iq;
				_tmp125_ = b2;
				if (_tmp124_ >= ((gint64) _tmp125_)) {
					gint64 _tmp126_;
					gint64 _tmp127_;
					gint64 _tmp128_;
					_tmp126_ = ir;
					ir = _tmp126_ + 1;
					_tmp127_ = iq;
					_tmp128_ = j1;
					iq = _tmp127_ - _tmp128_;
				}
				_tmp129_ = iq;
				_tmp130_ = ir;
				_tmp131_ = j2;
				iq = (_tmp129_ * BASE) - (_tmp130_ * _tmp131_);
				_tmp132_ = iq;
				if (_tmp132_ < ((gint64) 0)) {
					gint64 _tmp133_;
					gint64 _tmp134_;
					gint64 _tmp135_;
					_tmp133_ = ir;
					ir = _tmp133_ - 1;
					_tmp134_ = iq;
					_tmp135_ = y;
					iq = _tmp134_ + _tmp135_;
				}
				_tmp136_ = i;
				if (_tmp136_ < ((gint64) T)) {
					gint64 _tmp137_;
					gint64 _tmp138_;
					gint _tmp139_;
					_tmp137_ = iq;
					_tmp138_ = i;
					_tmp139_ = self->re_fraction[_tmp138_];
					iq = _tmp137_ + _tmp139_;
				}
				_tmp140_ = i;
				i = _tmp140_ + 1;
				_tmp141_ = iq;
				_tmp142_ = y;
				iqj = _tmp141_ / _tmp142_;
				_tmp143_ = z;
				_tmp144_ = k;
				_tmp145_ = iqj;
				_tmp146_ = ir;
				_tmp143_->re_fraction[_tmp144_ - 1] = (gint) (_tmp145_ + _tmp146_);
				_tmp147_ = _tmp143_->re_fraction[_tmp144_ - 1];
				_tmp148_ = iq;
				_tmp149_ = y;
				_tmp150_ = iqj;
				c = _tmp148_ - (_tmp149_ * _tmp150_);
				_tmp151_ = c;
				if (_tmp151_ < ((gint64) 0)) {
					Number* _tmp152_;
					mperr ("*** INTEGER OVERFLOW IN DIVIDE_INTEGER, B TOO LARGE ***");
					_tmp152_ = number_new_integer ((gint64) 0);
					result = _tmp152_;
					_number_unref0 (z);
					return result;
				}
			}
		}
	}
	mp_normalize (&z);
	mperr ("*** INTEGER OVERFLOW IN DIVIDE_INTEGER, B TOO LARGE ***");
	_tmp153_ = number_new_integer ((gint64) 0);
	result = _tmp153_;
	_number_unref0 (z);
	return result;
}


static Number* number_from_radians (Number* self, AngleUnit unit) {
	Number* result = NULL;
	AngleUnit _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = unit;
	switch (_tmp0_) {
		default:
		case ANGLE_UNIT_RADIANS:
		{
			Number* _tmp1_;
			_tmp1_ = _number_ref0 (self);
			result = _tmp1_;
			return result;
		}
		case ANGLE_UNIT_DEGREES:
		{
			Number* _tmp2_ = NULL;
			Number* _tmp3_;
			Number* _tmp4_;
			Number* _tmp5_;
			Number* _tmp6_ = NULL;
			Number* _tmp7_;
			_tmp2_ = number_multiply_integer (self, (gint64) 180);
			_tmp3_ = _tmp2_;
			_tmp4_ = number_new_pi ();
			_tmp5_ = _tmp4_;
			_tmp6_ = number_divide (_tmp3_, _tmp5_);
			_tmp7_ = _tmp6_;
			_number_unref0 (_tmp5_);
			_number_unref0 (_tmp3_);
			result = _tmp7_;
			return result;
		}
		case ANGLE_UNIT_GRADIANS:
		{
			Number* _tmp8_ = NULL;
			Number* _tmp9_;
			Number* _tmp10_;
			Number* _tmp11_;
			Number* _tmp12_ = NULL;
			Number* _tmp13_;
			_tmp8_ = number_multiply_integer (self, (gint64) 200);
			_tmp9_ = _tmp8_;
			_tmp10_ = number_new_pi ();
			_tmp11_ = _tmp10_;
			_tmp12_ = number_divide (_tmp9_, _tmp11_);
			_tmp13_ = _tmp12_;
			_number_unref0 (_tmp11_);
			_number_unref0 (_tmp9_);
			result = _tmp13_;
			return result;
		}
	}
}


static Number* number_to_radians (Number* self, AngleUnit unit) {
	Number* result = NULL;
	AngleUnit _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = unit;
	switch (_tmp0_) {
		default:
		case ANGLE_UNIT_RADIANS:
		{
			Number* _tmp1_;
			_tmp1_ = _number_ref0 (self);
			result = _tmp1_;
			return result;
		}
		case ANGLE_UNIT_DEGREES:
		{
			Number* _tmp2_;
			Number* _tmp3_;
			Number* _tmp4_ = NULL;
			Number* _tmp5_;
			Number* _tmp6_ = NULL;
			Number* _tmp7_;
			_tmp2_ = number_new_pi ();
			_tmp3_ = _tmp2_;
			_tmp4_ = number_multiply (self, _tmp3_);
			_tmp5_ = _tmp4_;
			_tmp6_ = number_divide_integer (_tmp5_, (gint64) 180);
			_tmp7_ = _tmp6_;
			_number_unref0 (_tmp5_);
			_number_unref0 (_tmp3_);
			result = _tmp7_;
			return result;
		}
		case ANGLE_UNIT_GRADIANS:
		{
			Number* _tmp8_;
			Number* _tmp9_;
			Number* _tmp10_ = NULL;
			Number* _tmp11_;
			Number* _tmp12_ = NULL;
			Number* _tmp13_;
			_tmp8_ = number_new_pi ();
			_tmp9_ = _tmp8_;
			_tmp10_ = number_multiply (self, _tmp9_);
			_tmp11_ = _tmp10_;
			_tmp12_ = number_divide_integer (_tmp11_, (gint64) 200);
			_tmp13_ = _tmp12_;
			_number_unref0 (_tmp11_);
			_number_unref0 (_tmp9_);
			result = _tmp13_;
			return result;
		}
	}
}


static Number* number_sin1 (Number* self, gboolean do_sin) {
	Number* result = NULL;
	gboolean _tmp0_ = FALSE;
	Number* _tmp4_ = NULL;
	Number* t2;
	Number* _tmp5_;
	Number* _tmp6_;
	Number* _tmp7_;
	gint _tmp8_ = 0;
	gboolean _tmp9_;
	Number* t1 = NULL;
	gint i = 0;
	Number* z = NULL;
	gboolean _tmp10_;
	gint _tmp16_ = 0;
	gint b2;
	gboolean _tmp42_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = number_is_zero (self);
	if (_tmp0_) {
		gboolean _tmp1_;
		_tmp1_ = do_sin;
		if (_tmp1_) {
			Number* _tmp2_;
			_tmp2_ = number_new_integer ((gint64) 0);
			result = _tmp2_;
			return result;
		} else {
			Number* _tmp3_;
			_tmp3_ = number_new_integer ((gint64) 1);
			result = _tmp3_;
			return result;
		}
	}
	_tmp4_ = number_multiply (self, self);
	t2 = _tmp4_;
	_tmp5_ = t2;
	_tmp6_ = number_new_integer ((gint64) 1);
	_tmp7_ = _tmp6_;
	_tmp8_ = number_compare (_tmp5_, _tmp7_);
	_tmp9_ = _tmp8_ > 0;
	_number_unref0 (_tmp7_);
	if (_tmp9_) {
		mperr ("*** ABS (X) > 1 IN CALL TO SIN1 ***");
	}
	_tmp10_ = do_sin;
	if (_tmp10_) {
		Number* _tmp11_;
		Number* _tmp12_;
		Number* _tmp13_;
		_tmp11_ = _number_ref0 (self);
		_number_unref0 (t1);
		t1 = _tmp11_;
		_tmp12_ = t1;
		_tmp13_ = _number_ref0 (_tmp12_);
		_number_unref0 (z);
		z = _tmp13_;
		i = 2;
	} else {
		Number* _tmp14_;
		Number* _tmp15_;
		_tmp14_ = number_new_integer ((gint64) 1);
		_number_unref0 (t1);
		t1 = _tmp14_;
		_tmp15_ = number_new_integer ((gint64) 0);
		_number_unref0 (z);
		z = _tmp15_;
		i = 1;
	}
	_tmp16_ = MAX (BASE, 64);
	b2 = 2 * _tmp16_;
	{
		gboolean _tmp17_;
		_tmp17_ = TRUE;
		while (TRUE) {
			gboolean _tmp18_;
			Number* _tmp21_;
			gint _tmp22_;
			Number* _tmp23_;
			Number* _tmp24_;
			Number* _tmp25_ = NULL;
			gint _tmp26_;
			gint _tmp27_;
			Number* _tmp38_;
			Number* _tmp39_;
			Number* _tmp40_ = NULL;
			gint _tmp41_;
			_tmp18_ = _tmp17_;
			if (!_tmp18_) {
				Number* _tmp19_;
				gint _tmp20_;
				_tmp19_ = t1;
				_tmp20_ = _tmp19_->re_sign;
				if (!(_tmp20_ != 0)) {
					break;
				}
			}
			_tmp17_ = FALSE;
			_tmp21_ = t1;
			_tmp22_ = _tmp21_->re_exponent;
			if ((T + _tmp22_) <= 0) {
				break;
			}
			_tmp23_ = t2;
			_tmp24_ = t1;
			_tmp25_ = number_multiply (_tmp23_, _tmp24_);
			_number_unref0 (t1);
			t1 = _tmp25_;
			_tmp26_ = i;
			_tmp27_ = b2;
			if (_tmp26_ > _tmp27_) {
				Number* _tmp28_;
				gint _tmp29_;
				Number* _tmp30_ = NULL;
				Number* _tmp31_;
				gint _tmp32_;
				Number* _tmp33_ = NULL;
				_tmp28_ = t1;
				_tmp29_ = i;
				_tmp30_ = number_divide_integer (_tmp28_, (gint64) (-_tmp29_));
				_number_unref0 (t1);
				t1 = _tmp30_;
				_tmp31_ = t1;
				_tmp32_ = i;
				_tmp33_ = number_divide_integer (_tmp31_, (gint64) (_tmp32_ + 1));
				_number_unref0 (t1);
				t1 = _tmp33_;
			} else {
				Number* _tmp34_;
				gint _tmp35_;
				gint _tmp36_;
				Number* _tmp37_ = NULL;
				_tmp34_ = t1;
				_tmp35_ = i;
				_tmp36_ = i;
				_tmp37_ = number_divide_integer (_tmp34_, (gint64) ((-_tmp35_) * (_tmp36_ + 1)));
				_number_unref0 (t1);
				t1 = _tmp37_;
			}
			_tmp38_ = t1;
			_tmp39_ = z;
			_tmp40_ = number_add (_tmp38_, _tmp39_);
			_number_unref0 (z);
			z = _tmp40_;
			_tmp41_ = i;
			i = _tmp41_ + 2;
		}
	}
	_tmp42_ = do_sin;
	if (!_tmp42_) {
		Number* _tmp43_;
		Number* _tmp44_;
		Number* _tmp45_;
		Number* _tmp46_ = NULL;
		_tmp43_ = z;
		_tmp44_ = number_new_integer ((gint64) 1);
		_tmp45_ = _tmp44_;
		_tmp46_ = number_add (_tmp43_, _tmp45_);
		_number_unref0 (z);
		z = _tmp46_;
		_number_unref0 (_tmp45_);
	}
	result = z;
	_number_unref0 (t1);
	_number_unref0 (t2);
	return result;
}


static Number* number_sin_real (Number* self, AngleUnit unit) {
	Number* result = NULL;
	gboolean _tmp0_ = FALSE;
	AngleUnit _tmp2_;
	Number* _tmp3_ = NULL;
	Number* x_radians;
	Number* _tmp4_;
	gint _tmp5_;
	gint xs;
	Number* _tmp6_;
	Number* _tmp7_ = NULL;
	Number* z = NULL;
	Number* _tmp8_;
	Number* _tmp9_;
	Number* _tmp10_;
	gint _tmp11_ = 0;
	gboolean _tmp12_;
	Number* _tmp65_;
	gint _tmp66_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = number_is_zero (self);
	if (_tmp0_) {
		Number* _tmp1_;
		_tmp1_ = number_new_integer ((gint64) 0);
		result = _tmp1_;
		return result;
	}
	_tmp2_ = unit;
	_tmp3_ = number_to_radians (self, _tmp2_);
	x_radians = _tmp3_;
	_tmp4_ = x_radians;
	_tmp5_ = _tmp4_->re_sign;
	xs = _tmp5_;
	_tmp6_ = x_radians;
	_tmp7_ = number_abs (_tmp6_);
	_number_unref0 (x_radians);
	x_radians = _tmp7_;
	_tmp8_ = x_radians;
	_tmp9_ = number_new_integer ((gint64) 1);
	_tmp10_ = _tmp9_;
	_tmp11_ = number_compare (_tmp8_, _tmp10_);
	_tmp12_ = _tmp11_ <= 0;
	_number_unref0 (_tmp10_);
	if (_tmp12_) {
		Number* _tmp13_;
		Number* _tmp14_ = NULL;
		_tmp13_ = x_radians;
		_tmp14_ = number_sin1 (_tmp13_, TRUE);
		_number_unref0 (z);
		z = _tmp14_;
	} else {
		Number* _tmp15_;
		Number* _tmp16_;
		Number* _tmp17_ = NULL;
		Number* _tmp18_;
		Number* _tmp19_;
		Number* _tmp20_ = NULL;
		Number* _tmp21_;
		Number* _tmp22_ = NULL;
		Number* _tmp23_;
		Number* _tmp24_ = NULL;
		Number* _tmp25_;
		Number* _tmp26_;
		Number* _tmp27_;
		Number* _tmp28_ = NULL;
		gint _tmp29_;
		Number* _tmp30_;
		gint _tmp31_;
		gint _tmp32_;
		Number* _tmp34_;
		Number* _tmp35_;
		Number* _tmp36_ = NULL;
		Number* _tmp37_;
		gint _tmp38_;
		Number* _tmp43_;
		gboolean _tmp44_ = FALSE;
		Number* _tmp46_;
		Number* _tmp47_;
		Number* _tmp48_ = NULL;
		Number* _tmp49_;
		gint _tmp50_;
		_tmp15_ = number_new_pi ();
		_tmp16_ = _tmp15_;
		_tmp17_ = number_divide_integer (_tmp16_, (gint64) 4);
		_number_unref0 (z);
		z = _tmp17_;
		_number_unref0 (_tmp16_);
		_tmp18_ = x_radians;
		_tmp19_ = z;
		_tmp20_ = number_divide (_tmp18_, _tmp19_);
		_number_unref0 (x_radians);
		x_radians = _tmp20_;
		_tmp21_ = x_radians;
		_tmp22_ = number_divide_integer (_tmp21_, (gint64) 8);
		_number_unref0 (x_radians);
		x_radians = _tmp22_;
		_tmp23_ = x_radians;
		_tmp24_ = number_fractional_component (_tmp23_);
		_number_unref0 (x_radians);
		x_radians = _tmp24_;
		_tmp25_ = x_radians;
		_tmp26_ = number_new_fraction ((gint64) (-1), (gint64) 2);
		_tmp27_ = _tmp26_;
		_tmp28_ = number_add (_tmp25_, _tmp27_);
		_number_unref0 (x_radians);
		x_radians = _tmp28_;
		_number_unref0 (_tmp27_);
		_tmp29_ = xs;
		_tmp30_ = x_radians;
		_tmp31_ = _tmp30_->re_sign;
		xs = (-_tmp29_) * _tmp31_;
		_tmp32_ = xs;
		if (_tmp32_ == 0) {
			Number* _tmp33_;
			_tmp33_ = number_new_integer ((gint64) 0);
			result = _tmp33_;
			_number_unref0 (z);
			_number_unref0 (x_radians);
			return result;
		}
		_tmp34_ = x_radians;
		_tmp34_->re_sign = 1;
		_tmp35_ = x_radians;
		_tmp36_ = number_multiply_integer (_tmp35_, (gint64) 4);
		_number_unref0 (x_radians);
		x_radians = _tmp36_;
		_tmp37_ = x_radians;
		_tmp38_ = _tmp37_->re_exponent;
		if (_tmp38_ > 0) {
			Number* _tmp39_;
			Number* _tmp40_;
			Number* _tmp41_;
			Number* _tmp42_ = NULL;
			_tmp39_ = x_radians;
			_tmp40_ = number_new_integer ((gint64) (-2));
			_tmp41_ = _tmp40_;
			_tmp42_ = number_add (_tmp39_, _tmp41_);
			_number_unref0 (x_radians);
			x_radians = _tmp42_;
			_number_unref0 (_tmp41_);
		}
		_tmp43_ = x_radians;
		_tmp44_ = number_is_zero (_tmp43_);
		if (_tmp44_) {
			Number* _tmp45_;
			_tmp45_ = number_new_integer ((gint64) 0);
			result = _tmp45_;
			_number_unref0 (z);
			_number_unref0 (x_radians);
			return result;
		}
		_tmp46_ = x_radians;
		_tmp46_->re_sign = 1;
		_tmp47_ = x_radians;
		_tmp48_ = number_multiply_integer (_tmp47_, (gint64) 2);
		_number_unref0 (x_radians);
		x_radians = _tmp48_;
		_tmp49_ = x_radians;
		_tmp50_ = _tmp49_->re_exponent;
		if (_tmp50_ > 0) {
			Number* _tmp51_;
			Number* _tmp52_;
			Number* _tmp53_;
			Number* _tmp54_ = NULL;
			Number* _tmp55_;
			Number* _tmp56_;
			Number* _tmp57_ = NULL;
			Number* _tmp58_;
			Number* _tmp59_ = NULL;
			_tmp51_ = x_radians;
			_tmp52_ = number_new_integer ((gint64) (-2));
			_tmp53_ = _tmp52_;
			_tmp54_ = number_add (_tmp51_, _tmp53_);
			_number_unref0 (x_radians);
			x_radians = _tmp54_;
			_number_unref0 (_tmp53_);
			_tmp55_ = x_radians;
			_tmp56_ = z;
			_tmp57_ = number_multiply (_tmp55_, _tmp56_);
			_number_unref0 (x_radians);
			x_radians = _tmp57_;
			_tmp58_ = x_radians;
			_tmp59_ = number_sin1 (_tmp58_, FALSE);
			_number_unref0 (z);
			z = _tmp59_;
		} else {
			Number* _tmp60_;
			Number* _tmp61_;
			Number* _tmp62_ = NULL;
			Number* _tmp63_;
			Number* _tmp64_ = NULL;
			_tmp60_ = x_radians;
			_tmp61_ = z;
			_tmp62_ = number_multiply (_tmp60_, _tmp61_);
			_number_unref0 (x_radians);
			x_radians = _tmp62_;
			_tmp63_ = x_radians;
			_tmp64_ = number_sin1 (_tmp63_, TRUE);
			_number_unref0 (z);
			z = _tmp64_;
		}
	}
	_tmp65_ = z;
	_tmp66_ = xs;
	_tmp65_->re_sign = _tmp66_;
	result = z;
	_number_unref0 (x_radians);
	return result;
}


static Number* number_cos_real (Number* self, AngleUnit unit) {
	Number* result = NULL;
	gboolean _tmp0_ = FALSE;
	AngleUnit _tmp2_;
	Number* _tmp3_ = NULL;
	Number* _tmp4_;
	Number* _tmp5_ = NULL;
	Number* _tmp6_;
	Number* z;
	Number* _tmp7_;
	Number* _tmp8_;
	Number* _tmp9_;
	gint _tmp10_ = 0;
	gboolean _tmp11_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = number_is_zero (self);
	if (_tmp0_) {
		Number* _tmp1_;
		_tmp1_ = number_new_integer ((gint64) 1);
		result = _tmp1_;
		return result;
	}
	_tmp2_ = unit;
	_tmp3_ = number_to_radians (self, _tmp2_);
	_tmp4_ = _tmp3_;
	_tmp5_ = number_abs (_tmp4_);
	_tmp6_ = _tmp5_;
	_number_unref0 (_tmp4_);
	z = _tmp6_;
	_tmp7_ = z;
	_tmp8_ = number_new_integer ((gint64) 1);
	_tmp9_ = _tmp8_;
	_tmp10_ = number_compare (_tmp7_, _tmp9_);
	_tmp11_ = _tmp10_ <= 0;
	_number_unref0 (_tmp9_);
	if (_tmp11_) {
		Number* _tmp12_;
		Number* _tmp13_ = NULL;
		_tmp12_ = z;
		_tmp13_ = number_sin1 (_tmp12_, FALSE);
		result = _tmp13_;
		_number_unref0 (z);
		return result;
	} else {
		Number* _tmp14_;
		Number* _tmp15_;
		Number* _tmp16_ = NULL;
		Number* _tmp17_;
		Number* _tmp18_;
		Number* _tmp19_ = NULL;
		Number* _tmp20_;
		Number* _tmp21_ = NULL;
		Number* _tmp22_;
		_tmp14_ = number_new_pi ();
		_tmp15_ = _tmp14_;
		_tmp16_ = number_divide_integer (_tmp15_, (gint64) 2);
		_tmp17_ = _tmp16_;
		_tmp18_ = z;
		_tmp19_ = number_subtract (_tmp17_, _tmp18_);
		_tmp20_ = _tmp19_;
		_tmp21_ = number_sin (_tmp20_, ANGLE_UNIT_RADIANS);
		_tmp22_ = _tmp21_;
		_number_unref0 (_tmp20_);
		_number_unref0 (_tmp17_);
		_number_unref0 (_tmp15_);
		result = _tmp22_;
		_number_unref0 (z);
		return result;
	}
	_number_unref0 (z);
}


static gchar string_get (const gchar* self, glong index) {
	gchar result = '\0';
	glong _tmp0_;
	gchar _tmp1_;
	g_return_val_if_fail (self != NULL, '\0');
	_tmp0_ = index;
	_tmp1_ = ((gchar*) self)[_tmp0_];
	result = _tmp1_;
	return result;
}


static Number* number_bitwise (Number* self, Number* y, BitwiseFunc bitwise_operator, void* bitwise_operator_target, gint wordlen) {
	Number* result = NULL;
	gchar* _tmp0_ = NULL;
	gchar* text1;
	Number* _tmp1_;
	gchar* _tmp2_ = NULL;
	gchar* text2;
	const gchar* _tmp3_;
	gint _tmp4_;
	gint _tmp5_;
	gint offset1;
	const gchar* _tmp6_;
	gint _tmp7_;
	gint _tmp8_;
	gint offset2;
	gint _tmp9_;
	gint offset_out;
	gint _tmp10_;
	gboolean _tmp17_ = FALSE;
	gint _tmp18_;
	gboolean _tmp25_;
	gint _tmp27_;
	gchar* _tmp28_ = NULL;
	gchar* text_out;
	gint text_out_length1;
	gint _text_out_size_;
	gchar* _tmp56_;
	gint _tmp56__length1;
	Number* _tmp57_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (y != NULL, NULL);
	_tmp0_ = number_to_hex_string (self);
	text1 = _tmp0_;
	_tmp1_ = y;
	_tmp2_ = number_to_hex_string (_tmp1_);
	text2 = _tmp2_;
	_tmp3_ = text1;
	_tmp4_ = strlen (_tmp3_);
	_tmp5_ = _tmp4_;
	offset1 = _tmp5_ - 1;
	_tmp6_ = text2;
	_tmp7_ = strlen (_tmp6_);
	_tmp8_ = _tmp7_;
	offset2 = _tmp8_ - 1;
	_tmp9_ = wordlen;
	offset_out = (_tmp9_ / 4) - 1;
	_tmp10_ = offset_out;
	if (_tmp10_ <= 0) {
		gint _tmp11_ = 0;
		gint _tmp12_;
		gint _tmp13_;
		gint _tmp16_;
		_tmp12_ = offset1;
		_tmp13_ = offset2;
		if (_tmp12_ > _tmp13_) {
			gint _tmp14_;
			_tmp14_ = offset1;
			_tmp11_ = _tmp14_;
		} else {
			gint _tmp15_;
			_tmp15_ = offset2;
			_tmp11_ = _tmp15_;
		}
		_tmp16_ = _tmp11_;
		offset_out = _tmp16_;
	}
	_tmp18_ = offset_out;
	if (_tmp18_ > 0) {
		gboolean _tmp19_ = FALSE;
		gint _tmp20_;
		gint _tmp21_;
		gboolean _tmp24_;
		_tmp20_ = offset_out;
		_tmp21_ = offset1;
		if (_tmp20_ < _tmp21_) {
			_tmp19_ = TRUE;
		} else {
			gint _tmp22_;
			gint _tmp23_;
			_tmp22_ = offset_out;
			_tmp23_ = offset2;
			_tmp19_ = _tmp22_ < _tmp23_;
		}
		_tmp24_ = _tmp19_;
		_tmp17_ = _tmp24_;
	} else {
		_tmp17_ = FALSE;
	}
	_tmp25_ = _tmp17_;
	if (_tmp25_) {
		Number* _tmp26_;
		mperr ("Overflow. Try a bigger word size");
		_tmp26_ = number_new_integer ((gint64) 0);
		result = _tmp26_;
		_g_free0 (text2);
		_g_free0 (text1);
		return result;
	}
	_tmp27_ = offset_out;
	_tmp28_ = g_new0 (gchar, _tmp27_ + 1);
	text_out = _tmp28_;
	text_out_length1 = _tmp27_ + 1;
	_text_out_size_ = text_out_length1;
	{
		gchar* _tmp29_;
		gint _tmp29__length1;
		gint _tmp30_;
		gchar _tmp31_;
		gboolean _tmp32_;
		_tmp29_ = text_out;
		_tmp29__length1 = text_out_length1;
		_tmp30_ = offset_out;
		_tmp29_[_tmp30_ + 1] = '\0';
		_tmp31_ = _tmp29_[_tmp30_ + 1];
		_tmp32_ = TRUE;
		while (TRUE) {
			gboolean _tmp33_;
			gint _tmp35_;
			gint v1;
			gint v2;
			static const gchar digits[] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};
			gint _tmp36_;
			gint _tmp42_;
			gchar* _tmp48_;
			gint _tmp48__length1;
			gint _tmp49_;
			BitwiseFunc _tmp50_;
			void* _tmp50__target;
			gint _tmp51_;
			gint _tmp52_;
			gint _tmp53_ = 0;
			gchar _tmp54_;
			gchar _tmp55_;
			_tmp33_ = _tmp32_;
			if (!_tmp33_) {
				gint _tmp34_;
				_tmp34_ = offset_out;
				offset_out = _tmp34_ - 1;
			}
			_tmp32_ = FALSE;
			_tmp35_ = offset_out;
			if (!(_tmp35_ >= 0)) {
				break;
			}
			v1 = 0;
			v2 = 0;
			_tmp36_ = offset1;
			if (_tmp36_ >= 0) {
				const gchar* _tmp37_;
				gint _tmp38_;
				gchar _tmp39_ = '\0';
				gint _tmp40_ = 0;
				gint _tmp41_;
				_tmp37_ = text1;
				_tmp38_ = offset1;
				_tmp39_ = string_get (_tmp37_, (glong) _tmp38_);
				_tmp40_ = number_hex_to_int (self, _tmp39_);
				v1 = _tmp40_;
				_tmp41_ = offset1;
				offset1 = _tmp41_ - 1;
			}
			_tmp42_ = offset2;
			if (_tmp42_ >= 0) {
				const gchar* _tmp43_;
				gint _tmp44_;
				gchar _tmp45_ = '\0';
				gint _tmp46_ = 0;
				gint _tmp47_;
				_tmp43_ = text2;
				_tmp44_ = offset2;
				_tmp45_ = string_get (_tmp43_, (glong) _tmp44_);
				_tmp46_ = number_hex_to_int (self, _tmp45_);
				v2 = _tmp46_;
				_tmp47_ = offset2;
				offset2 = _tmp47_ - 1;
			}
			_tmp48_ = text_out;
			_tmp48__length1 = text_out_length1;
			_tmp49_ = offset_out;
			_tmp50_ = bitwise_operator;
			_tmp50__target = bitwise_operator_target;
			_tmp51_ = v1;
			_tmp52_ = v2;
			_tmp53_ = _tmp50_ (_tmp51_, _tmp52_, _tmp50__target);
			_tmp54_ = digits[_tmp53_];
			_tmp48_[_tmp49_] = _tmp54_;
			_tmp55_ = _tmp48_[_tmp49_];
		}
	}
	_tmp56_ = text_out;
	_tmp56__length1 = text_out_length1;
	_tmp57_ = mp_set_from_string ((const gchar*) _tmp56_, 16);
	result = _tmp57_;
	text_out = (g_free (text_out), NULL);
	_g_free0 (text2);
	_g_free0 (text1);
	return result;
}


static gint number_hex_to_int (Number* self, gchar digit) {
	gint result = 0;
	gboolean _tmp0_ = FALSE;
	gchar _tmp1_;
	gboolean _tmp3_;
	gboolean _tmp5_ = FALSE;
	gchar _tmp6_;
	gboolean _tmp8_;
	gboolean _tmp10_ = FALSE;
	gchar _tmp11_;
	gboolean _tmp13_;
	g_return_val_if_fail (self != NULL, 0);
	_tmp1_ = digit;
	if (_tmp1_ >= '0') {
		gchar _tmp2_;
		_tmp2_ = digit;
		_tmp0_ = _tmp2_ <= '9';
	} else {
		_tmp0_ = FALSE;
	}
	_tmp3_ = _tmp0_;
	if (_tmp3_) {
		gchar _tmp4_;
		_tmp4_ = digit;
		result = (gint) (_tmp4_ - '0');
		return result;
	}
	_tmp6_ = digit;
	if (_tmp6_ >= 'A') {
		gchar _tmp7_;
		_tmp7_ = digit;
		_tmp5_ = _tmp7_ <= 'F';
	} else {
		_tmp5_ = FALSE;
	}
	_tmp8_ = _tmp5_;
	if (_tmp8_) {
		gchar _tmp9_;
		_tmp9_ = digit;
		result = (_tmp9_ - 'A') + 10;
		return result;
	}
	_tmp11_ = digit;
	if (_tmp11_ >= 'a') {
		gchar _tmp12_;
		_tmp12_ = digit;
		_tmp10_ = _tmp12_ <= 'f';
	} else {
		_tmp10_ = FALSE;
	}
	_tmp13_ = _tmp10_;
	if (_tmp13_) {
		gchar _tmp14_;
		_tmp14_ = digit;
		result = (_tmp14_ - 'a') + 10;
		return result;
	}
	result = 0;
	return result;
}


static gchar* number_to_hex_string (Number* self) {
	gchar* result = NULL;
	Serializer* _tmp0_;
	Serializer* serializer;
	gchar* _tmp1_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = serializer_new (DISPLAY_FORMAT_FIXED, 16, 0);
	serializer = _tmp0_;
	_tmp1_ = serializer_to_string (serializer, self);
	result = _tmp1_;
	_g_object_unref0 (serializer);
	return result;
}


Number* number_construct (GType object_type) {
	Number* self = NULL;
	self = (Number*) g_type_create_instance (object_type);
	return self;
}


Number* number_new (void) {
	return number_construct (TYPE_NUMBER);
}


static void value_number_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void value_number_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		number_unref (value->data[0].v_pointer);
	}
}


static void value_number_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = number_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer value_number_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* value_number_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		Number* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = number_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* value_number_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	Number** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = number_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* param_spec_number (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ParamSpecNumber* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_NUMBER), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer value_get_number (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_NUMBER), NULL);
	return value->data[0].v_pointer;
}


void value_set_number (GValue* value, gpointer v_object) {
	Number* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_NUMBER));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_NUMBER));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		number_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		number_unref (old);
	}
}


void value_take_number (GValue* value, gpointer v_object) {
	Number* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_NUMBER));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_NUMBER));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		number_unref (old);
	}
}


static void number_class_init (NumberClass * klass) {
	number_parent_class = g_type_class_peek_parent (klass);
	NUMBER_CLASS (klass)->finalize = number_finalize;
}


static void number_instance_init (Number * self) {
	self->ref_count = 1;
}


static void number_finalize (Number* obj) {
	Number * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_NUMBER, Number);
}


GType number_get_type (void) {
	static volatile gsize number_type_id__volatile = 0;
	if (g_once_init_enter (&number_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { value_number_init, value_number_free_value, value_number_copy_value, value_number_peek_pointer, "p", value_number_collect_value, "p", value_number_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (NumberClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) number_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Number), 0, (GInstanceInitFunc) number_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType number_type_id;
		number_type_id = g_type_register_fundamental (g_type_fundamental_next (), "Number", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&number_type_id__volatile, number_type_id);
	}
	return number_type_id__volatile;
}


gpointer number_ref (gpointer instance) {
	Number* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void number_unref (gpointer instance) {
	Number* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		NUMBER_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


void mperr (const gchar* text) {
	const gchar* _tmp0_;
	gchar* _tmp1_;
	g_return_if_fail (text != NULL);
	_tmp0_ = text;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (mp_error);
	mp_error = _tmp1_;
}


gchar* mp_get_error (void) {
	gchar* result = NULL;
	const gchar* _tmp0_;
	gchar* _tmp1_;
	_tmp0_ = mp_error;
	_tmp1_ = g_strdup (_tmp0_);
	result = _tmp1_;
	return result;
}


void mp_clear_error (void) {
	_g_free0 (mp_error);
	mp_error = NULL;
}


static gint string_index_of_char (const gchar* self, gunichar c, gint start_index) {
	gint result = 0;
	gint _tmp0_;
	gunichar _tmp1_;
	gchar* _tmp2_ = NULL;
	gchar* _result_;
	gchar* _tmp3_;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = start_index;
	_tmp1_ = c;
	_tmp2_ = g_utf8_strchr (((gchar*) self) + _tmp0_, (gssize) (-1), _tmp1_);
	_result_ = _tmp2_;
	_tmp3_ = _result_;
	if (_tmp3_ != NULL) {
		gchar* _tmp4_;
		_tmp4_ = _result_;
		result = (gint) (_tmp4_ - ((gchar*) self));
		return result;
	} else {
		result = -1;
		return result;
	}
}


static gboolean string_get_next_char (const gchar* self, gint* index, gunichar* c) {
	gunichar _vala_c = 0U;
	gboolean result = FALSE;
	gint _tmp0_;
	gunichar _tmp1_ = 0U;
	gunichar _tmp2_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = *index;
	_tmp1_ = g_utf8_get_char (((gchar*) self) + _tmp0_);
	_vala_c = _tmp1_;
	_tmp2_ = _vala_c;
	if (_tmp2_ != ((gunichar) 0)) {
		gint _tmp3_;
		gchar* _tmp4_ = NULL;
		_tmp3_ = *index;
		_tmp4_ = g_utf8_next_char (((gchar*) self) + _tmp3_);
		*index = (gint) (_tmp4_ - ((gchar*) self));
		result = TRUE;
		if (c) {
			*c = _vala_c;
		}
		return result;
	} else {
		result = FALSE;
		if (c) {
			*c = _vala_c;
		}
		return result;
	}
	if (c) {
		*c = _vala_c;
	}
}


static gboolean string_get_prev_char (const gchar* self, gint* index, gunichar* c) {
	gunichar _vala_c = 0U;
	gboolean result = FALSE;
	gint _tmp0_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = *index;
	if (0 < _tmp0_) {
		gint _tmp1_;
		gchar* _tmp2_ = NULL;
		gint _tmp3_;
		gunichar _tmp4_ = 0U;
		_tmp1_ = *index;
		_tmp2_ = g_utf8_prev_char (((gchar*) self) + _tmp1_);
		*index = (gint) (_tmp2_ - ((gchar*) self));
		_tmp3_ = *index;
		_tmp4_ = g_utf8_get_char (((gchar*) self) + _tmp3_);
		_vala_c = _tmp4_;
		result = TRUE;
		if (c) {
			*c = _vala_c;
		}
		return result;
	} else {
		_vala_c = (gunichar) 0;
		result = FALSE;
		if (c) {
			*c = _vala_c;
		}
		return result;
	}
	if (c) {
		*c = _vala_c;
	}
}


Number* mp_set_from_string (const gchar* str, gint default_base) {
	Number* result = NULL;
	const gchar* _tmp0_;
	gint _tmp1_ = 0;
	static const gunichar base_digits[] = {8320U, 8321U, 8322U, 8323U, 8324U, 8325U, 8326U, 8327U, 8328U, 8329U};
	gint index;
	gunichar c = 0U;
	gint _tmp7_;
	gint end;
	gint number_base;
	gint base_multiplier;
	gint _tmp25_;
	gboolean negate;
	const gchar* _tmp27_;
	gunichar _tmp28_ = 0U;
	gunichar _tmp29_;
	Number* _tmp36_;
	Number* z;
	static const gunichar fractions[] = {189U, 8531U, 8532U, 188U, 190U, 8533U, 8534U, 8535U, 8536U, 8537U, 8538U, 8539U, 8540U, 8541U, 8542U};
	static const gint numerators[] = {1, 1, 2, 1, 3, 1, 2, 3, 4, 1, 5, 1, 3, 5, 7};
	static const gint denominators[] = {2, 3, 3, 4, 4, 5, 5, 5, 5, 6, 6, 8, 8, 8, 8};
	gboolean has_fraction;
	const gchar* _tmp56_;
	gunichar _tmp57_ = 0U;
	gboolean _tmp58_ = FALSE;
	gboolean _tmp80_;
	gint _tmp109_;
	gint _tmp110_;
	gboolean _tmp111_;
	g_return_val_if_fail (str != NULL, NULL);
	_tmp0_ = str;
	_tmp1_ = string_index_of_char (_tmp0_, 176U, 0);
	if (_tmp1_ >= 0) {
		const gchar* _tmp2_;
		Number* _tmp3_ = NULL;
		_tmp2_ = str;
		_tmp3_ = set_from_sexagesimal (_tmp2_);
		result = _tmp3_;
		return result;
	}
	index = 0;
	while (TRUE) {
		const gchar* _tmp4_;
		gunichar _tmp5_ = 0U;
		gboolean _tmp6_ = FALSE;
		_tmp4_ = str;
		_tmp6_ = string_get_next_char (_tmp4_, &index, &_tmp5_);
		c = _tmp5_;
		if (!_tmp6_) {
			break;
		}
	}
	_tmp7_ = index;
	end = _tmp7_;
	number_base = 0;
	base_multiplier = 1;
	while (TRUE) {
		const gchar* _tmp8_;
		gunichar _tmp9_ = 0U;
		gboolean _tmp10_ = FALSE;
		gint value;
		gint _tmp19_;
		gint _tmp20_;
		gint _tmp21_;
		gint _tmp22_;
		gint _tmp23_;
		gint _tmp24_;
		_tmp8_ = str;
		_tmp10_ = string_get_prev_char (_tmp8_, &index, &_tmp9_);
		c = _tmp9_;
		if (!_tmp10_) {
			break;
		}
		value = -1;
		{
			gint i;
			i = 0;
			{
				gboolean _tmp11_;
				_tmp11_ = TRUE;
				while (TRUE) {
					gboolean _tmp12_;
					gint _tmp14_;
					gunichar _tmp15_;
					gint _tmp16_;
					gunichar _tmp17_;
					_tmp12_ = _tmp11_;
					if (!_tmp12_) {
						gint _tmp13_;
						_tmp13_ = i;
						i = _tmp13_ + 1;
					}
					_tmp11_ = FALSE;
					_tmp14_ = i;
					if (!(_tmp14_ < G_N_ELEMENTS (base_digits))) {
						break;
					}
					_tmp15_ = c;
					_tmp16_ = i;
					_tmp17_ = base_digits[_tmp16_];
					if (_tmp15_ == _tmp17_) {
						gint _tmp18_;
						_tmp18_ = i;
						value = _tmp18_;
						break;
					}
				}
			}
		}
		_tmp19_ = value;
		if (_tmp19_ < 0) {
			break;
		}
		_tmp20_ = index;
		end = _tmp20_;
		_tmp21_ = number_base;
		_tmp22_ = value;
		_tmp23_ = base_multiplier;
		number_base = _tmp21_ + (_tmp22_ * _tmp23_);
		_tmp24_ = base_multiplier;
		base_multiplier = _tmp24_ * 10;
	}
	_tmp25_ = base_multiplier;
	if (_tmp25_ == 1) {
		gint _tmp26_;
		_tmp26_ = default_base;
		number_base = _tmp26_;
	}
	negate = FALSE;
	index = 0;
	_tmp27_ = str;
	string_get_next_char (_tmp27_, &index, &_tmp28_);
	c = _tmp28_;
	_tmp29_ = c;
	if (_tmp29_ == ((gunichar) '+')) {
		negate = FALSE;
	} else {
		gboolean _tmp30_ = FALSE;
		gunichar _tmp31_;
		gboolean _tmp33_;
		_tmp31_ = c;
		if (_tmp31_ == ((gunichar) '-')) {
			_tmp30_ = TRUE;
		} else {
			gunichar _tmp32_;
			_tmp32_ = c;
			_tmp30_ = _tmp32_ == 8722U;
		}
		_tmp33_ = _tmp30_;
		if (_tmp33_) {
			negate = TRUE;
		} else {
			const gchar* _tmp34_;
			gunichar _tmp35_ = 0U;
			_tmp34_ = str;
			string_get_prev_char (_tmp34_, &index, &_tmp35_);
			c = _tmp35_;
		}
	}
	_tmp36_ = number_new_integer ((gint64) 0);
	z = _tmp36_;
	while (TRUE) {
		const gchar* _tmp37_;
		gunichar _tmp38_ = 0U;
		gboolean _tmp39_ = FALSE;
		gunichar _tmp40_;
		gint _tmp41_;
		gint _tmp42_ = 0;
		gint i;
		gint _tmp43_;
		gint _tmp44_;
		gint _tmp45_;
		Number* _tmp48_;
		gint _tmp49_;
		Number* _tmp50_ = NULL;
		Number* _tmp51_;
		gint _tmp52_;
		Number* _tmp53_;
		Number* _tmp54_;
		Number* _tmp55_ = NULL;
		_tmp37_ = str;
		_tmp39_ = string_get_next_char (_tmp37_, &index, &_tmp38_);
		c = _tmp38_;
		if (!_tmp39_) {
			break;
		}
		_tmp40_ = c;
		_tmp41_ = number_base;
		_tmp42_ = char_val (_tmp40_, _tmp41_);
		i = _tmp42_;
		_tmp43_ = i;
		_tmp44_ = number_base;
		if (_tmp43_ > _tmp44_) {
			result = NULL;
			_number_unref0 (z);
			return result;
		}
		_tmp45_ = i;
		if (_tmp45_ < 0) {
			const gchar* _tmp46_;
			gunichar _tmp47_ = 0U;
			_tmp46_ = str;
			string_get_prev_char (_tmp46_, &index, &_tmp47_);
			c = _tmp47_;
			break;
		}
		_tmp48_ = z;
		_tmp49_ = number_base;
		_tmp50_ = number_multiply_integer (_tmp48_, (gint64) _tmp49_);
		_tmp51_ = _tmp50_;
		_tmp52_ = i;
		_tmp53_ = number_new_integer ((gint64) _tmp52_);
		_tmp54_ = _tmp53_;
		_tmp55_ = number_add (_tmp51_, _tmp54_);
		_number_unref0 (z);
		z = _tmp55_;
		_number_unref0 (_tmp54_);
		_number_unref0 (_tmp51_);
	}
	has_fraction = FALSE;
	_tmp56_ = str;
	_tmp58_ = string_get_next_char (_tmp56_, &index, &_tmp57_);
	c = _tmp57_;
	if (_tmp58_) {
		gunichar _tmp77_;
		{
			gint i;
			i = 0;
			{
				gboolean _tmp59_;
				_tmp59_ = TRUE;
				while (TRUE) {
					gboolean _tmp60_;
					gint _tmp62_;
					gunichar _tmp63_;
					gint _tmp64_;
					gunichar _tmp65_;
					_tmp60_ = _tmp59_;
					if (!_tmp60_) {
						gint _tmp61_;
						_tmp61_ = i;
						i = _tmp61_ + 1;
					}
					_tmp59_ = FALSE;
					_tmp62_ = i;
					if (!(_tmp62_ < G_N_ELEMENTS (fractions))) {
						break;
					}
					_tmp63_ = c;
					_tmp64_ = i;
					_tmp65_ = fractions[_tmp64_];
					if (_tmp63_ == _tmp65_) {
						gint _tmp66_;
						gint _tmp67_;
						gint _tmp68_;
						gint _tmp69_;
						Number* _tmp70_;
						Number* fraction;
						Number* _tmp71_;
						Number* _tmp72_;
						Number* _tmp73_ = NULL;
						const gchar* _tmp74_;
						gunichar _tmp75_ = 0U;
						gboolean _tmp76_ = FALSE;
						_tmp66_ = i;
						_tmp67_ = numerators[_tmp66_];
						_tmp68_ = i;
						_tmp69_ = denominators[_tmp68_];
						_tmp70_ = number_new_fraction ((gint64) _tmp67_, (gint64) _tmp69_);
						fraction = _tmp70_;
						_tmp71_ = z;
						_tmp72_ = fraction;
						_tmp73_ = number_add (_tmp71_, _tmp72_);
						_number_unref0 (z);
						z = _tmp73_;
						_tmp74_ = str;
						_tmp76_ = string_get_next_char (_tmp74_, &index, &_tmp75_);
						c = _tmp75_;
						if (!_tmp76_) {
							result = z;
							_number_unref0 (fraction);
							return result;
						} else {
							result = NULL;
							_number_unref0 (fraction);
							_number_unref0 (z);
							return result;
						}
						_number_unref0 (fraction);
					}
				}
			}
		}
		_tmp77_ = c;
		if (_tmp77_ == ((gunichar) '.')) {
			has_fraction = TRUE;
		} else {
			const gchar* _tmp78_;
			gunichar _tmp79_ = 0U;
			_tmp78_ = str;
			string_get_prev_char (_tmp78_, &index, &_tmp79_);
			c = _tmp79_;
		}
	}
	_tmp80_ = has_fraction;
	if (_tmp80_) {
		Number* _tmp81_;
		Number* numerator;
		Number* _tmp82_;
		Number* denominator;
		Number* _tmp103_;
		Number* _tmp104_;
		Number* _tmp105_ = NULL;
		Number* _tmp106_;
		Number* _tmp107_;
		Number* _tmp108_ = NULL;
		_tmp81_ = number_new_integer ((gint64) 0);
		numerator = _tmp81_;
		_tmp82_ = number_new_integer ((gint64) 1);
		denominator = _tmp82_;
		while (TRUE) {
			const gchar* _tmp83_;
			gunichar _tmp84_ = 0U;
			gboolean _tmp85_ = FALSE;
			gunichar _tmp86_;
			gint _tmp87_;
			gint _tmp88_ = 0;
			gint i;
			gint _tmp89_;
			Number* _tmp92_;
			gint _tmp93_;
			Number* _tmp94_ = NULL;
			Number* _tmp95_;
			gint _tmp96_;
			Number* _tmp97_ = NULL;
			Number* _tmp98_;
			gint _tmp99_;
			Number* _tmp100_;
			Number* _tmp101_;
			Number* _tmp102_ = NULL;
			_tmp83_ = str;
			_tmp85_ = string_get_next_char (_tmp83_, &index, &_tmp84_);
			c = _tmp84_;
			if (!_tmp85_) {
				break;
			}
			_tmp86_ = c;
			_tmp87_ = number_base;
			_tmp88_ = char_val (_tmp86_, _tmp87_);
			i = _tmp88_;
			_tmp89_ = i;
			if (_tmp89_ < 0) {
				const gchar* _tmp90_;
				gunichar _tmp91_ = 0U;
				_tmp90_ = str;
				string_get_prev_char (_tmp90_, &index, &_tmp91_);
				c = _tmp91_;
				break;
			}
			_tmp92_ = denominator;
			_tmp93_ = number_base;
			_tmp94_ = number_multiply_integer (_tmp92_, (gint64) _tmp93_);
			_number_unref0 (denominator);
			denominator = _tmp94_;
			_tmp95_ = numerator;
			_tmp96_ = number_base;
			_tmp97_ = number_multiply_integer (_tmp95_, (gint64) _tmp96_);
			_number_unref0 (numerator);
			numerator = _tmp97_;
			_tmp98_ = numerator;
			_tmp99_ = i;
			_tmp100_ = number_new_integer ((gint64) _tmp99_);
			_tmp101_ = _tmp100_;
			_tmp102_ = number_add (_tmp98_, _tmp101_);
			_number_unref0 (numerator);
			numerator = _tmp102_;
			_number_unref0 (_tmp101_);
		}
		_tmp103_ = numerator;
		_tmp104_ = denominator;
		_tmp105_ = number_divide (_tmp103_, _tmp104_);
		_number_unref0 (numerator);
		numerator = _tmp105_;
		_tmp106_ = z;
		_tmp107_ = numerator;
		_tmp108_ = number_add (_tmp106_, _tmp107_);
		_number_unref0 (z);
		z = _tmp108_;
		_number_unref0 (denominator);
		_number_unref0 (numerator);
	}
	_tmp109_ = index;
	_tmp110_ = end;
	if (_tmp109_ != _tmp110_) {
		result = NULL;
		_number_unref0 (z);
		return result;
	}
	_tmp111_ = negate;
	if (_tmp111_) {
		Number* _tmp112_;
		Number* _tmp113_ = NULL;
		_tmp112_ = z;
		_tmp113_ = number_invert_sign (_tmp112_);
		_number_unref0 (z);
		z = _tmp113_;
	}
	result = z;
	return result;
}


gint char_val (gunichar c, gint number_base) {
	gint result = 0;
	gunichar _tmp0_;
	gboolean _tmp1_ = FALSE;
	gunichar _tmp2_;
	gint _tmp3_ = 0;
	gint value;
	gint _tmp4_;
	gint _tmp5_;
	_tmp0_ = c;
	_tmp1_ = g_unichar_isxdigit (_tmp0_);
	if (!_tmp1_) {
		result = -1;
		return result;
	}
	_tmp2_ = c;
	_tmp3_ = g_unichar_xdigit_value (_tmp2_);
	value = _tmp3_;
	_tmp4_ = value;
	_tmp5_ = number_base;
	if (_tmp4_ >= _tmp5_) {
		result = -1;
		return result;
	}
	result = value;
	return result;
}


Number* set_from_sexagesimal (const gchar* str) {
	Number* result = NULL;
	const gchar* _tmp0_;
	gint _tmp1_ = 0;
	gint degree_index;
	gint _tmp2_;
	const gchar* _tmp3_;
	gint _tmp4_;
	gchar* _tmp5_ = NULL;
	gchar* _tmp6_;
	Number* _tmp7_ = NULL;
	Number* _tmp8_;
	Number* degrees;
	Number* _tmp9_;
	gint _tmp10_;
	gint minute_start;
	gunichar c = 0U;
	const gchar* _tmp11_;
	gunichar _tmp12_ = 0U;
	const gchar* _tmp13_;
	gint _tmp14_;
	gchar _tmp15_ = '\0';
	const gchar* _tmp16_;
	gint _tmp17_;
	gint _tmp18_ = 0;
	gint minute_index;
	gint _tmp19_;
	const gchar* _tmp20_;
	gint _tmp21_;
	gint _tmp22_;
	gint _tmp23_;
	gchar* _tmp24_ = NULL;
	gchar* _tmp25_;
	Number* _tmp26_ = NULL;
	Number* _tmp27_;
	Number* minutes;
	Number* _tmp28_;
	Number* _tmp29_;
	Number* _tmp30_;
	Number* _tmp31_ = NULL;
	Number* _tmp32_;
	Number* _tmp33_ = NULL;
	gint _tmp34_;
	gint second_start;
	const gchar* _tmp35_;
	gunichar _tmp36_ = 0U;
	const gchar* _tmp37_;
	gint _tmp38_;
	gchar _tmp39_ = '\0';
	const gchar* _tmp40_;
	gint _tmp41_;
	gint _tmp42_ = 0;
	gint second_index;
	gint _tmp43_;
	const gchar* _tmp44_;
	gint _tmp45_;
	gint _tmp46_;
	gint _tmp47_;
	gchar* _tmp48_ = NULL;
	gchar* _tmp49_;
	Number* _tmp50_ = NULL;
	Number* _tmp51_;
	Number* seconds;
	Number* _tmp52_;
	Number* _tmp53_;
	Number* _tmp54_;
	Number* _tmp55_ = NULL;
	Number* _tmp56_;
	Number* _tmp57_ = NULL;
	const gchar* _tmp58_;
	gunichar _tmp59_ = 0U;
	const gchar* _tmp60_;
	gint _tmp61_;
	gchar _tmp62_ = '\0';
	g_return_val_if_fail (str != NULL, NULL);
	_tmp0_ = str;
	_tmp1_ = string_index_of_char (_tmp0_, 176U, 0);
	degree_index = _tmp1_;
	_tmp2_ = degree_index;
	if (_tmp2_ < 0) {
		result = NULL;
		return result;
	}
	_tmp3_ = str;
	_tmp4_ = degree_index;
	_tmp5_ = string_substring (_tmp3_, (glong) 0, (glong) _tmp4_);
	_tmp6_ = _tmp5_;
	_tmp7_ = mp_set_from_string (_tmp6_, 10);
	_tmp8_ = _tmp7_;
	_g_free0 (_tmp6_);
	degrees = _tmp8_;
	_tmp9_ = degrees;
	if (_tmp9_ == NULL) {
		result = NULL;
		_number_unref0 (degrees);
		return result;
	}
	_tmp10_ = degree_index;
	minute_start = _tmp10_;
	_tmp11_ = str;
	string_get_next_char (_tmp11_, &minute_start, &_tmp12_);
	c = _tmp12_;
	_tmp13_ = str;
	_tmp14_ = minute_start;
	_tmp15_ = string_get (_tmp13_, (glong) _tmp14_);
	if (_tmp15_ == '\0') {
		result = degrees;
		return result;
	}
	_tmp16_ = str;
	_tmp17_ = minute_start;
	_tmp18_ = string_index_of_char (_tmp16_, (gunichar) '\'', _tmp17_);
	minute_index = _tmp18_;
	_tmp19_ = minute_index;
	if (_tmp19_ < 0) {
		result = NULL;
		_number_unref0 (degrees);
		return result;
	}
	_tmp20_ = str;
	_tmp21_ = minute_start;
	_tmp22_ = minute_index;
	_tmp23_ = minute_start;
	_tmp24_ = string_substring (_tmp20_, (glong) _tmp21_, (glong) (_tmp22_ - _tmp23_));
	_tmp25_ = _tmp24_;
	_tmp26_ = mp_set_from_string (_tmp25_, 10);
	_tmp27_ = _tmp26_;
	_g_free0 (_tmp25_);
	minutes = _tmp27_;
	_tmp28_ = minutes;
	if (_tmp28_ == NULL) {
		result = NULL;
		_number_unref0 (minutes);
		_number_unref0 (degrees);
		return result;
	}
	_tmp29_ = degrees;
	_tmp30_ = minutes;
	_tmp31_ = number_divide_integer (_tmp30_, (gint64) 60);
	_tmp32_ = _tmp31_;
	_tmp33_ = number_add (_tmp29_, _tmp32_);
	_number_unref0 (degrees);
	degrees = _tmp33_;
	_number_unref0 (_tmp32_);
	_tmp34_ = minute_index;
	second_start = _tmp34_;
	_tmp35_ = str;
	string_get_next_char (_tmp35_, &second_start, &_tmp36_);
	c = _tmp36_;
	_tmp37_ = str;
	_tmp38_ = second_start;
	_tmp39_ = string_get (_tmp37_, (glong) _tmp38_);
	if (_tmp39_ == '\0') {
		result = degrees;
		_number_unref0 (minutes);
		return result;
	}
	_tmp40_ = str;
	_tmp41_ = second_start;
	_tmp42_ = string_index_of_char (_tmp40_, (gunichar) '"', _tmp41_);
	second_index = _tmp42_;
	_tmp43_ = second_index;
	if (_tmp43_ < 0) {
		result = NULL;
		_number_unref0 (minutes);
		_number_unref0 (degrees);
		return result;
	}
	_tmp44_ = str;
	_tmp45_ = second_start;
	_tmp46_ = second_index;
	_tmp47_ = second_start;
	_tmp48_ = string_substring (_tmp44_, (glong) _tmp45_, (glong) (_tmp46_ - _tmp47_));
	_tmp49_ = _tmp48_;
	_tmp50_ = mp_set_from_string (_tmp49_, 10);
	_tmp51_ = _tmp50_;
	_g_free0 (_tmp49_);
	seconds = _tmp51_;
	_tmp52_ = seconds;
	if (_tmp52_ == NULL) {
		result = NULL;
		_number_unref0 (seconds);
		_number_unref0 (minutes);
		_number_unref0 (degrees);
		return result;
	}
	_tmp53_ = degrees;
	_tmp54_ = seconds;
	_tmp55_ = number_divide_integer (_tmp54_, (gint64) 3600);
	_tmp56_ = _tmp55_;
	_tmp57_ = number_add (_tmp53_, _tmp56_);
	_number_unref0 (degrees);
	degrees = _tmp57_;
	_number_unref0 (_tmp56_);
	_tmp58_ = str;
	string_get_next_char (_tmp58_, &second_index, &_tmp59_);
	c = _tmp59_;
	_tmp60_ = str;
	_tmp61_ = second_index;
	_tmp62_ = string_get (_tmp60_, (glong) _tmp61_);
	if (_tmp62_ == '\0') {
		result = degrees;
		_number_unref0 (seconds);
		_number_unref0 (minutes);
		return result;
	} else {
		result = NULL;
		_number_unref0 (seconds);
		_number_unref0 (minutes);
		_number_unref0 (degrees);
		return result;
	}
	_number_unref0 (seconds);
	_number_unref0 (minutes);
	_number_unref0 (degrees);
}


void mp_gcd (gint64* k, gint64* l) {
	gint64 _tmp0_;
	gint64 _tmp1_ = 0LL;
	gint64 i;
	gint64 _tmp2_;
	gint64 _tmp3_ = 0LL;
	gint64 j;
	gint64 _tmp4_;
	gint64 _tmp18_;
	gint64 _tmp19_;
	gint64 _tmp20_;
	gint64 _tmp21_;
	_tmp0_ = *k;
	_tmp1_ = llabs (_tmp0_);
	i = _tmp1_;
	_tmp2_ = *l;
	_tmp3_ = llabs (_tmp2_);
	j = _tmp3_;
	_tmp4_ = j;
	if (_tmp4_ == ((gint64) 0)) {
		gint64 _tmp5_;
		*k = (gint64) 1;
		*l = (gint64) 0;
		_tmp5_ = i;
		if (_tmp5_ == ((gint64) 0)) {
			*k = (gint64) 0;
		}
		return;
	}
	{
		gboolean _tmp6_;
		_tmp6_ = TRUE;
		while (TRUE) {
			gboolean _tmp7_;
			gint64 _tmp9_;
			gint64 _tmp10_;
			gint64 _tmp11_;
			gint64 _tmp16_;
			gint64 _tmp17_;
			_tmp7_ = _tmp6_;
			if (!_tmp7_) {
				gint64 _tmp8_;
				_tmp8_ = j;
				if (!(_tmp8_ != ((gint64) 0))) {
					break;
				}
			}
			_tmp6_ = FALSE;
			_tmp9_ = i;
			_tmp10_ = j;
			i = _tmp9_ % _tmp10_;
			_tmp11_ = i;
			if (_tmp11_ == ((gint64) 0)) {
				gint64 _tmp12_;
				gint64 _tmp13_;
				gint64 _tmp14_;
				gint64 _tmp15_;
				_tmp12_ = *k;
				_tmp13_ = j;
				*k = _tmp12_ / _tmp13_;
				_tmp14_ = *l;
				_tmp15_ = j;
				*l = _tmp14_ / _tmp15_;
				return;
			}
			_tmp16_ = j;
			_tmp17_ = i;
			j = _tmp16_ % _tmp17_;
		}
	}
	_tmp18_ = *k;
	_tmp19_ = i;
	*k = _tmp18_ / _tmp19_;
	_tmp20_ = *l;
	_tmp21_ = i;
	*l = _tmp20_ / _tmp21_;
}


void mp_normalize (Number** x) {
	gint start_index = 0;
	gint _tmp9_;
	gint _tmp12_;
	g_return_if_fail (*x != NULL);
	{
		gboolean _tmp0_;
		start_index = 0;
		_tmp0_ = TRUE;
		while (TRUE) {
			gboolean _tmp1_;
			gboolean _tmp3_ = FALSE;
			gint _tmp4_;
			gboolean _tmp8_;
			_tmp1_ = _tmp0_;
			if (!_tmp1_) {
				gint _tmp2_;
				_tmp2_ = start_index;
				start_index = _tmp2_ + 1;
			}
			_tmp0_ = FALSE;
			_tmp4_ = start_index;
			if (_tmp4_ < SIZE) {
				Number* _tmp5_;
				gint _tmp6_;
				gint _tmp7_;
				_tmp5_ = *x;
				_tmp6_ = start_index;
				_tmp7_ = _tmp5_->re_fraction[_tmp6_];
				_tmp3_ = _tmp7_ == 0;
			} else {
				_tmp3_ = FALSE;
			}
			_tmp8_ = _tmp3_;
			if (!_tmp8_) {
				break;
			}
		}
	}
	_tmp9_ = start_index;
	if (_tmp9_ >= SIZE) {
		Number* _tmp10_;
		Number* _tmp11_;
		_tmp10_ = *x;
		_tmp10_->re_sign = 0;
		_tmp11_ = *x;
		_tmp11_->re_exponent = 0;
		return;
	}
	_tmp12_ = start_index;
	if (_tmp12_ > 0) {
		Number* _tmp13_;
		Number* _tmp14_;
		gint _tmp15_;
		gint _tmp16_;
		gint i;
		_tmp13_ = *x;
		_tmp14_ = *x;
		_tmp15_ = _tmp14_->re_exponent;
		_tmp16_ = start_index;
		_tmp14_->re_exponent = _tmp15_ - _tmp16_;
		i = 0;
		{
			gboolean _tmp17_;
			_tmp17_ = TRUE;
			while (TRUE) {
				gboolean _tmp18_;
				gint _tmp20_;
				gint _tmp21_;
				Number* _tmp22_;
				gint _tmp23_;
				Number* _tmp24_;
				gint _tmp25_;
				gint _tmp26_;
				gint _tmp27_;
				gint _tmp28_;
				_tmp18_ = _tmp17_;
				if (!_tmp18_) {
					gint _tmp19_;
					_tmp19_ = i;
					i = _tmp19_ + 1;
				}
				_tmp17_ = FALSE;
				_tmp20_ = i;
				_tmp21_ = start_index;
				if (!((_tmp20_ + _tmp21_) < SIZE)) {
					break;
				}
				_tmp22_ = *x;
				_tmp23_ = i;
				_tmp24_ = *x;
				_tmp25_ = i;
				_tmp26_ = start_index;
				_tmp27_ = _tmp24_->re_fraction[_tmp25_ + _tmp26_];
				_tmp22_->re_fraction[_tmp23_] = _tmp27_;
				_tmp28_ = _tmp22_->re_fraction[_tmp23_];
			}
		}
		{
			gboolean _tmp29_;
			_tmp29_ = TRUE;
			while (TRUE) {
				gboolean _tmp30_;
				gint _tmp32_;
				Number* _tmp33_;
				gint _tmp34_;
				gint _tmp35_;
				_tmp30_ = _tmp29_;
				if (!_tmp30_) {
					gint _tmp31_;
					_tmp31_ = i;
					i = _tmp31_ + 1;
				}
				_tmp29_ = FALSE;
				_tmp32_ = i;
				if (!(_tmp32_ < SIZE)) {
					break;
				}
				_tmp33_ = *x;
				_tmp34_ = i;
				_tmp33_->re_fraction[_tmp34_] = 0;
				_tmp35_ = _tmp33_->re_fraction[_tmp34_];
			}
		}
	}
}


gboolean mp_is_overflow (Number* x, gint wordlen) {
	gboolean result = FALSE;
	Number* _tmp0_;
	Number* _tmp1_;
	gint _tmp2_;
	Number* _tmp3_ = NULL;
	Number* _tmp4_;
	Number* t2;
	Number* _tmp5_;
	gint _tmp6_ = 0;
	g_return_val_if_fail (x != NULL, FALSE);
	_tmp0_ = number_new_integer ((gint64) 2);
	_tmp1_ = _tmp0_;
	_tmp2_ = wordlen;
	_tmp3_ = number_xpowy_integer (_tmp1_, (gint64) _tmp2_);
	_tmp4_ = _tmp3_;
	_number_unref0 (_tmp1_);
	t2 = _tmp4_;
	_tmp5_ = x;
	_tmp6_ = number_compare (t2, _tmp5_);
	result = _tmp6_ > 0;
	_number_unref0 (t2);
	return result;
}



