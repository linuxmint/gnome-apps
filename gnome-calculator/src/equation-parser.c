/* equation-parser.c generated by valac 0.20.1, the Vala compiler
 * generated from equation-parser.vala, do not modify */

/*
 * Copyright (C) 2012 Arth Patel
 * Copyright (C) 2012 Robert Ancell
 *
 * This program is free software: you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 2 of the License, or (at your option) any later
 * version. See http://www.gnu.org/copyleft/gpl.html the full text of the
 * license.
 */
/* Operator Associativity. */

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <gobject/gvaluecollector.h>


#define TYPE_ASSOCIATIVITY (associativity_get_type ())

#define TYPE_PRECEDENCE (precedence_get_type ())

#define TYPE_PARSE_NODE (parse_node_get_type ())
#define PARSE_NODE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PARSE_NODE, ParseNode))
#define PARSE_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PARSE_NODE, ParseNodeClass))
#define IS_PARSE_NODE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PARSE_NODE))
#define IS_PARSE_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PARSE_NODE))
#define PARSE_NODE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PARSE_NODE, ParseNodeClass))

typedef struct _ParseNode ParseNode;
typedef struct _ParseNodeClass ParseNodeClass;
typedef struct _ParseNodePrivate ParseNodePrivate;

#define TYPE_NUMBER (number_get_type ())
#define NUMBER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_NUMBER, Number))
#define NUMBER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_NUMBER, NumberClass))
#define IS_NUMBER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_NUMBER))
#define IS_NUMBER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_NUMBER))
#define NUMBER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_NUMBER, NumberClass))

typedef struct _Number Number;
typedef struct _NumberClass NumberClass;

#define TYPE_PARSER (parser_get_type ())
#define PARSER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PARSER, Parser))
#define PARSER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PARSER, ParserClass))
#define IS_PARSER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PARSER))
#define IS_PARSER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PARSER))
#define PARSER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PARSER, ParserClass))

typedef struct _Parser Parser;
typedef struct _ParserClass ParserClass;

#define TYPE_LEXER_TOKEN (lexer_token_get_type ())
#define LEXER_TOKEN(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_LEXER_TOKEN, LexerToken))
#define LEXER_TOKEN_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_LEXER_TOKEN, LexerTokenClass))
#define IS_LEXER_TOKEN(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_LEXER_TOKEN))
#define IS_LEXER_TOKEN_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_LEXER_TOKEN))
#define LEXER_TOKEN_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_LEXER_TOKEN, LexerTokenClass))

typedef struct _LexerToken LexerToken;
typedef struct _LexerTokenClass LexerTokenClass;
#define _parser_unref0(var) ((var == NULL) ? NULL : (var = (parser_unref (var), NULL)))
#define _parse_node_unref0(var) ((var == NULL) ? NULL : (var = (parse_node_unref (var), NULL)))
#define _lexer_token_unref0(var) ((var == NULL) ? NULL : (var = (lexer_token_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
typedef struct _ParamSpecParseNode ParamSpecParseNode;

#define TYPE_RNODE (rnode_get_type ())
#define RNODE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_RNODE, RNode))
#define RNODE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_RNODE, RNodeClass))
#define IS_RNODE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_RNODE))
#define IS_RNODE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_RNODE))
#define RNODE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_RNODE, RNodeClass))

typedef struct _RNode RNode;
typedef struct _RNodeClass RNodeClass;
typedef struct _RNodePrivate RNodePrivate;
#define _number_unref0(var) ((var == NULL) ? NULL : (var = (number_unref (var), NULL)))

#define TYPE_LR_NODE (lr_node_get_type ())
#define LR_NODE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_LR_NODE, LRNode))
#define LR_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_LR_NODE, LRNodeClass))
#define IS_LR_NODE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_LR_NODE))
#define IS_LR_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_LR_NODE))
#define LR_NODE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_LR_NODE, LRNodeClass))

typedef struct _LRNode LRNode;
typedef struct _LRNodeClass LRNodeClass;
typedef struct _LRNodePrivate LRNodePrivate;

#define TYPE_CONSTANT_NODE (constant_node_get_type ())
#define CONSTANT_NODE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CONSTANT_NODE, ConstantNode))
#define CONSTANT_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CONSTANT_NODE, ConstantNodeClass))
#define IS_CONSTANT_NODE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CONSTANT_NODE))
#define IS_CONSTANT_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CONSTANT_NODE))
#define CONSTANT_NODE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CONSTANT_NODE, ConstantNodeClass))

typedef struct _ConstantNode ConstantNode;
typedef struct _ConstantNodeClass ConstantNodeClass;
typedef struct _ConstantNodePrivate ConstantNodePrivate;
typedef struct _LexerTokenPrivate LexerTokenPrivate;

#define TYPE_LEXER_TOKEN_TYPE (lexer_token_type_get_type ())
typedef struct _ParserPrivate ParserPrivate;

#define TYPE_ASSIGN_NODE (assign_node_get_type ())
#define ASSIGN_NODE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_ASSIGN_NODE, AssignNode))
#define ASSIGN_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_ASSIGN_NODE, AssignNodeClass))
#define IS_ASSIGN_NODE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_ASSIGN_NODE))
#define IS_ASSIGN_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_ASSIGN_NODE))
#define ASSIGN_NODE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_ASSIGN_NODE, AssignNodeClass))

typedef struct _AssignNode AssignNode;
typedef struct _AssignNodeClass AssignNodeClass;
typedef struct _AssignNodePrivate AssignNodePrivate;

#define TYPE_NAME_NODE (name_node_get_type ())
#define NAME_NODE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_NAME_NODE, NameNode))
#define NAME_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_NAME_NODE, NameNodeClass))
#define IS_NAME_NODE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_NAME_NODE))
#define IS_NAME_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_NAME_NODE))
#define NAME_NODE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_NAME_NODE, NameNodeClass))

typedef struct _NameNode NameNode;
typedef struct _NameNodeClass NameNodeClass;
typedef struct _NameNodePrivate NameNodePrivate;

#define TYPE_VARIABLE_NODE (variable_node_get_type ())
#define VARIABLE_NODE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_VARIABLE_NODE, VariableNode))
#define VARIABLE_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_VARIABLE_NODE, VariableNodeClass))
#define IS_VARIABLE_NODE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_VARIABLE_NODE))
#define IS_VARIABLE_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_VARIABLE_NODE))
#define VARIABLE_NODE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_VARIABLE_NODE, VariableNodeClass))

typedef struct _VariableNode VariableNode;
typedef struct _VariableNodeClass VariableNodeClass;
typedef struct _VariableNodePrivate VariableNodePrivate;

#define TYPE_ERROR_CODE (error_code_get_type ())

#define TYPE_VARIABLE_WITH_POWER_NODE (variable_with_power_node_get_type ())
#define VARIABLE_WITH_POWER_NODE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_VARIABLE_WITH_POWER_NODE, VariableWithPowerNode))
#define VARIABLE_WITH_POWER_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_VARIABLE_WITH_POWER_NODE, VariableWithPowerNodeClass))
#define IS_VARIABLE_WITH_POWER_NODE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_VARIABLE_WITH_POWER_NODE))
#define IS_VARIABLE_WITH_POWER_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_VARIABLE_WITH_POWER_NODE))
#define VARIABLE_WITH_POWER_NODE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_VARIABLE_WITH_POWER_NODE, VariableWithPowerNodeClass))

typedef struct _VariableWithPowerNode VariableWithPowerNode;
typedef struct _VariableWithPowerNodeClass VariableWithPowerNodeClass;
typedef struct _VariableWithPowerNodePrivate VariableWithPowerNodePrivate;

#define TYPE_FUNCTION_NODE (function_node_get_type ())
#define FUNCTION_NODE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_FUNCTION_NODE, FunctionNode))
#define FUNCTION_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_FUNCTION_NODE, FunctionNodeClass))
#define IS_FUNCTION_NODE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_FUNCTION_NODE))
#define IS_FUNCTION_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_FUNCTION_NODE))
#define FUNCTION_NODE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_FUNCTION_NODE, FunctionNodeClass))

typedef struct _FunctionNode FunctionNode;
typedef struct _FunctionNodeClass FunctionNodeClass;
typedef struct _FunctionNodePrivate FunctionNodePrivate;

#define TYPE_FUNCTION_WITH_POWER_NODE (function_with_power_node_get_type ())
#define FUNCTION_WITH_POWER_NODE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_FUNCTION_WITH_POWER_NODE, FunctionWithPowerNode))
#define FUNCTION_WITH_POWER_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_FUNCTION_WITH_POWER_NODE, FunctionWithPowerNodeClass))
#define IS_FUNCTION_WITH_POWER_NODE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_FUNCTION_WITH_POWER_NODE))
#define IS_FUNCTION_WITH_POWER_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_FUNCTION_WITH_POWER_NODE))
#define FUNCTION_WITH_POWER_NODE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_FUNCTION_WITH_POWER_NODE, FunctionWithPowerNodeClass))

typedef struct _FunctionWithPowerNode FunctionWithPowerNode;
typedef struct _FunctionWithPowerNodeClass FunctionWithPowerNodeClass;
typedef struct _FunctionWithPowerNodePrivate FunctionWithPowerNodePrivate;

#define TYPE_FUNCTION_WITH_NEGATIVE_POWER_NODE (function_with_negative_power_node_get_type ())
#define FUNCTION_WITH_NEGATIVE_POWER_NODE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_FUNCTION_WITH_NEGATIVE_POWER_NODE, FunctionWithNegativePowerNode))
#define FUNCTION_WITH_NEGATIVE_POWER_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_FUNCTION_WITH_NEGATIVE_POWER_NODE, FunctionWithNegativePowerNodeClass))
#define IS_FUNCTION_WITH_NEGATIVE_POWER_NODE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_FUNCTION_WITH_NEGATIVE_POWER_NODE))
#define IS_FUNCTION_WITH_NEGATIVE_POWER_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_FUNCTION_WITH_NEGATIVE_POWER_NODE))
#define FUNCTION_WITH_NEGATIVE_POWER_NODE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_FUNCTION_WITH_NEGATIVE_POWER_NODE, FunctionWithNegativePowerNodeClass))

typedef struct _FunctionWithNegativePowerNode FunctionWithNegativePowerNode;
typedef struct _FunctionWithNegativePowerNodeClass FunctionWithNegativePowerNodeClass;
typedef struct _FunctionWithNegativePowerNodePrivate FunctionWithNegativePowerNodePrivate;

#define TYPE_UNARY_MINUS_NODE (unary_minus_node_get_type ())
#define UNARY_MINUS_NODE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_UNARY_MINUS_NODE, UnaryMinusNode))
#define UNARY_MINUS_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_UNARY_MINUS_NODE, UnaryMinusNodeClass))
#define IS_UNARY_MINUS_NODE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_UNARY_MINUS_NODE))
#define IS_UNARY_MINUS_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_UNARY_MINUS_NODE))
#define UNARY_MINUS_NODE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_UNARY_MINUS_NODE, UnaryMinusNodeClass))

typedef struct _UnaryMinusNode UnaryMinusNode;
typedef struct _UnaryMinusNodeClass UnaryMinusNodeClass;
typedef struct _UnaryMinusNodePrivate UnaryMinusNodePrivate;

#define TYPE_ABSOLUTE_VALUE_NODE (absolute_value_node_get_type ())
#define ABSOLUTE_VALUE_NODE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_ABSOLUTE_VALUE_NODE, AbsoluteValueNode))
#define ABSOLUTE_VALUE_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_ABSOLUTE_VALUE_NODE, AbsoluteValueNodeClass))
#define IS_ABSOLUTE_VALUE_NODE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_ABSOLUTE_VALUE_NODE))
#define IS_ABSOLUTE_VALUE_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_ABSOLUTE_VALUE_NODE))
#define ABSOLUTE_VALUE_NODE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_ABSOLUTE_VALUE_NODE, AbsoluteValueNodeClass))

typedef struct _AbsoluteValueNode AbsoluteValueNode;
typedef struct _AbsoluteValueNodeClass AbsoluteValueNodeClass;
typedef struct _AbsoluteValueNodePrivate AbsoluteValueNodePrivate;

#define TYPE_FLOOR_NODE (floor_node_get_type ())
#define FLOOR_NODE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_FLOOR_NODE, FloorNode))
#define FLOOR_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_FLOOR_NODE, FloorNodeClass))
#define IS_FLOOR_NODE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_FLOOR_NODE))
#define IS_FLOOR_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_FLOOR_NODE))
#define FLOOR_NODE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_FLOOR_NODE, FloorNodeClass))

typedef struct _FloorNode FloorNode;
typedef struct _FloorNodeClass FloorNodeClass;
typedef struct _FloorNodePrivate FloorNodePrivate;

#define TYPE_CEILING_NODE (ceiling_node_get_type ())
#define CEILING_NODE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CEILING_NODE, CeilingNode))
#define CEILING_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CEILING_NODE, CeilingNodeClass))
#define IS_CEILING_NODE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CEILING_NODE))
#define IS_CEILING_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CEILING_NODE))
#define CEILING_NODE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CEILING_NODE, CeilingNodeClass))

typedef struct _CeilingNode CeilingNode;
typedef struct _CeilingNodeClass CeilingNodeClass;
typedef struct _CeilingNodePrivate CeilingNodePrivate;

#define TYPE_FRACTIONAL_COMPONENT_NODE (fractional_component_node_get_type ())
#define FRACTIONAL_COMPONENT_NODE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_FRACTIONAL_COMPONENT_NODE, FractionalComponentNode))
#define FRACTIONAL_COMPONENT_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_FRACTIONAL_COMPONENT_NODE, FractionalComponentNodeClass))
#define IS_FRACTIONAL_COMPONENT_NODE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_FRACTIONAL_COMPONENT_NODE))
#define IS_FRACTIONAL_COMPONENT_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_FRACTIONAL_COMPONENT_NODE))
#define FRACTIONAL_COMPONENT_NODE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_FRACTIONAL_COMPONENT_NODE, FractionalComponentNodeClass))

typedef struct _FractionalComponentNode FractionalComponentNode;
typedef struct _FractionalComponentNodeClass FractionalComponentNodeClass;
typedef struct _FractionalComponentNodePrivate FractionalComponentNodePrivate;

#define TYPE_ROUND_NODE (round_node_get_type ())
#define ROUND_NODE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_ROUND_NODE, RoundNode))
#define ROUND_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_ROUND_NODE, RoundNodeClass))
#define IS_ROUND_NODE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_ROUND_NODE))
#define IS_ROUND_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_ROUND_NODE))
#define ROUND_NODE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_ROUND_NODE, RoundNodeClass))

typedef struct _RoundNode RoundNode;
typedef struct _RoundNodeClass RoundNodeClass;
typedef struct _RoundNodePrivate RoundNodePrivate;

#define TYPE_PERCENT_NODE (percent_node_get_type ())
#define PERCENT_NODE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PERCENT_NODE, PercentNode))
#define PERCENT_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PERCENT_NODE, PercentNodeClass))
#define IS_PERCENT_NODE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PERCENT_NODE))
#define IS_PERCENT_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PERCENT_NODE))
#define PERCENT_NODE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PERCENT_NODE, PercentNodeClass))

typedef struct _PercentNode PercentNode;
typedef struct _PercentNodeClass PercentNodeClass;
typedef struct _PercentNodePrivate PercentNodePrivate;

#define TYPE_FACTORIAL_NODE (factorial_node_get_type ())
#define FACTORIAL_NODE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_FACTORIAL_NODE, FactorialNode))
#define FACTORIAL_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_FACTORIAL_NODE, FactorialNodeClass))
#define IS_FACTORIAL_NODE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_FACTORIAL_NODE))
#define IS_FACTORIAL_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_FACTORIAL_NODE))
#define FACTORIAL_NODE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_FACTORIAL_NODE, FactorialNodeClass))

typedef struct _FactorialNode FactorialNode;
typedef struct _FactorialNodeClass FactorialNodeClass;
typedef struct _FactorialNodePrivate FactorialNodePrivate;

#define TYPE_ADD_NODE (add_node_get_type ())
#define ADD_NODE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_ADD_NODE, AddNode))
#define ADD_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_ADD_NODE, AddNodeClass))
#define IS_ADD_NODE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_ADD_NODE))
#define IS_ADD_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_ADD_NODE))
#define ADD_NODE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_ADD_NODE, AddNodeClass))

typedef struct _AddNode AddNode;
typedef struct _AddNodeClass AddNodeClass;
typedef struct _AddNodePrivate AddNodePrivate;

#define TYPE_SUBTRACT_NODE (subtract_node_get_type ())
#define SUBTRACT_NODE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SUBTRACT_NODE, SubtractNode))
#define SUBTRACT_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SUBTRACT_NODE, SubtractNodeClass))
#define IS_SUBTRACT_NODE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SUBTRACT_NODE))
#define IS_SUBTRACT_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SUBTRACT_NODE))
#define SUBTRACT_NODE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SUBTRACT_NODE, SubtractNodeClass))

typedef struct _SubtractNode SubtractNode;
typedef struct _SubtractNodeClass SubtractNodeClass;
typedef struct _SubtractNodePrivate SubtractNodePrivate;

#define TYPE_MULTIPLY_NODE (multiply_node_get_type ())
#define MULTIPLY_NODE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MULTIPLY_NODE, MultiplyNode))
#define MULTIPLY_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MULTIPLY_NODE, MultiplyNodeClass))
#define IS_MULTIPLY_NODE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MULTIPLY_NODE))
#define IS_MULTIPLY_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MULTIPLY_NODE))
#define MULTIPLY_NODE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MULTIPLY_NODE, MultiplyNodeClass))

typedef struct _MultiplyNode MultiplyNode;
typedef struct _MultiplyNodeClass MultiplyNodeClass;
typedef struct _MultiplyNodePrivate MultiplyNodePrivate;

#define TYPE_DIVIDE_NODE (divide_node_get_type ())
#define DIVIDE_NODE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_DIVIDE_NODE, DivideNode))
#define DIVIDE_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_DIVIDE_NODE, DivideNodeClass))
#define IS_DIVIDE_NODE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_DIVIDE_NODE))
#define IS_DIVIDE_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_DIVIDE_NODE))
#define DIVIDE_NODE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_DIVIDE_NODE, DivideNodeClass))

typedef struct _DivideNode DivideNode;
typedef struct _DivideNodeClass DivideNodeClass;
typedef struct _DivideNodePrivate DivideNodePrivate;

#define TYPE_MODULUS_DIVIDE_NODE (modulus_divide_node_get_type ())
#define MODULUS_DIVIDE_NODE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MODULUS_DIVIDE_NODE, ModulusDivideNode))
#define MODULUS_DIVIDE_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MODULUS_DIVIDE_NODE, ModulusDivideNodeClass))
#define IS_MODULUS_DIVIDE_NODE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MODULUS_DIVIDE_NODE))
#define IS_MODULUS_DIVIDE_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MODULUS_DIVIDE_NODE))
#define MODULUS_DIVIDE_NODE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MODULUS_DIVIDE_NODE, ModulusDivideNodeClass))

typedef struct _ModulusDivideNode ModulusDivideNode;
typedef struct _ModulusDivideNodeClass ModulusDivideNodeClass;
typedef struct _ModulusDivideNodePrivate ModulusDivideNodePrivate;

#define TYPE_ROOT_NODE (root_node_get_type ())
#define ROOT_NODE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_ROOT_NODE, RootNode))
#define ROOT_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_ROOT_NODE, RootNodeClass))
#define IS_ROOT_NODE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_ROOT_NODE))
#define IS_ROOT_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_ROOT_NODE))
#define ROOT_NODE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_ROOT_NODE, RootNodeClass))

typedef struct _RootNode RootNode;
typedef struct _RootNodeClass RootNodeClass;
typedef struct _RootNodePrivate RootNodePrivate;

#define TYPE_XPOW_YNODE (xpow_ynode_get_type ())
#define XPOW_YNODE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_XPOW_YNODE, XPowYNode))
#define XPOW_YNODE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_XPOW_YNODE, XPowYNodeClass))
#define IS_XPOW_YNODE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_XPOW_YNODE))
#define IS_XPOW_YNODE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_XPOW_YNODE))
#define XPOW_YNODE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_XPOW_YNODE, XPowYNodeClass))

typedef struct _XPowYNode XPowYNode;
typedef struct _XPowYNodeClass XPowYNodeClass;
typedef struct _XPowYNodePrivate XPowYNodePrivate;

#define TYPE_XPOW_YINTEGER_NODE (xpow_yinteger_node_get_type ())
#define XPOW_YINTEGER_NODE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_XPOW_YINTEGER_NODE, XPowYIntegerNode))
#define XPOW_YINTEGER_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_XPOW_YINTEGER_NODE, XPowYIntegerNodeClass))
#define IS_XPOW_YINTEGER_NODE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_XPOW_YINTEGER_NODE))
#define IS_XPOW_YINTEGER_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_XPOW_YINTEGER_NODE))
#define XPOW_YINTEGER_NODE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_XPOW_YINTEGER_NODE, XPowYIntegerNodeClass))

typedef struct _XPowYIntegerNode XPowYIntegerNode;
typedef struct _XPowYIntegerNodeClass XPowYIntegerNodeClass;
typedef struct _XPowYIntegerNodePrivate XPowYIntegerNodePrivate;

#define TYPE_NOT_NODE (not_node_get_type ())
#define NOT_NODE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_NOT_NODE, NotNode))
#define NOT_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_NOT_NODE, NotNodeClass))
#define IS_NOT_NODE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_NOT_NODE))
#define IS_NOT_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_NOT_NODE))
#define NOT_NODE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_NOT_NODE, NotNodeClass))

typedef struct _NotNode NotNode;
typedef struct _NotNodeClass NotNodeClass;
typedef struct _NotNodePrivate NotNodePrivate;

#define TYPE_AND_NODE (and_node_get_type ())
#define AND_NODE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_AND_NODE, AndNode))
#define AND_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_AND_NODE, AndNodeClass))
#define IS_AND_NODE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_AND_NODE))
#define IS_AND_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_AND_NODE))
#define AND_NODE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_AND_NODE, AndNodeClass))

typedef struct _AndNode AndNode;
typedef struct _AndNodeClass AndNodeClass;
typedef struct _AndNodePrivate AndNodePrivate;

#define TYPE_OR_NODE (or_node_get_type ())
#define OR_NODE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_OR_NODE, OrNode))
#define OR_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_OR_NODE, OrNodeClass))
#define IS_OR_NODE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_OR_NODE))
#define IS_OR_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_OR_NODE))
#define OR_NODE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_OR_NODE, OrNodeClass))

typedef struct _OrNode OrNode;
typedef struct _OrNodeClass OrNodeClass;
typedef struct _OrNodePrivate OrNodePrivate;

#define TYPE_XOR_NODE (xor_node_get_type ())
#define XOR_NODE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_XOR_NODE, XorNode))
#define XOR_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_XOR_NODE, XorNodeClass))
#define IS_XOR_NODE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_XOR_NODE))
#define IS_XOR_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_XOR_NODE))
#define XOR_NODE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_XOR_NODE, XorNodeClass))

typedef struct _XorNode XorNode;
typedef struct _XorNodeClass XorNodeClass;
typedef struct _XorNodePrivate XorNodePrivate;

#define TYPE_CONVERT_NODE (convert_node_get_type ())
#define CONVERT_NODE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CONVERT_NODE, ConvertNode))
#define CONVERT_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CONVERT_NODE, ConvertNodeClass))
#define IS_CONVERT_NODE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CONVERT_NODE))
#define IS_CONVERT_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CONVERT_NODE))
#define CONVERT_NODE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CONVERT_NODE, ConvertNodeClass))

typedef struct _ConvertNode ConvertNode;
typedef struct _ConvertNodeClass ConvertNodeClass;
typedef struct _ConvertNodePrivate ConvertNodePrivate;

#define TYPE_CONVERT_BASE_NODE (convert_base_node_get_type ())
#define CONVERT_BASE_NODE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CONVERT_BASE_NODE, ConvertBaseNode))
#define CONVERT_BASE_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CONVERT_BASE_NODE, ConvertBaseNodeClass))
#define IS_CONVERT_BASE_NODE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CONVERT_BASE_NODE))
#define IS_CONVERT_BASE_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CONVERT_BASE_NODE))
#define CONVERT_BASE_NODE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CONVERT_BASE_NODE, ConvertBaseNodeClass))

typedef struct _ConvertBaseNode ConvertBaseNode;
typedef struct _ConvertBaseNodeClass ConvertBaseNodeClass;
typedef struct _ConvertBaseNodePrivate ConvertBaseNodePrivate;

#define TYPE_CONVERT_NUMBER_NODE (convert_number_node_get_type ())
#define CONVERT_NUMBER_NODE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CONVERT_NUMBER_NODE, ConvertNumberNode))
#define CONVERT_NUMBER_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CONVERT_NUMBER_NODE, ConvertNumberNodeClass))
#define IS_CONVERT_NUMBER_NODE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CONVERT_NUMBER_NODE))
#define IS_CONVERT_NUMBER_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CONVERT_NUMBER_NODE))
#define CONVERT_NUMBER_NODE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CONVERT_NUMBER_NODE, ConvertNumberNodeClass))

typedef struct _ConvertNumberNode ConvertNumberNode;
typedef struct _ConvertNumberNodeClass ConvertNumberNodeClass;
typedef struct _ConvertNumberNodePrivate ConvertNumberNodePrivate;

#define TYPE_LEXER (lexer_get_type ())
#define LEXER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_LEXER, Lexer))
#define LEXER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_LEXER, LexerClass))
#define IS_LEXER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_LEXER))
#define IS_LEXER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_LEXER))
#define LEXER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_LEXER, LexerClass))

typedef struct _Lexer Lexer;
typedef struct _LexerClass LexerClass;
#define _lexer_unref0(var) ((var == NULL) ? NULL : (var = (lexer_unref (var), NULL)))
typedef struct _ParamSpecParser ParamSpecParser;

typedef enum  {
	ASSOCIATIVITY_LEFT,
	ASSOCIATIVITY_RIGHT
} Associativity;

typedef enum  {
	PRECEDENCE_UNKNOWN = 0,
	PRECEDENCE_ADD_SUBTRACT = 1,
	PRECEDENCE_MULTIPLY = 2,
	PRECEDENCE_MOD = 3,
	PRECEDENCE_DIVIDE = 4,
	PRECEDENCE_NOT = 5,
	PRECEDENCE_ROOT = 6,
	PRECEDENCE_FUNCTION = 7,
	PRECEDENCE_BOOLEAN = 8,
	PRECEDENCE_PERCENTAGE = 9,
	PRECEDENCE_UNARY_MINUS = 10,
	PRECEDENCE_POWER = 10,
	PRECEDENCE_FACTORIAL = 11,
	PRECEDENCE_NUMBER_VARIABLE = 12,
	PRECEDENCE_DEPTH
} Precedence;

struct _ParseNode {
	GTypeInstance parent_instance;
	volatile int ref_count;
	ParseNodePrivate * priv;
	Parser* parser;
	ParseNode* parent;
	ParseNode* left;
	ParseNode* right;
	LexerToken* token;
	guint precedence;
	Associativity associativity;
	gchar* value;
};

struct _ParseNodeClass {
	GTypeClass parent_class;
	void (*finalize) (ParseNode *self);
	Number* (*solve) (ParseNode* self);
};

struct _ParamSpecParseNode {
	GParamSpec parent_instance;
};

struct _RNode {
	ParseNode parent_instance;
	RNodePrivate * priv;
};

struct _RNodeClass {
	ParseNodeClass parent_class;
	Number* (*solve_r) (RNode* self, Number* r);
};

struct _LRNode {
	ParseNode parent_instance;
	LRNodePrivate * priv;
};

struct _LRNodeClass {
	ParseNodeClass parent_class;
	Number* (*solve_lr) (LRNode* self, Number* left, Number* r);
};

struct _ConstantNode {
	ParseNode parent_instance;
	ConstantNodePrivate * priv;
};

struct _ConstantNodeClass {
	ParseNodeClass parent_class;
};

typedef enum  {
	LEXER_TOKEN_TYPE_UNKNOWN,
	LEXER_TOKEN_TYPE_PL_DECIMAL,
	LEXER_TOKEN_TYPE_PL_DIGIT,
	LEXER_TOKEN_TYPE_PL_HEX,
	LEXER_TOKEN_TYPE_PL_SUPER_DIGIT,
	LEXER_TOKEN_TYPE_PL_SUPER_MINUS,
	LEXER_TOKEN_TYPE_PL_SUB_DIGIT,
	LEXER_TOKEN_TYPE_PL_FRACTION,
	LEXER_TOKEN_TYPE_PL_DEGREE,
	LEXER_TOKEN_TYPE_PL_MINUTE,
	LEXER_TOKEN_TYPE_PL_SECOND,
	LEXER_TOKEN_TYPE_PL_LETTER,
	LEXER_TOKEN_TYPE_PL_EOS,
	LEXER_TOKEN_TYPE_PL_SKIP,
	LEXER_TOKEN_TYPE_ADD,
	LEXER_TOKEN_TYPE_SUBTRACT,
	LEXER_TOKEN_TYPE_MULTIPLY,
	LEXER_TOKEN_TYPE_DIVIDE,
	LEXER_TOKEN_TYPE_MOD,
	LEXER_TOKEN_TYPE_L_FLOOR,
	LEXER_TOKEN_TYPE_R_FLOOR,
	LEXER_TOKEN_TYPE_L_CEILING,
	LEXER_TOKEN_TYPE_R_CEILING,
	LEXER_TOKEN_TYPE_ROOT,
	LEXER_TOKEN_TYPE_ROOT_3,
	LEXER_TOKEN_TYPE_ROOT_4,
	LEXER_TOKEN_TYPE_NOT,
	LEXER_TOKEN_TYPE_AND,
	LEXER_TOKEN_TYPE_OR,
	LEXER_TOKEN_TYPE_XOR,
	LEXER_TOKEN_TYPE_IN,
	LEXER_TOKEN_TYPE_NUMBER,
	LEXER_TOKEN_TYPE_SUP_NUMBER,
	LEXER_TOKEN_TYPE_NSUP_NUMBER,
	LEXER_TOKEN_TYPE_SUB_NUMBER,
	LEXER_TOKEN_TYPE_FUNCTION,
	LEXER_TOKEN_TYPE_VARIABLE,
	LEXER_TOKEN_TYPE_ASSIGN,
	LEXER_TOKEN_TYPE_L_R_BRACKET,
	LEXER_TOKEN_TYPE_R_R_BRACKET,
	LEXER_TOKEN_TYPE_L_S_BRACKET,
	LEXER_TOKEN_TYPE_R_S_BRACKET,
	LEXER_TOKEN_TYPE_L_C_BRACKET,
	LEXER_TOKEN_TYPE_R_C_BRACKET,
	LEXER_TOKEN_TYPE_ABS,
	LEXER_TOKEN_TYPE_POWER,
	LEXER_TOKEN_TYPE_FACTORIAL,
	LEXER_TOKEN_TYPE_PERCENTAGE
} LexerTokenType;

struct _LexerToken {
	GTypeInstance parent_instance;
	volatile int ref_count;
	LexerTokenPrivate * priv;
	gchar* text;
	guint start_index;
	guint end_index;
	LexerTokenType type;
};

struct _LexerTokenClass {
	GTypeClass parent_class;
	void (*finalize) (LexerToken *self);
};

struct _Parser {
	GTypeInstance parent_instance;
	volatile int ref_count;
	ParserPrivate * priv;
	gint number_base;
	gint wordlen;
};

struct _ParserClass {
	GTypeClass parent_class;
	void (*finalize) (Parser *self);
	gboolean (*variable_is_defined) (Parser* self, const gchar* name);
	Number* (*get_variable) (Parser* self, const gchar* name);
	void (*set_variable) (Parser* self, const gchar* name, Number* x);
	gboolean (*function_is_defined) (Parser* self, const gchar* name);
	Number* (*get_function) (Parser* self, const gchar* name, Number* x);
	Number* (*convert) (Parser* self, Number* x, const gchar* x_units, const gchar* z_units);
};

struct _AssignNode {
	RNode parent_instance;
	AssignNodePrivate * priv;
};

struct _AssignNodeClass {
	RNodeClass parent_class;
};

struct _NameNode {
	ParseNode parent_instance;
	NameNodePrivate * priv;
};

struct _NameNodeClass {
	ParseNodeClass parent_class;
};

struct _VariableNode {
	ParseNode parent_instance;
	VariableNodePrivate * priv;
};

struct _VariableNodeClass {
	ParseNodeClass parent_class;
};

typedef enum  {
	ERROR_CODE_NONE,
	ERROR_CODE_INVALID,
	ERROR_CODE_OVERFLOW,
	ERROR_CODE_UNKNOWN_VARIABLE,
	ERROR_CODE_UNKNOWN_FUNCTION,
	ERROR_CODE_UNKNOWN_CONVERSION,
	ERROR_CODE_MP
} ErrorCode;

struct _VariableWithPowerNode {
	ParseNode parent_instance;
	VariableWithPowerNodePrivate * priv;
};

struct _VariableWithPowerNodeClass {
	ParseNodeClass parent_class;
};

struct _FunctionNode {
	RNode parent_instance;
	FunctionNodePrivate * priv;
};

struct _FunctionNodeClass {
	RNodeClass parent_class;
};

struct _FunctionWithPowerNode {
	ParseNode parent_instance;
	FunctionWithPowerNodePrivate * priv;
};

struct _FunctionWithPowerNodeClass {
	ParseNodeClass parent_class;
};

struct _FunctionWithNegativePowerNode {
	ParseNode parent_instance;
	FunctionWithNegativePowerNodePrivate * priv;
};

struct _FunctionWithNegativePowerNodeClass {
	ParseNodeClass parent_class;
};

struct _UnaryMinusNode {
	RNode parent_instance;
	UnaryMinusNodePrivate * priv;
};

struct _UnaryMinusNodeClass {
	RNodeClass parent_class;
};

struct _AbsoluteValueNode {
	RNode parent_instance;
	AbsoluteValueNodePrivate * priv;
};

struct _AbsoluteValueNodeClass {
	RNodeClass parent_class;
};

struct _FloorNode {
	RNode parent_instance;
	FloorNodePrivate * priv;
};

struct _FloorNodeClass {
	RNodeClass parent_class;
};

struct _CeilingNode {
	RNode parent_instance;
	CeilingNodePrivate * priv;
};

struct _CeilingNodeClass {
	RNodeClass parent_class;
};

struct _FractionalComponentNode {
	RNode parent_instance;
	FractionalComponentNodePrivate * priv;
};

struct _FractionalComponentNodeClass {
	RNodeClass parent_class;
};

struct _RoundNode {
	RNode parent_instance;
	RoundNodePrivate * priv;
};

struct _RoundNodeClass {
	RNodeClass parent_class;
};

struct _PercentNode {
	RNode parent_instance;
	PercentNodePrivate * priv;
};

struct _PercentNodeClass {
	RNodeClass parent_class;
};

struct _FactorialNode {
	RNode parent_instance;
	FactorialNodePrivate * priv;
};

struct _FactorialNodeClass {
	RNodeClass parent_class;
};

struct _AddNode {
	LRNode parent_instance;
	AddNodePrivate * priv;
	gboolean do_percentage;
};

struct _AddNodeClass {
	LRNodeClass parent_class;
};

struct _SubtractNode {
	LRNode parent_instance;
	SubtractNodePrivate * priv;
	gboolean do_percentage;
};

struct _SubtractNodeClass {
	LRNodeClass parent_class;
};

struct _MultiplyNode {
	LRNode parent_instance;
	MultiplyNodePrivate * priv;
};

struct _MultiplyNodeClass {
	LRNodeClass parent_class;
};

struct _DivideNode {
	LRNode parent_instance;
	DivideNodePrivate * priv;
};

struct _DivideNodeClass {
	LRNodeClass parent_class;
};

struct _ModulusDivideNode {
	LRNode parent_instance;
	ModulusDivideNodePrivate * priv;
};

struct _ModulusDivideNodeClass {
	LRNodeClass parent_class;
};

struct _RootNode {
	RNode parent_instance;
	RootNodePrivate * priv;
};

struct _RootNodeClass {
	RNodeClass parent_class;
};

struct _RootNodePrivate {
	gint n;
};

struct _XPowYNode {
	LRNode parent_instance;
	XPowYNodePrivate * priv;
};

struct _XPowYNodeClass {
	LRNodeClass parent_class;
};

struct _XPowYIntegerNode {
	ParseNode parent_instance;
	XPowYIntegerNodePrivate * priv;
};

struct _XPowYIntegerNodeClass {
	ParseNodeClass parent_class;
};

struct _NotNode {
	RNode parent_instance;
	NotNodePrivate * priv;
};

struct _NotNodeClass {
	RNodeClass parent_class;
};

struct _AndNode {
	LRNode parent_instance;
	AndNodePrivate * priv;
};

struct _AndNodeClass {
	LRNodeClass parent_class;
};

struct _OrNode {
	LRNode parent_instance;
	OrNodePrivate * priv;
};

struct _OrNodeClass {
	LRNodeClass parent_class;
};

struct _XorNode {
	LRNode parent_instance;
	XorNodePrivate * priv;
};

struct _XorNodeClass {
	LRNodeClass parent_class;
};

struct _ConvertNode {
	LRNode parent_instance;
	ConvertNodePrivate * priv;
};

struct _ConvertNodeClass {
	LRNodeClass parent_class;
};

struct _ConvertBaseNode {
	ParseNode parent_instance;
	ConvertBaseNodePrivate * priv;
};

struct _ConvertBaseNodeClass {
	ParseNodeClass parent_class;
};

struct _ConvertNumberNode {
	ParseNode parent_instance;
	ConvertNumberNodePrivate * priv;
};

struct _ConvertNumberNodeClass {
	ParseNodeClass parent_class;
};

struct _ParserPrivate {
	gchar* input;
	ParseNode* root;
	ParseNode* right_most;
	Lexer* lexer;
	guint depth_level;
	ErrorCode error;
	gchar* error_token;
	gint error_token_start;
	gint error_token_end;
	guint representation_base;
};

struct _ParamSpecParser {
	GParamSpec parent_instance;
};


static gpointer parse_node_parent_class = NULL;
static gpointer rnode_parent_class = NULL;
static gpointer lr_node_parent_class = NULL;
static gpointer constant_node_parent_class = NULL;
static gpointer assign_node_parent_class = NULL;
static gpointer name_node_parent_class = NULL;
static gpointer variable_node_parent_class = NULL;
static gpointer variable_with_power_node_parent_class = NULL;
static gpointer function_node_parent_class = NULL;
static gpointer function_with_power_node_parent_class = NULL;
static gpointer function_with_negative_power_node_parent_class = NULL;
static gpointer unary_minus_node_parent_class = NULL;
static gpointer absolute_value_node_parent_class = NULL;
static gpointer floor_node_parent_class = NULL;
static gpointer ceiling_node_parent_class = NULL;
static gpointer fractional_component_node_parent_class = NULL;
static gpointer round_node_parent_class = NULL;
static gpointer percent_node_parent_class = NULL;
static gpointer factorial_node_parent_class = NULL;
static gpointer add_node_parent_class = NULL;
static gpointer subtract_node_parent_class = NULL;
static gpointer multiply_node_parent_class = NULL;
static gpointer divide_node_parent_class = NULL;
static gpointer modulus_divide_node_parent_class = NULL;
static gpointer root_node_parent_class = NULL;
static gpointer xpow_ynode_parent_class = NULL;
static gpointer xpow_yinteger_node_parent_class = NULL;
static gpointer not_node_parent_class = NULL;
static gpointer and_node_parent_class = NULL;
static gpointer or_node_parent_class = NULL;
static gpointer xor_node_parent_class = NULL;
static gpointer convert_node_parent_class = NULL;
static gpointer convert_base_node_parent_class = NULL;
static gpointer convert_number_node_parent_class = NULL;
static gpointer parser_parent_class = NULL;

GType associativity_get_type (void) G_GNUC_CONST;
GType precedence_get_type (void) G_GNUC_CONST;
gpointer parse_node_ref (gpointer instance);
void parse_node_unref (gpointer instance);
GParamSpec* param_spec_parse_node (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_parse_node (GValue* value, gpointer v_object);
void value_take_parse_node (GValue* value, gpointer v_object);
gpointer value_get_parse_node (const GValue* value);
GType parse_node_get_type (void) G_GNUC_CONST;
gpointer number_ref (gpointer instance);
void number_unref (gpointer instance);
GParamSpec* param_spec_number (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_number (GValue* value, gpointer v_object);
void value_take_number (GValue* value, gpointer v_object);
gpointer value_get_number (const GValue* value);
GType number_get_type (void) G_GNUC_CONST;
gpointer parser_ref (gpointer instance);
void parser_unref (gpointer instance);
GParamSpec* param_spec_parser (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_parser (GValue* value, gpointer v_object);
void value_take_parser (GValue* value, gpointer v_object);
gpointer value_get_parser (const GValue* value);
GType parser_get_type (void) G_GNUC_CONST;
gpointer lexer_token_ref (gpointer instance);
void lexer_token_unref (gpointer instance);
GParamSpec* param_spec_lexer_token (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_lexer_token (GValue* value, gpointer v_object);
void value_take_lexer_token (GValue* value, gpointer v_object);
gpointer value_get_lexer_token (const GValue* value);
GType lexer_token_get_type (void) G_GNUC_CONST;
enum  {
	PARSE_NODE_DUMMY_PROPERTY
};
ParseNode* parse_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity, const gchar* value);
ParseNode* parse_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity, const gchar* value);
Number* parse_node_solve (ParseNode* self);
static Number* parse_node_real_solve (ParseNode* self);
static void parse_node_finalize (ParseNode* obj);
GType rnode_get_type (void) G_GNUC_CONST;
enum  {
	RNODE_DUMMY_PROPERTY
};
RNode* rnode_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
static Number* rnode_real_solve (ParseNode* base);
Number* rnode_solve_r (RNode* self, Number* r);
static Number* rnode_real_solve_r (RNode* self, Number* r);
GType lr_node_get_type (void) G_GNUC_CONST;
enum  {
	LR_NODE_DUMMY_PROPERTY
};
LRNode* lr_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
static Number* lr_node_real_solve (ParseNode* base);
Number* lr_node_solve_lr (LRNode* self, Number* left, Number* r);
static Number* lr_node_real_solve_lr (LRNode* self, Number* left, Number* r);
GType constant_node_get_type (void) G_GNUC_CONST;
enum  {
	CONSTANT_NODE_DUMMY_PROPERTY
};
ConstantNode* constant_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
ConstantNode* constant_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
static Number* constant_node_real_solve (ParseNode* base);
Number* mp_set_from_string (const gchar* str, gint default_base);
GType lexer_token_type_get_type (void) G_GNUC_CONST;
GType assign_node_get_type (void) G_GNUC_CONST;
enum  {
	ASSIGN_NODE_DUMMY_PROPERTY
};
AssignNode* assign_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
AssignNode* assign_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
static Number* assign_node_real_solve_r (RNode* base, Number* r);
void parser_set_variable (Parser* self, const gchar* name, Number* x);
GType name_node_get_type (void) G_GNUC_CONST;
enum  {
	NAME_NODE_DUMMY_PROPERTY
};
NameNode* name_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity, const gchar* text);
NameNode* name_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity, const gchar* text);
GType variable_node_get_type (void) G_GNUC_CONST;
enum  {
	VARIABLE_NODE_DUMMY_PROPERTY
};
VariableNode* variable_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
VariableNode* variable_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
static Number* variable_node_real_solve (ParseNode* base);
Number* parser_get_variable (Parser* self, const gchar* name);
Number* number_new_integer (gint64 value);
Number* number_construct_integer (GType object_type, gint64 value);
GType error_code_get_type (void) G_GNUC_CONST;
void parser_set_error (Parser* self, ErrorCode errorno, const gchar* token, guint token_start, guint token_end);
Number* number_multiply (Number* self, Number* y);
GType variable_with_power_node_get_type (void) G_GNUC_CONST;
enum  {
	VARIABLE_WITH_POWER_NODE_DUMMY_PROPERTY
};
VariableWithPowerNode* variable_with_power_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity, const gchar* text);
VariableWithPowerNode* variable_with_power_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity, const gchar* text);
static Number* variable_with_power_node_real_solve (ParseNode* base);
gint super_atoi (const gchar* data);
Number* number_xpowy_integer (Number* self, gint64 n);
GType function_node_get_type (void) G_GNUC_CONST;
enum  {
	FUNCTION_NODE_DUMMY_PROPERTY
};
FunctionNode* function_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
FunctionNode* function_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
static Number* function_node_real_solve_r (RNode* base, Number* r);
Number* parser_get_function (Parser* self, const gchar* name, Number* x);
GType function_with_power_node_get_type (void) G_GNUC_CONST;
enum  {
	FUNCTION_WITH_POWER_NODE_DUMMY_PROPERTY
};
FunctionWithPowerNode* function_with_power_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity, const gchar* text);
FunctionWithPowerNode* function_with_power_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity, const gchar* text);
static Number* function_with_power_node_real_solve (ParseNode* base);
GType function_with_negative_power_node_get_type (void) G_GNUC_CONST;
enum  {
	FUNCTION_WITH_NEGATIVE_POWER_NODE_DUMMY_PROPERTY
};
FunctionWithNegativePowerNode* function_with_negative_power_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity, const gchar* text);
FunctionWithNegativePowerNode* function_with_negative_power_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity, const gchar* text);
static Number* function_with_negative_power_node_real_solve (ParseNode* base);
GType unary_minus_node_get_type (void) G_GNUC_CONST;
enum  {
	UNARY_MINUS_NODE_DUMMY_PROPERTY
};
UnaryMinusNode* unary_minus_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
UnaryMinusNode* unary_minus_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
static Number* unary_minus_node_real_solve_r (RNode* base, Number* r);
Number* number_invert_sign (Number* self);
GType absolute_value_node_get_type (void) G_GNUC_CONST;
enum  {
	ABSOLUTE_VALUE_NODE_DUMMY_PROPERTY
};
AbsoluteValueNode* absolute_value_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
AbsoluteValueNode* absolute_value_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
static Number* absolute_value_node_real_solve_r (RNode* base, Number* r);
Number* number_abs (Number* self);
GType floor_node_get_type (void) G_GNUC_CONST;
enum  {
	FLOOR_NODE_DUMMY_PROPERTY
};
FloorNode* floor_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
FloorNode* floor_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
static Number* floor_node_real_solve_r (RNode* base, Number* r);
Number* number_floor (Number* self);
GType ceiling_node_get_type (void) G_GNUC_CONST;
enum  {
	CEILING_NODE_DUMMY_PROPERTY
};
CeilingNode* ceiling_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
CeilingNode* ceiling_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
static Number* ceiling_node_real_solve_r (RNode* base, Number* r);
Number* number_ceiling (Number* self);
GType fractional_component_node_get_type (void) G_GNUC_CONST;
enum  {
	FRACTIONAL_COMPONENT_NODE_DUMMY_PROPERTY
};
FractionalComponentNode* fractional_component_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
FractionalComponentNode* fractional_component_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
static Number* fractional_component_node_real_solve_r (RNode* base, Number* r);
Number* number_fractional_part (Number* self);
GType round_node_get_type (void) G_GNUC_CONST;
enum  {
	ROUND_NODE_DUMMY_PROPERTY
};
RoundNode* round_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
RoundNode* round_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
static Number* round_node_real_solve_r (RNode* base, Number* r);
Number* number_round (Number* self);
GType percent_node_get_type (void) G_GNUC_CONST;
enum  {
	PERCENT_NODE_DUMMY_PROPERTY
};
PercentNode* percent_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
PercentNode* percent_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
static Number* percent_node_real_solve_r (RNode* base, Number* r);
Number* number_divide_integer (Number* self, gint64 y);
GType factorial_node_get_type (void) G_GNUC_CONST;
enum  {
	FACTORIAL_NODE_DUMMY_PROPERTY
};
FactorialNode* factorial_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
FactorialNode* factorial_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
static Number* factorial_node_real_solve_r (RNode* base, Number* r);
Number* number_factorial (Number* self);
GType add_node_get_type (void) G_GNUC_CONST;
enum  {
	ADD_NODE_DUMMY_PROPERTY
};
AddNode* add_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
AddNode* add_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
static Number* add_node_real_solve_lr (LRNode* base, Number* l, Number* r);
Number* number_add (Number* self, Number* y);
static void add_node_finalize (ParseNode* obj);
GType subtract_node_get_type (void) G_GNUC_CONST;
enum  {
	SUBTRACT_NODE_DUMMY_PROPERTY
};
SubtractNode* subtract_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
SubtractNode* subtract_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
static Number* subtract_node_real_solve_lr (LRNode* base, Number* l, Number* r);
Number* number_subtract (Number* self, Number* y);
static void subtract_node_finalize (ParseNode* obj);
GType multiply_node_get_type (void) G_GNUC_CONST;
enum  {
	MULTIPLY_NODE_DUMMY_PROPERTY
};
MultiplyNode* multiply_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
MultiplyNode* multiply_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
static Number* multiply_node_real_solve_lr (LRNode* base, Number* l, Number* r);
GType divide_node_get_type (void) G_GNUC_CONST;
enum  {
	DIVIDE_NODE_DUMMY_PROPERTY
};
DivideNode* divide_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
DivideNode* divide_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
static Number* divide_node_real_solve_lr (LRNode* base, Number* l, Number* r);
Number* number_divide (Number* self, Number* y);
GType modulus_divide_node_get_type (void) G_GNUC_CONST;
enum  {
	MODULUS_DIVIDE_NODE_DUMMY_PROPERTY
};
ModulusDivideNode* modulus_divide_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
ModulusDivideNode* modulus_divide_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
static Number* modulus_divide_node_real_solve_lr (LRNode* base, Number* l, Number* r);
Number* number_modulus_divide (Number* self, Number* y);
GType root_node_get_type (void) G_GNUC_CONST;
#define ROOT_NODE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_ROOT_NODE, RootNodePrivate))
enum  {
	ROOT_NODE_DUMMY_PROPERTY
};
RootNode* root_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity, gint n);
RootNode* root_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity, gint n);
static Number* root_node_real_solve_r (RNode* base, Number* r);
Number* number_root (Number* self, gint64 n);
static void root_node_finalize (ParseNode* obj);
GType xpow_ynode_get_type (void) G_GNUC_CONST;
enum  {
	XPOW_YNODE_DUMMY_PROPERTY
};
XPowYNode* xpow_ynode_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
XPowYNode* xpow_ynode_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
static Number* xpow_ynode_real_solve_lr (LRNode* base, Number* l, Number* r);
Number* number_xpowy (Number* self, Number* y);
GType xpow_yinteger_node_get_type (void) G_GNUC_CONST;
enum  {
	XPOW_YINTEGER_NODE_DUMMY_PROPERTY
};
XPowYIntegerNode* xpow_yinteger_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
XPowYIntegerNode* xpow_yinteger_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
static Number* xpow_yinteger_node_real_solve (ParseNode* base);
GType not_node_get_type (void) G_GNUC_CONST;
enum  {
	NOT_NODE_DUMMY_PROPERTY
};
NotNode* not_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
NotNode* not_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
static Number* not_node_real_solve_r (RNode* base, Number* r);
gboolean mp_is_overflow (Number* x, gint wordlen);
Number* number_not (Number* self, gint wordlen);
GType and_node_get_type (void) G_GNUC_CONST;
enum  {
	AND_NODE_DUMMY_PROPERTY
};
AndNode* and_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
AndNode* and_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
static Number* and_node_real_solve_lr (LRNode* base, Number* l, Number* r);
Number* number_and (Number* self, Number* y);
GType or_node_get_type (void) G_GNUC_CONST;
enum  {
	OR_NODE_DUMMY_PROPERTY
};
OrNode* or_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
OrNode* or_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
static Number* or_node_real_solve_lr (LRNode* base, Number* l, Number* r);
Number* number_or (Number* self, Number* y);
GType xor_node_get_type (void) G_GNUC_CONST;
enum  {
	XOR_NODE_DUMMY_PROPERTY
};
XorNode* xor_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
XorNode* xor_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
static Number* xor_node_real_solve_lr (LRNode* base, Number* l, Number* r);
Number* number_xor (Number* self, Number* y);
GType convert_node_get_type (void) G_GNUC_CONST;
enum  {
	CONVERT_NODE_DUMMY_PROPERTY
};
ConvertNode* convert_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
ConvertNode* convert_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
static Number* convert_node_real_solve_lr (LRNode* base, Number* l, Number* r);
Number* parser_convert (Parser* self, Number* x, const gchar* x_units, const gchar* z_units);
GType convert_base_node_get_type (void) G_GNUC_CONST;
enum  {
	CONVERT_BASE_NODE_DUMMY_PROPERTY
};
ConvertBaseNode* convert_base_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity, const gchar* value);
ConvertBaseNode* convert_base_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity, const gchar* value);
static Number* convert_base_node_real_solve (ParseNode* base);
void parser_set_representation_base (Parser* self, guint new_base);
GType convert_number_node_get_type (void) G_GNUC_CONST;
enum  {
	CONVERT_NUMBER_NODE_DUMMY_PROPERTY
};
ConvertNumberNode* convert_number_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
ConvertNumberNode* convert_number_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity);
static Number* convert_number_node_real_solve (ParseNode* base);
gpointer lexer_ref (gpointer instance);
void lexer_unref (gpointer instance);
GParamSpec* param_spec_lexer (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_lexer (GValue* value, gpointer v_object);
void value_take_lexer (GValue* value, gpointer v_object);
gpointer value_get_lexer (const GValue* value);
GType lexer_get_type (void) G_GNUC_CONST;
#define PARSER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_PARSER, ParserPrivate))
enum  {
	PARSER_DUMMY_PROPERTY
};
Parser* parser_new (const gchar* input, gint number_base, gint wordlen);
Parser* parser_construct (GType object_type, const gchar* input, gint number_base, gint wordlen);
Lexer* lexer_new (const gchar* input, Parser* parser, gint number_base);
Lexer* lexer_construct (GType object_type, const gchar* input, Parser* parser, gint number_base);
gboolean parser_variable_is_defined (Parser* self, const gchar* name);
static gboolean parser_real_variable_is_defined (Parser* self, const gchar* name);
static Number* parser_real_get_variable (Parser* self, const gchar* name);
static void parser_real_set_variable (Parser* self, const gchar* name, Number* x);
gboolean parser_function_is_defined (Parser* self, const gchar* name);
static gboolean parser_real_function_is_defined (Parser* self, const gchar* name);
static Number* parser_real_get_function (Parser* self, const gchar* name, Number* x);
static Number* parser_real_convert (Parser* self, Number* x, const gchar* x_units, const gchar* z_units);
Number* parser_parse (Parser* self, guint* representation_base, ErrorCode* error_code, gchar** error_token, guint* error_start, guint* error_end);
void lexer_scan (Lexer* self);
static gboolean parser_statement (Parser* self);
LexerToken* lexer_get_next_token (Lexer* self);
static Precedence parser_get_precedence (Parser* self, LexerTokenType type);
static Associativity parser_get_associativity_p (Parser* self, Precedence type);
static Associativity parser_get_associativity (Parser* self, LexerToken* token);
static guint parser_make_precedence_p (Parser* self, Precedence p);
static guint parser_make_precedence_t (Parser* self, LexerTokenType type);
static gboolean parser_cmp_nodes (Parser* self, ParseNode* left, ParseNode* right);
static void parser_insert_into_tree_all (Parser* self, ParseNode* node, gboolean unary_function);
static void parser_insert_into_tree (Parser* self, ParseNode* node);
static void parser_insert_into_tree_unary (Parser* self, ParseNode* node);
static void parser_destroy_all_nodes (Parser* self, ParseNode* node);
static gboolean parser_check_variable (Parser* self, const gchar* name);
static gboolean parser_expression (Parser* self);
static gboolean parser_check_base (Parser* self);
void lexer_roll_back (Lexer* self);
static gboolean parser_unit (Parser* self);
static gboolean parser_expression_1 (Parser* self);
static gboolean parser_expression_2 (Parser* self);
static gboolean parser_variable (Parser* self);
gint sub_atoi (const gchar* data);
static gboolean parser_term (Parser* self);
static gboolean parser_term_2 (Parser* self);
static void parser_finalize (Parser* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);


GType associativity_get_type (void) {
	static volatile gsize associativity_type_id__volatile = 0;
	if (g_once_init_enter (&associativity_type_id__volatile)) {
		static const GEnumValue values[] = {{ASSOCIATIVITY_LEFT, "ASSOCIATIVITY_LEFT", "left"}, {ASSOCIATIVITY_RIGHT, "ASSOCIATIVITY_RIGHT", "right"}, {0, NULL, NULL}};
		GType associativity_type_id;
		associativity_type_id = g_enum_register_static ("Associativity", values);
		g_once_init_leave (&associativity_type_id__volatile, associativity_type_id);
	}
	return associativity_type_id__volatile;
}


GType precedence_get_type (void) {
	static volatile gsize precedence_type_id__volatile = 0;
	if (g_once_init_enter (&precedence_type_id__volatile)) {
		static const GEnumValue values[] = {{PRECEDENCE_UNKNOWN, "PRECEDENCE_UNKNOWN", "unknown"}, {PRECEDENCE_ADD_SUBTRACT, "PRECEDENCE_ADD_SUBTRACT", "add-subtract"}, {PRECEDENCE_MULTIPLY, "PRECEDENCE_MULTIPLY", "multiply"}, {PRECEDENCE_MOD, "PRECEDENCE_MOD", "mod"}, {PRECEDENCE_DIVIDE, "PRECEDENCE_DIVIDE", "divide"}, {PRECEDENCE_NOT, "PRECEDENCE_NOT", "not"}, {PRECEDENCE_ROOT, "PRECEDENCE_ROOT", "root"}, {PRECEDENCE_FUNCTION, "PRECEDENCE_FUNCTION", "function"}, {PRECEDENCE_BOOLEAN, "PRECEDENCE_BOOLEAN", "boolean"}, {PRECEDENCE_PERCENTAGE, "PRECEDENCE_PERCENTAGE", "percentage"}, {PRECEDENCE_UNARY_MINUS, "PRECEDENCE_UNARY_MINUS", "unary-minus"}, {PRECEDENCE_POWER, "PRECEDENCE_POWER", "power"}, {PRECEDENCE_FACTORIAL, "PRECEDENCE_FACTORIAL", "factorial"}, {PRECEDENCE_NUMBER_VARIABLE, "PRECEDENCE_NUMBER_VARIABLE", "number-variable"}, {PRECEDENCE_DEPTH, "PRECEDENCE_DEPTH", "depth"}, {0, NULL, NULL}};
		GType precedence_type_id;
		precedence_type_id = g_enum_register_static ("Precedence", values);
		g_once_init_leave (&precedence_type_id__volatile, precedence_type_id);
	}
	return precedence_type_id__volatile;
}


static gpointer _parser_ref0 (gpointer self) {
	return self ? parser_ref (self) : NULL;
}


static gpointer _lexer_token_ref0 (gpointer self) {
	return self ? lexer_token_ref (self) : NULL;
}


ParseNode* parse_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity, const gchar* value) {
	ParseNode* self = NULL;
	Parser* _tmp0_;
	Parser* _tmp1_;
	LexerToken* _tmp2_;
	LexerToken* _tmp3_;
	guint _tmp4_;
	Associativity _tmp5_;
	const gchar* _tmp6_;
	gchar* _tmp7_;
	g_return_val_if_fail (parser != NULL, NULL);
	self = (ParseNode*) g_type_create_instance (object_type);
	_tmp0_ = parser;
	_tmp1_ = _parser_ref0 (_tmp0_);
	_parser_unref0 (self->parser);
	self->parser = _tmp1_;
	_tmp2_ = token;
	_tmp3_ = _lexer_token_ref0 (_tmp2_);
	_lexer_token_unref0 (self->token);
	self->token = _tmp3_;
	_tmp4_ = precedence;
	self->precedence = _tmp4_;
	_tmp5_ = associativity;
	self->associativity = _tmp5_;
	_tmp6_ = value;
	_tmp7_ = g_strdup (_tmp6_);
	_g_free0 (self->value);
	self->value = _tmp7_;
	return self;
}


ParseNode* parse_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity, const gchar* value) {
	return parse_node_construct (TYPE_PARSE_NODE, parser, token, precedence, associativity, value);
}


static Number* parse_node_real_solve (ParseNode* self) {
	Number* result = NULL;
	result = NULL;
	return result;
}


Number* parse_node_solve (ParseNode* self) {
	g_return_val_if_fail (self != NULL, NULL);
	return PARSE_NODE_GET_CLASS (self)->solve (self);
}


static void value_parse_node_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void value_parse_node_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		parse_node_unref (value->data[0].v_pointer);
	}
}


static void value_parse_node_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = parse_node_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer value_parse_node_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* value_parse_node_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		ParseNode* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = parse_node_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* value_parse_node_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	ParseNode** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = parse_node_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* param_spec_parse_node (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ParamSpecParseNode* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_PARSE_NODE), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer value_get_parse_node (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_PARSE_NODE), NULL);
	return value->data[0].v_pointer;
}


void value_set_parse_node (GValue* value, gpointer v_object) {
	ParseNode* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_PARSE_NODE));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_PARSE_NODE));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		parse_node_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		parse_node_unref (old);
	}
}


void value_take_parse_node (GValue* value, gpointer v_object) {
	ParseNode* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_PARSE_NODE));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_PARSE_NODE));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		parse_node_unref (old);
	}
}


static void parse_node_class_init (ParseNodeClass * klass) {
	parse_node_parent_class = g_type_class_peek_parent (klass);
	PARSE_NODE_CLASS (klass)->finalize = parse_node_finalize;
	PARSE_NODE_CLASS (klass)->solve = parse_node_real_solve;
}


static void parse_node_instance_init (ParseNode * self) {
	self->parent = NULL;
	self->left = NULL;
	self->right = NULL;
	self->ref_count = 1;
}


static void parse_node_finalize (ParseNode* obj) {
	ParseNode * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_PARSE_NODE, ParseNode);
	_parser_unref0 (self->parser);
	_parse_node_unref0 (self->parent);
	_parse_node_unref0 (self->left);
	_parse_node_unref0 (self->right);
	_lexer_token_unref0 (self->token);
	_g_free0 (self->value);
}


GType parse_node_get_type (void) {
	static volatile gsize parse_node_type_id__volatile = 0;
	if (g_once_init_enter (&parse_node_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { value_parse_node_init, value_parse_node_free_value, value_parse_node_copy_value, value_parse_node_peek_pointer, "p", value_parse_node_collect_value, "p", value_parse_node_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (ParseNodeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) parse_node_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ParseNode), 0, (GInstanceInitFunc) parse_node_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType parse_node_type_id;
		parse_node_type_id = g_type_register_fundamental (g_type_fundamental_next (), "ParseNode", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&parse_node_type_id__volatile, parse_node_type_id);
	}
	return parse_node_type_id__volatile;
}


gpointer parse_node_ref (gpointer instance) {
	ParseNode* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void parse_node_unref (gpointer instance) {
	ParseNode* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		PARSE_NODE_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


RNode* rnode_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	RNode* self = NULL;
	Parser* _tmp0_;
	LexerToken* _tmp1_;
	guint _tmp2_;
	Associativity _tmp3_;
	g_return_val_if_fail (parser != NULL, NULL);
	_tmp0_ = parser;
	_tmp1_ = token;
	_tmp2_ = precedence;
	_tmp3_ = associativity;
	self = (RNode*) parse_node_construct (object_type, _tmp0_, _tmp1_, _tmp2_, _tmp3_, NULL);
	return self;
}


static Number* rnode_real_solve (ParseNode* base) {
	RNode * self;
	Number* result = NULL;
	ParseNode* _tmp0_;
	Number* _tmp1_ = NULL;
	Number* r;
	Number* _tmp2_;
	Number* _tmp3_;
	Number* _tmp4_ = NULL;
	self = (RNode*) base;
	_tmp0_ = ((ParseNode*) self)->right;
	_tmp1_ = parse_node_solve (_tmp0_);
	r = _tmp1_;
	_tmp2_ = r;
	if (_tmp2_ == NULL) {
		result = NULL;
		_number_unref0 (r);
		return result;
	}
	_tmp3_ = r;
	_tmp4_ = rnode_solve_r (self, _tmp3_);
	result = _tmp4_;
	_number_unref0 (r);
	return result;
}


static Number* rnode_real_solve_r (RNode* self, Number* r) {
	g_critical ("Type `%s' does not implement abstract method `rnode_solve_r'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return NULL;
}


Number* rnode_solve_r (RNode* self, Number* r) {
	g_return_val_if_fail (self != NULL, NULL);
	return RNODE_GET_CLASS (self)->solve_r (self, r);
}


static void rnode_class_init (RNodeClass * klass) {
	rnode_parent_class = g_type_class_peek_parent (klass);
	PARSE_NODE_CLASS (klass)->solve = rnode_real_solve;
	RNODE_CLASS (klass)->solve_r = rnode_real_solve_r;
}


static void rnode_instance_init (RNode * self) {
}


GType rnode_get_type (void) {
	static volatile gsize rnode_type_id__volatile = 0;
	if (g_once_init_enter (&rnode_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (RNodeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rnode_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RNode), 0, (GInstanceInitFunc) rnode_instance_init, NULL };
		GType rnode_type_id;
		rnode_type_id = g_type_register_static (TYPE_PARSE_NODE, "RNode", &g_define_type_info, G_TYPE_FLAG_ABSTRACT);
		g_once_init_leave (&rnode_type_id__volatile, rnode_type_id);
	}
	return rnode_type_id__volatile;
}


LRNode* lr_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	LRNode* self = NULL;
	Parser* _tmp0_;
	LexerToken* _tmp1_;
	guint _tmp2_;
	Associativity _tmp3_;
	g_return_val_if_fail (parser != NULL, NULL);
	_tmp0_ = parser;
	_tmp1_ = token;
	_tmp2_ = precedence;
	_tmp3_ = associativity;
	self = (LRNode*) parse_node_construct (object_type, _tmp0_, _tmp1_, _tmp2_, _tmp3_, NULL);
	return self;
}


static Number* lr_node_real_solve (ParseNode* base) {
	LRNode * self;
	Number* result = NULL;
	ParseNode* _tmp0_;
	Number* _tmp1_ = NULL;
	Number* l;
	ParseNode* _tmp2_;
	Number* _tmp3_ = NULL;
	Number* r;
	gboolean _tmp4_ = FALSE;
	Number* _tmp5_;
	gboolean _tmp7_;
	Number* _tmp8_;
	Number* _tmp9_;
	Number* _tmp10_ = NULL;
	self = (LRNode*) base;
	_tmp0_ = ((ParseNode*) self)->left;
	_tmp1_ = parse_node_solve (_tmp0_);
	l = _tmp1_;
	_tmp2_ = ((ParseNode*) self)->right;
	_tmp3_ = parse_node_solve (_tmp2_);
	r = _tmp3_;
	_tmp5_ = l;
	if (_tmp5_ == NULL) {
		_tmp4_ = TRUE;
	} else {
		Number* _tmp6_;
		_tmp6_ = r;
		_tmp4_ = _tmp6_ == NULL;
	}
	_tmp7_ = _tmp4_;
	if (_tmp7_) {
		result = NULL;
		_number_unref0 (r);
		_number_unref0 (l);
		return result;
	}
	_tmp8_ = l;
	_tmp9_ = r;
	_tmp10_ = lr_node_solve_lr (self, _tmp8_, _tmp9_);
	result = _tmp10_;
	_number_unref0 (r);
	_number_unref0 (l);
	return result;
}


static Number* lr_node_real_solve_lr (LRNode* self, Number* left, Number* r) {
	g_critical ("Type `%s' does not implement abstract method `lr_node_solve_lr'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return NULL;
}


Number* lr_node_solve_lr (LRNode* self, Number* left, Number* r) {
	g_return_val_if_fail (self != NULL, NULL);
	return LR_NODE_GET_CLASS (self)->solve_lr (self, left, r);
}


static void lr_node_class_init (LRNodeClass * klass) {
	lr_node_parent_class = g_type_class_peek_parent (klass);
	PARSE_NODE_CLASS (klass)->solve = lr_node_real_solve;
	LR_NODE_CLASS (klass)->solve_lr = lr_node_real_solve_lr;
}


static void lr_node_instance_init (LRNode * self) {
}


GType lr_node_get_type (void) {
	static volatile gsize lr_node_type_id__volatile = 0;
	if (g_once_init_enter (&lr_node_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (LRNodeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) lr_node_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (LRNode), 0, (GInstanceInitFunc) lr_node_instance_init, NULL };
		GType lr_node_type_id;
		lr_node_type_id = g_type_register_static (TYPE_PARSE_NODE, "LRNode", &g_define_type_info, G_TYPE_FLAG_ABSTRACT);
		g_once_init_leave (&lr_node_type_id__volatile, lr_node_type_id);
	}
	return lr_node_type_id__volatile;
}


ConstantNode* constant_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	ConstantNode* self = NULL;
	Parser* _tmp0_;
	LexerToken* _tmp1_;
	guint _tmp2_;
	Associativity _tmp3_;
	g_return_val_if_fail (parser != NULL, NULL);
	_tmp0_ = parser;
	_tmp1_ = token;
	_tmp2_ = precedence;
	_tmp3_ = associativity;
	self = (ConstantNode*) parse_node_construct (object_type, _tmp0_, _tmp1_, _tmp2_, _tmp3_, NULL);
	return self;
}


ConstantNode* constant_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	return constant_node_construct (TYPE_CONSTANT_NODE, parser, token, precedence, associativity);
}


static Number* constant_node_real_solve (ParseNode* base) {
	ConstantNode * self;
	Number* result = NULL;
	LexerToken* _tmp0_;
	const gchar* _tmp1_;
	Parser* _tmp2_;
	gint _tmp3_;
	Number* _tmp4_ = NULL;
	self = (ConstantNode*) base;
	_tmp0_ = ((ParseNode*) self)->token;
	_tmp1_ = _tmp0_->text;
	_tmp2_ = ((ParseNode*) self)->parser;
	_tmp3_ = _tmp2_->number_base;
	_tmp4_ = mp_set_from_string (_tmp1_, _tmp3_);
	result = _tmp4_;
	return result;
}


static void constant_node_class_init (ConstantNodeClass * klass) {
	constant_node_parent_class = g_type_class_peek_parent (klass);
	PARSE_NODE_CLASS (klass)->solve = constant_node_real_solve;
}


static void constant_node_instance_init (ConstantNode * self) {
}


GType constant_node_get_type (void) {
	static volatile gsize constant_node_type_id__volatile = 0;
	if (g_once_init_enter (&constant_node_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ConstantNodeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) constant_node_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ConstantNode), 0, (GInstanceInitFunc) constant_node_instance_init, NULL };
		GType constant_node_type_id;
		constant_node_type_id = g_type_register_static (TYPE_PARSE_NODE, "ConstantNode", &g_define_type_info, 0);
		g_once_init_leave (&constant_node_type_id__volatile, constant_node_type_id);
	}
	return constant_node_type_id__volatile;
}


AssignNode* assign_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	AssignNode* self = NULL;
	Parser* _tmp0_;
	LexerToken* _tmp1_;
	guint _tmp2_;
	Associativity _tmp3_;
	g_return_val_if_fail (parser != NULL, NULL);
	_tmp0_ = parser;
	_tmp1_ = token;
	_tmp2_ = precedence;
	_tmp3_ = associativity;
	self = (AssignNode*) rnode_construct (object_type, _tmp0_, _tmp1_, _tmp2_, _tmp3_);
	return self;
}


AssignNode* assign_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	return assign_node_construct (TYPE_ASSIGN_NODE, parser, token, precedence, associativity);
}


static gpointer _number_ref0 (gpointer self) {
	return self ? number_ref (self) : NULL;
}


static Number* assign_node_real_solve_r (RNode* base, Number* r) {
	AssignNode * self;
	Number* result = NULL;
	Parser* _tmp0_;
	ParseNode* _tmp1_;
	LexerToken* _tmp2_;
	const gchar* _tmp3_;
	Number* _tmp4_;
	Number* _tmp5_;
	Number* _tmp6_;
	self = (AssignNode*) base;
	g_return_val_if_fail (r != NULL, NULL);
	_tmp0_ = ((ParseNode*) self)->parser;
	_tmp1_ = ((ParseNode*) self)->left;
	_tmp2_ = _tmp1_->token;
	_tmp3_ = _tmp2_->text;
	_tmp4_ = r;
	parser_set_variable (_tmp0_, _tmp3_, _tmp4_);
	_tmp5_ = r;
	_tmp6_ = _number_ref0 (_tmp5_);
	result = _tmp6_;
	return result;
}


static void assign_node_class_init (AssignNodeClass * klass) {
	assign_node_parent_class = g_type_class_peek_parent (klass);
	RNODE_CLASS (klass)->solve_r = assign_node_real_solve_r;
}


static void assign_node_instance_init (AssignNode * self) {
}


GType assign_node_get_type (void) {
	static volatile gsize assign_node_type_id__volatile = 0;
	if (g_once_init_enter (&assign_node_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (AssignNodeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) assign_node_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (AssignNode), 0, (GInstanceInitFunc) assign_node_instance_init, NULL };
		GType assign_node_type_id;
		assign_node_type_id = g_type_register_static (TYPE_RNODE, "AssignNode", &g_define_type_info, 0);
		g_once_init_leave (&assign_node_type_id__volatile, assign_node_type_id);
	}
	return assign_node_type_id__volatile;
}


NameNode* name_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity, const gchar* text) {
	NameNode* self = NULL;
	Parser* _tmp0_;
	LexerToken* _tmp1_;
	guint _tmp2_;
	Associativity _tmp3_;
	const gchar* _tmp4_;
	g_return_val_if_fail (parser != NULL, NULL);
	_tmp0_ = parser;
	_tmp1_ = token;
	_tmp2_ = precedence;
	_tmp3_ = associativity;
	_tmp4_ = text;
	self = (NameNode*) parse_node_construct (object_type, _tmp0_, _tmp1_, _tmp2_, _tmp3_, _tmp4_);
	return self;
}


NameNode* name_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity, const gchar* text) {
	return name_node_construct (TYPE_NAME_NODE, parser, token, precedence, associativity, text);
}


static void name_node_class_init (NameNodeClass * klass) {
	name_node_parent_class = g_type_class_peek_parent (klass);
}


static void name_node_instance_init (NameNode * self) {
}


GType name_node_get_type (void) {
	static volatile gsize name_node_type_id__volatile = 0;
	if (g_once_init_enter (&name_node_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (NameNodeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) name_node_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (NameNode), 0, (GInstanceInitFunc) name_node_instance_init, NULL };
		GType name_node_type_id;
		name_node_type_id = g_type_register_static (TYPE_PARSE_NODE, "NameNode", &g_define_type_info, 0);
		g_once_init_leave (&name_node_type_id__volatile, name_node_type_id);
	}
	return name_node_type_id__volatile;
}


VariableNode* variable_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	VariableNode* self = NULL;
	Parser* _tmp0_;
	LexerToken* _tmp1_;
	guint _tmp2_;
	Associativity _tmp3_;
	g_return_val_if_fail (parser != NULL, NULL);
	_tmp0_ = parser;
	_tmp1_ = token;
	_tmp2_ = precedence;
	_tmp3_ = associativity;
	self = (VariableNode*) parse_node_construct (object_type, _tmp0_, _tmp1_, _tmp2_, _tmp3_, NULL);
	return self;
}


VariableNode* variable_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	return variable_node_construct (TYPE_VARIABLE_NODE, parser, token, precedence, associativity);
}


static gboolean string_get_next_char (const gchar* self, gint* index, gunichar* c) {
	gunichar _vala_c = 0U;
	gboolean result = FALSE;
	gint _tmp0_;
	gunichar _tmp1_ = 0U;
	gunichar _tmp2_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = *index;
	_tmp1_ = g_utf8_get_char (((gchar*) self) + _tmp0_);
	_vala_c = _tmp1_;
	_tmp2_ = _vala_c;
	if (_tmp2_ != ((gunichar) 0)) {
		gint _tmp3_;
		gchar* _tmp4_ = NULL;
		_tmp3_ = *index;
		_tmp4_ = g_utf8_next_char (((gchar*) self) + _tmp3_);
		*index = (gint) (_tmp4_ - ((gchar*) self));
		result = TRUE;
		if (c) {
			*c = _vala_c;
		}
		return result;
	} else {
		result = FALSE;
		if (c) {
			*c = _vala_c;
		}
		return result;
	}
	if (c) {
		*c = _vala_c;
	}
}


static gchar* g_unichar_to_string (gunichar self) {
	gchar* result = NULL;
	gchar* _tmp0_ = NULL;
	gchar* str;
	const gchar* _tmp1_;
	_tmp0_ = g_new0 (gchar, 7);
	str = (gchar*) _tmp0_;
	_tmp1_ = str;
	g_unichar_to_utf8 (self, _tmp1_);
	result = str;
	return result;
}


static Number* variable_node_real_solve (ParseNode* base) {
	VariableNode * self;
	Number* result = NULL;
	Parser* _tmp0_;
	LexerToken* _tmp1_;
	const gchar* _tmp2_;
	Number* _tmp3_ = NULL;
	Number* ans;
	Number* _tmp4_;
	Number* _tmp5_;
	Number* value;
	gint index;
	gunichar c = 0U;
	self = (VariableNode*) base;
	_tmp0_ = ((ParseNode*) self)->parser;
	_tmp1_ = ((ParseNode*) self)->token;
	_tmp2_ = _tmp1_->text;
	_tmp3_ = parser_get_variable (_tmp0_, _tmp2_);
	ans = _tmp3_;
	_tmp4_ = ans;
	if (_tmp4_ != NULL) {
		result = ans;
		return result;
	}
	_tmp5_ = number_new_integer ((gint64) 1);
	value = _tmp5_;
	index = 0;
	while (TRUE) {
		LexerToken* _tmp6_;
		const gchar* _tmp7_;
		gunichar _tmp8_ = 0U;
		gboolean _tmp9_ = FALSE;
		Parser* _tmp10_;
		gunichar _tmp11_;
		gchar* _tmp12_ = NULL;
		gchar* _tmp13_;
		Number* _tmp14_ = NULL;
		Number* _tmp15_;
		Number* t;
		Number* _tmp16_;
		Number* _tmp24_;
		Number* _tmp25_;
		Number* _tmp26_ = NULL;
		_tmp6_ = ((ParseNode*) self)->token;
		_tmp7_ = _tmp6_->text;
		_tmp9_ = string_get_next_char (_tmp7_, &index, &_tmp8_);
		c = _tmp8_;
		if (!_tmp9_) {
			break;
		}
		_tmp10_ = ((ParseNode*) self)->parser;
		_tmp11_ = c;
		_tmp12_ = g_unichar_to_string (_tmp11_);
		_tmp13_ = _tmp12_;
		_tmp14_ = parser_get_variable (_tmp10_, _tmp13_);
		_tmp15_ = _tmp14_;
		_g_free0 (_tmp13_);
		t = _tmp15_;
		_tmp16_ = t;
		if (_tmp16_ == NULL) {
			Parser* _tmp17_;
			LexerToken* _tmp18_;
			const gchar* _tmp19_;
			LexerToken* _tmp20_;
			guint _tmp21_;
			LexerToken* _tmp22_;
			guint _tmp23_;
			_tmp17_ = ((ParseNode*) self)->parser;
			_tmp18_ = ((ParseNode*) self)->token;
			_tmp19_ = _tmp18_->text;
			_tmp20_ = ((ParseNode*) self)->token;
			_tmp21_ = _tmp20_->start_index;
			_tmp22_ = ((ParseNode*) self)->token;
			_tmp23_ = _tmp22_->end_index;
			parser_set_error (_tmp17_, ERROR_CODE_UNKNOWN_VARIABLE, _tmp19_, _tmp21_, _tmp23_);
			result = NULL;
			_number_unref0 (t);
			_number_unref0 (value);
			_number_unref0 (ans);
			return result;
		}
		_tmp24_ = value;
		_tmp25_ = t;
		_tmp26_ = number_multiply (_tmp24_, _tmp25_);
		_number_unref0 (value);
		value = _tmp26_;
		_number_unref0 (t);
	}
	result = value;
	_number_unref0 (ans);
	return result;
}


static void variable_node_class_init (VariableNodeClass * klass) {
	variable_node_parent_class = g_type_class_peek_parent (klass);
	PARSE_NODE_CLASS (klass)->solve = variable_node_real_solve;
}


static void variable_node_instance_init (VariableNode * self) {
}


GType variable_node_get_type (void) {
	static volatile gsize variable_node_type_id__volatile = 0;
	if (g_once_init_enter (&variable_node_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (VariableNodeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) variable_node_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (VariableNode), 0, (GInstanceInitFunc) variable_node_instance_init, NULL };
		GType variable_node_type_id;
		variable_node_type_id = g_type_register_static (TYPE_PARSE_NODE, "VariableNode", &g_define_type_info, 0);
		g_once_init_leave (&variable_node_type_id__volatile, variable_node_type_id);
	}
	return variable_node_type_id__volatile;
}


VariableWithPowerNode* variable_with_power_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity, const gchar* text) {
	VariableWithPowerNode* self = NULL;
	Parser* _tmp0_;
	LexerToken* _tmp1_;
	guint _tmp2_;
	Associativity _tmp3_;
	const gchar* _tmp4_;
	g_return_val_if_fail (parser != NULL, NULL);
	g_return_val_if_fail (text != NULL, NULL);
	_tmp0_ = parser;
	_tmp1_ = token;
	_tmp2_ = precedence;
	_tmp3_ = associativity;
	_tmp4_ = text;
	self = (VariableWithPowerNode*) parse_node_construct (object_type, _tmp0_, _tmp1_, _tmp2_, _tmp3_, _tmp4_);
	return self;
}


VariableWithPowerNode* variable_with_power_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity, const gchar* text) {
	return variable_with_power_node_construct (TYPE_VARIABLE_WITH_POWER_NODE, parser, token, precedence, associativity, text);
}


static Number* variable_with_power_node_real_solve (ParseNode* base) {
	VariableWithPowerNode * self;
	Number* result = NULL;
	const gchar* _tmp0_;
	gint _tmp1_ = 0;
	gint pow;
	Parser* _tmp2_;
	LexerToken* _tmp3_;
	const gchar* _tmp4_;
	Number* _tmp5_ = NULL;
	Number* ans;
	Number* _tmp6_;
	Number* _tmp10_;
	Number* value;
	gint index;
	gunichar c = 0U;
	self = (VariableWithPowerNode*) base;
	_tmp0_ = ((ParseNode*) self)->value;
	_tmp1_ = super_atoi (_tmp0_);
	pow = _tmp1_;
	_g_free0 (((ParseNode*) self)->value);
	((ParseNode*) self)->value = NULL;
	_tmp2_ = ((ParseNode*) self)->parser;
	_tmp3_ = ((ParseNode*) self)->token;
	_tmp4_ = _tmp3_->text;
	_tmp5_ = parser_get_variable (_tmp2_, _tmp4_);
	ans = _tmp5_;
	_tmp6_ = ans;
	if (_tmp6_ != NULL) {
		Number* _tmp7_;
		gint _tmp8_;
		Number* _tmp9_ = NULL;
		_tmp7_ = ans;
		_tmp8_ = pow;
		_tmp9_ = number_xpowy_integer (_tmp7_, (gint64) _tmp8_);
		result = _tmp9_;
		_number_unref0 (ans);
		return result;
	}
	_tmp10_ = number_new_integer ((gint64) 1);
	value = _tmp10_;
	index = 0;
	while (TRUE) {
		LexerToken* _tmp11_;
		const gchar* _tmp12_;
		gunichar _tmp13_ = 0U;
		gboolean _tmp14_ = FALSE;
		Parser* _tmp15_;
		gunichar _tmp16_;
		gchar* _tmp17_ = NULL;
		gchar* _tmp18_;
		Number* _tmp19_ = NULL;
		Number* _tmp20_;
		Number* t;
		Number* _tmp21_;
		gint _tmp29_;
		gint i;
		gunichar next = 0U;
		LexerToken* _tmp30_;
		const gchar* _tmp31_;
		gunichar _tmp32_ = 0U;
		gboolean _tmp33_ = FALSE;
		Number* _tmp37_;
		Number* _tmp38_;
		Number* _tmp39_ = NULL;
		_tmp11_ = ((ParseNode*) self)->token;
		_tmp12_ = _tmp11_->text;
		_tmp14_ = string_get_next_char (_tmp12_, &index, &_tmp13_);
		c = _tmp13_;
		if (!_tmp14_) {
			break;
		}
		_tmp15_ = ((ParseNode*) self)->parser;
		_tmp16_ = c;
		_tmp17_ = g_unichar_to_string (_tmp16_);
		_tmp18_ = _tmp17_;
		_tmp19_ = parser_get_variable (_tmp15_, _tmp18_);
		_tmp20_ = _tmp19_;
		_g_free0 (_tmp18_);
		t = _tmp20_;
		_tmp21_ = t;
		if (_tmp21_ == NULL) {
			Parser* _tmp22_;
			LexerToken* _tmp23_;
			const gchar* _tmp24_;
			LexerToken* _tmp25_;
			guint _tmp26_;
			LexerToken* _tmp27_;
			guint _tmp28_;
			_tmp22_ = ((ParseNode*) self)->parser;
			_tmp23_ = ((ParseNode*) self)->token;
			_tmp24_ = _tmp23_->text;
			_tmp25_ = ((ParseNode*) self)->token;
			_tmp26_ = _tmp25_->start_index;
			_tmp27_ = ((ParseNode*) self)->token;
			_tmp28_ = _tmp27_->end_index;
			parser_set_error (_tmp22_, ERROR_CODE_UNKNOWN_VARIABLE, _tmp24_, _tmp26_, _tmp28_);
			result = NULL;
			_number_unref0 (t);
			_number_unref0 (value);
			_number_unref0 (ans);
			return result;
		}
		_tmp29_ = index;
		i = _tmp29_;
		_tmp30_ = ((ParseNode*) self)->token;
		_tmp31_ = _tmp30_->text;
		_tmp33_ = string_get_next_char (_tmp31_, &i, &_tmp32_);
		next = _tmp32_;
		if (!_tmp33_) {
			Number* _tmp34_;
			gint _tmp35_;
			Number* _tmp36_ = NULL;
			_tmp34_ = t;
			_tmp35_ = pow;
			_tmp36_ = number_xpowy_integer (_tmp34_, (gint64) _tmp35_);
			_number_unref0 (t);
			t = _tmp36_;
		}
		_tmp37_ = value;
		_tmp38_ = t;
		_tmp39_ = number_multiply (_tmp37_, _tmp38_);
		_number_unref0 (value);
		value = _tmp39_;
		_number_unref0 (t);
	}
	result = value;
	_number_unref0 (ans);
	return result;
}


static void variable_with_power_node_class_init (VariableWithPowerNodeClass * klass) {
	variable_with_power_node_parent_class = g_type_class_peek_parent (klass);
	PARSE_NODE_CLASS (klass)->solve = variable_with_power_node_real_solve;
}


static void variable_with_power_node_instance_init (VariableWithPowerNode * self) {
}


GType variable_with_power_node_get_type (void) {
	static volatile gsize variable_with_power_node_type_id__volatile = 0;
	if (g_once_init_enter (&variable_with_power_node_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (VariableWithPowerNodeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) variable_with_power_node_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (VariableWithPowerNode), 0, (GInstanceInitFunc) variable_with_power_node_instance_init, NULL };
		GType variable_with_power_node_type_id;
		variable_with_power_node_type_id = g_type_register_static (TYPE_PARSE_NODE, "VariableWithPowerNode", &g_define_type_info, 0);
		g_once_init_leave (&variable_with_power_node_type_id__volatile, variable_with_power_node_type_id);
	}
	return variable_with_power_node_type_id__volatile;
}


FunctionNode* function_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	FunctionNode* self = NULL;
	Parser* _tmp0_;
	LexerToken* _tmp1_;
	guint _tmp2_;
	Associativity _tmp3_;
	g_return_val_if_fail (parser != NULL, NULL);
	_tmp0_ = parser;
	_tmp1_ = token;
	_tmp2_ = precedence;
	_tmp3_ = associativity;
	self = (FunctionNode*) rnode_construct (object_type, _tmp0_, _tmp1_, _tmp2_, _tmp3_);
	return self;
}


FunctionNode* function_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	return function_node_construct (TYPE_FUNCTION_NODE, parser, token, precedence, associativity);
}


static Number* function_node_real_solve_r (RNode* base, Number* r) {
	FunctionNode * self;
	Number* result = NULL;
	Parser* _tmp0_;
	LexerToken* _tmp1_;
	const gchar* _tmp2_;
	Number* _tmp3_;
	Number* _tmp4_ = NULL;
	Number* ans;
	Number* _tmp5_;
	self = (FunctionNode*) base;
	g_return_val_if_fail (r != NULL, NULL);
	_tmp0_ = ((ParseNode*) self)->parser;
	_tmp1_ = ((ParseNode*) self)->token;
	_tmp2_ = _tmp1_->text;
	_tmp3_ = r;
	_tmp4_ = parser_get_function (_tmp0_, _tmp2_, _tmp3_);
	ans = _tmp4_;
	_tmp5_ = ans;
	if (_tmp5_ == NULL) {
		Parser* _tmp6_;
		LexerToken* _tmp7_;
		const gchar* _tmp8_;
		LexerToken* _tmp9_;
		guint _tmp10_;
		LexerToken* _tmp11_;
		guint _tmp12_;
		_tmp6_ = ((ParseNode*) self)->parser;
		_tmp7_ = ((ParseNode*) self)->token;
		_tmp8_ = _tmp7_->text;
		_tmp9_ = ((ParseNode*) self)->token;
		_tmp10_ = _tmp9_->start_index;
		_tmp11_ = ((ParseNode*) self)->token;
		_tmp12_ = _tmp11_->end_index;
		parser_set_error (_tmp6_, ERROR_CODE_UNKNOWN_FUNCTION, _tmp8_, _tmp10_, _tmp12_);
	}
	result = ans;
	return result;
}


static void function_node_class_init (FunctionNodeClass * klass) {
	function_node_parent_class = g_type_class_peek_parent (klass);
	RNODE_CLASS (klass)->solve_r = function_node_real_solve_r;
}


static void function_node_instance_init (FunctionNode * self) {
}


GType function_node_get_type (void) {
	static volatile gsize function_node_type_id__volatile = 0;
	if (g_once_init_enter (&function_node_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FunctionNodeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) function_node_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FunctionNode), 0, (GInstanceInitFunc) function_node_instance_init, NULL };
		GType function_node_type_id;
		function_node_type_id = g_type_register_static (TYPE_RNODE, "FunctionNode", &g_define_type_info, 0);
		g_once_init_leave (&function_node_type_id__volatile, function_node_type_id);
	}
	return function_node_type_id__volatile;
}


FunctionWithPowerNode* function_with_power_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity, const gchar* text) {
	FunctionWithPowerNode* self = NULL;
	Parser* _tmp0_;
	LexerToken* _tmp1_;
	guint _tmp2_;
	Associativity _tmp3_;
	const gchar* _tmp4_;
	g_return_val_if_fail (parser != NULL, NULL);
	g_return_val_if_fail (text != NULL, NULL);
	_tmp0_ = parser;
	_tmp1_ = token;
	_tmp2_ = precedence;
	_tmp3_ = associativity;
	_tmp4_ = text;
	self = (FunctionWithPowerNode*) parse_node_construct (object_type, _tmp0_, _tmp1_, _tmp2_, _tmp3_, _tmp4_);
	return self;
}


FunctionWithPowerNode* function_with_power_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity, const gchar* text) {
	return function_with_power_node_construct (TYPE_FUNCTION_WITH_POWER_NODE, parser, token, precedence, associativity, text);
}


static Number* function_with_power_node_real_solve (ParseNode* base) {
	FunctionWithPowerNode * self;
	Number* result = NULL;
	ParseNode* _tmp0_;
	Number* _tmp1_ = NULL;
	Number* val;
	Number* _tmp2_;
	Parser* _tmp3_;
	LexerToken* _tmp4_;
	const gchar* _tmp5_;
	Number* _tmp6_;
	Number* _tmp7_ = NULL;
	Number* tmp;
	Number* _tmp8_;
	const gchar* _tmp16_;
	gint _tmp17_ = 0;
	gint pow;
	Number* _tmp18_;
	gint _tmp19_;
	Number* _tmp20_ = NULL;
	self = (FunctionWithPowerNode*) base;
	_tmp0_ = ((ParseNode*) self)->right;
	_tmp1_ = parse_node_solve (_tmp0_);
	val = _tmp1_;
	_tmp2_ = val;
	if (_tmp2_ == NULL) {
		_g_free0 (((ParseNode*) self)->value);
		((ParseNode*) self)->value = NULL;
		result = NULL;
		_number_unref0 (val);
		return result;
	}
	_tmp3_ = ((ParseNode*) self)->parser;
	_tmp4_ = ((ParseNode*) self)->token;
	_tmp5_ = _tmp4_->text;
	_tmp6_ = val;
	_tmp7_ = parser_get_function (_tmp3_, _tmp5_, _tmp6_);
	tmp = _tmp7_;
	_tmp8_ = tmp;
	if (_tmp8_ == NULL) {
		Parser* _tmp9_;
		LexerToken* _tmp10_;
		const gchar* _tmp11_;
		LexerToken* _tmp12_;
		guint _tmp13_;
		LexerToken* _tmp14_;
		guint _tmp15_;
		_g_free0 (((ParseNode*) self)->value);
		((ParseNode*) self)->value = NULL;
		_tmp9_ = ((ParseNode*) self)->parser;
		_tmp10_ = ((ParseNode*) self)->token;
		_tmp11_ = _tmp10_->text;
		_tmp12_ = ((ParseNode*) self)->token;
		_tmp13_ = _tmp12_->start_index;
		_tmp14_ = ((ParseNode*) self)->token;
		_tmp15_ = _tmp14_->end_index;
		parser_set_error (_tmp9_, ERROR_CODE_UNKNOWN_FUNCTION, _tmp11_, _tmp13_, _tmp15_);
		result = NULL;
		_number_unref0 (tmp);
		_number_unref0 (val);
		return result;
	}
	_tmp16_ = ((ParseNode*) self)->value;
	_tmp17_ = super_atoi (_tmp16_);
	pow = _tmp17_;
	_g_free0 (((ParseNode*) self)->value);
	((ParseNode*) self)->value = NULL;
	_tmp18_ = tmp;
	_tmp19_ = pow;
	_tmp20_ = number_xpowy_integer (_tmp18_, (gint64) _tmp19_);
	result = _tmp20_;
	_number_unref0 (tmp);
	_number_unref0 (val);
	return result;
}


static void function_with_power_node_class_init (FunctionWithPowerNodeClass * klass) {
	function_with_power_node_parent_class = g_type_class_peek_parent (klass);
	PARSE_NODE_CLASS (klass)->solve = function_with_power_node_real_solve;
}


static void function_with_power_node_instance_init (FunctionWithPowerNode * self) {
}


GType function_with_power_node_get_type (void) {
	static volatile gsize function_with_power_node_type_id__volatile = 0;
	if (g_once_init_enter (&function_with_power_node_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FunctionWithPowerNodeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) function_with_power_node_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FunctionWithPowerNode), 0, (GInstanceInitFunc) function_with_power_node_instance_init, NULL };
		GType function_with_power_node_type_id;
		function_with_power_node_type_id = g_type_register_static (TYPE_PARSE_NODE, "FunctionWithPowerNode", &g_define_type_info, 0);
		g_once_init_leave (&function_with_power_node_type_id__volatile, function_with_power_node_type_id);
	}
	return function_with_power_node_type_id__volatile;
}


FunctionWithNegativePowerNode* function_with_negative_power_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity, const gchar* text) {
	FunctionWithNegativePowerNode* self = NULL;
	Parser* _tmp0_;
	LexerToken* _tmp1_;
	guint _tmp2_;
	Associativity _tmp3_;
	const gchar* _tmp4_;
	g_return_val_if_fail (parser != NULL, NULL);
	g_return_val_if_fail (text != NULL, NULL);
	_tmp0_ = parser;
	_tmp1_ = token;
	_tmp2_ = precedence;
	_tmp3_ = associativity;
	_tmp4_ = text;
	self = (FunctionWithNegativePowerNode*) parse_node_construct (object_type, _tmp0_, _tmp1_, _tmp2_, _tmp3_, _tmp4_);
	return self;
}


FunctionWithNegativePowerNode* function_with_negative_power_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity, const gchar* text) {
	return function_with_negative_power_node_construct (TYPE_FUNCTION_WITH_NEGATIVE_POWER_NODE, parser, token, precedence, associativity, text);
}


static Number* function_with_negative_power_node_real_solve (ParseNode* base) {
	FunctionWithNegativePowerNode * self;
	Number* result = NULL;
	ParseNode* _tmp0_;
	Number* _tmp1_ = NULL;
	Number* val;
	Number* _tmp2_;
	LexerToken* _tmp3_;
	const gchar* _tmp4_;
	gchar* _tmp5_;
	gchar* inv_name;
	Parser* _tmp6_;
	const gchar* _tmp7_;
	Number* _tmp8_;
	Number* _tmp9_ = NULL;
	Number* tmp;
	Number* _tmp10_;
	const gchar* _tmp18_;
	gint _tmp19_ = 0;
	gint pow;
	Number* _tmp20_;
	gint _tmp21_;
	Number* _tmp22_ = NULL;
	self = (FunctionWithNegativePowerNode*) base;
	_tmp0_ = ((ParseNode*) self)->right;
	_tmp1_ = parse_node_solve (_tmp0_);
	val = _tmp1_;
	_tmp2_ = val;
	if (_tmp2_ == NULL) {
		_g_free0 (((ParseNode*) self)->value);
		((ParseNode*) self)->value = NULL;
		result = NULL;
		_number_unref0 (val);
		return result;
	}
	_tmp3_ = ((ParseNode*) self)->token;
	_tmp4_ = _tmp3_->text;
	_tmp5_ = g_strconcat (_tmp4_, "", NULL);
	inv_name = _tmp5_;
	_tmp6_ = ((ParseNode*) self)->parser;
	_tmp7_ = inv_name;
	_tmp8_ = val;
	_tmp9_ = parser_get_function (_tmp6_, _tmp7_, _tmp8_);
	tmp = _tmp9_;
	_tmp10_ = tmp;
	if (_tmp10_ == NULL) {
		Parser* _tmp11_;
		LexerToken* _tmp12_;
		const gchar* _tmp13_;
		LexerToken* _tmp14_;
		guint _tmp15_;
		LexerToken* _tmp16_;
		guint _tmp17_;
		_g_free0 (((ParseNode*) self)->value);
		((ParseNode*) self)->value = NULL;
		_tmp11_ = ((ParseNode*) self)->parser;
		_tmp12_ = ((ParseNode*) self)->token;
		_tmp13_ = _tmp12_->text;
		_tmp14_ = ((ParseNode*) self)->token;
		_tmp15_ = _tmp14_->start_index;
		_tmp16_ = ((ParseNode*) self)->token;
		_tmp17_ = _tmp16_->end_index;
		parser_set_error (_tmp11_, ERROR_CODE_UNKNOWN_FUNCTION, _tmp13_, _tmp15_, _tmp17_);
		result = NULL;
		_number_unref0 (tmp);
		_g_free0 (inv_name);
		_number_unref0 (val);
		return result;
	}
	_tmp18_ = ((ParseNode*) self)->value;
	_tmp19_ = super_atoi (_tmp18_);
	pow = _tmp19_;
	_g_free0 (((ParseNode*) self)->value);
	((ParseNode*) self)->value = NULL;
	_tmp20_ = tmp;
	_tmp21_ = pow;
	_tmp22_ = number_xpowy_integer (_tmp20_, (gint64) (-_tmp21_));
	result = _tmp22_;
	_number_unref0 (tmp);
	_g_free0 (inv_name);
	_number_unref0 (val);
	return result;
}


static void function_with_negative_power_node_class_init (FunctionWithNegativePowerNodeClass * klass) {
	function_with_negative_power_node_parent_class = g_type_class_peek_parent (klass);
	PARSE_NODE_CLASS (klass)->solve = function_with_negative_power_node_real_solve;
}


static void function_with_negative_power_node_instance_init (FunctionWithNegativePowerNode * self) {
}


GType function_with_negative_power_node_get_type (void) {
	static volatile gsize function_with_negative_power_node_type_id__volatile = 0;
	if (g_once_init_enter (&function_with_negative_power_node_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FunctionWithNegativePowerNodeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) function_with_negative_power_node_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FunctionWithNegativePowerNode), 0, (GInstanceInitFunc) function_with_negative_power_node_instance_init, NULL };
		GType function_with_negative_power_node_type_id;
		function_with_negative_power_node_type_id = g_type_register_static (TYPE_PARSE_NODE, "FunctionWithNegativePowerNode", &g_define_type_info, 0);
		g_once_init_leave (&function_with_negative_power_node_type_id__volatile, function_with_negative_power_node_type_id);
	}
	return function_with_negative_power_node_type_id__volatile;
}


UnaryMinusNode* unary_minus_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	UnaryMinusNode* self = NULL;
	Parser* _tmp0_;
	LexerToken* _tmp1_;
	guint _tmp2_;
	Associativity _tmp3_;
	g_return_val_if_fail (parser != NULL, NULL);
	_tmp0_ = parser;
	_tmp1_ = token;
	_tmp2_ = precedence;
	_tmp3_ = associativity;
	self = (UnaryMinusNode*) rnode_construct (object_type, _tmp0_, _tmp1_, _tmp2_, _tmp3_);
	return self;
}


UnaryMinusNode* unary_minus_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	return unary_minus_node_construct (TYPE_UNARY_MINUS_NODE, parser, token, precedence, associativity);
}


static Number* unary_minus_node_real_solve_r (RNode* base, Number* r) {
	UnaryMinusNode * self;
	Number* result = NULL;
	Number* _tmp0_;
	Number* _tmp1_ = NULL;
	self = (UnaryMinusNode*) base;
	g_return_val_if_fail (r != NULL, NULL);
	_tmp0_ = r;
	_tmp1_ = number_invert_sign (_tmp0_);
	result = _tmp1_;
	return result;
}


static void unary_minus_node_class_init (UnaryMinusNodeClass * klass) {
	unary_minus_node_parent_class = g_type_class_peek_parent (klass);
	RNODE_CLASS (klass)->solve_r = unary_minus_node_real_solve_r;
}


static void unary_minus_node_instance_init (UnaryMinusNode * self) {
}


GType unary_minus_node_get_type (void) {
	static volatile gsize unary_minus_node_type_id__volatile = 0;
	if (g_once_init_enter (&unary_minus_node_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (UnaryMinusNodeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) unary_minus_node_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (UnaryMinusNode), 0, (GInstanceInitFunc) unary_minus_node_instance_init, NULL };
		GType unary_minus_node_type_id;
		unary_minus_node_type_id = g_type_register_static (TYPE_RNODE, "UnaryMinusNode", &g_define_type_info, 0);
		g_once_init_leave (&unary_minus_node_type_id__volatile, unary_minus_node_type_id);
	}
	return unary_minus_node_type_id__volatile;
}


AbsoluteValueNode* absolute_value_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	AbsoluteValueNode* self = NULL;
	Parser* _tmp0_;
	LexerToken* _tmp1_;
	guint _tmp2_;
	Associativity _tmp3_;
	g_return_val_if_fail (parser != NULL, NULL);
	_tmp0_ = parser;
	_tmp1_ = token;
	_tmp2_ = precedence;
	_tmp3_ = associativity;
	self = (AbsoluteValueNode*) rnode_construct (object_type, _tmp0_, _tmp1_, _tmp2_, _tmp3_);
	return self;
}


AbsoluteValueNode* absolute_value_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	return absolute_value_node_construct (TYPE_ABSOLUTE_VALUE_NODE, parser, token, precedence, associativity);
}


static Number* absolute_value_node_real_solve_r (RNode* base, Number* r) {
	AbsoluteValueNode * self;
	Number* result = NULL;
	Number* _tmp0_;
	Number* _tmp1_ = NULL;
	self = (AbsoluteValueNode*) base;
	g_return_val_if_fail (r != NULL, NULL);
	_tmp0_ = r;
	_tmp1_ = number_abs (_tmp0_);
	result = _tmp1_;
	return result;
}


static void absolute_value_node_class_init (AbsoluteValueNodeClass * klass) {
	absolute_value_node_parent_class = g_type_class_peek_parent (klass);
	RNODE_CLASS (klass)->solve_r = absolute_value_node_real_solve_r;
}


static void absolute_value_node_instance_init (AbsoluteValueNode * self) {
}


GType absolute_value_node_get_type (void) {
	static volatile gsize absolute_value_node_type_id__volatile = 0;
	if (g_once_init_enter (&absolute_value_node_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (AbsoluteValueNodeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) absolute_value_node_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (AbsoluteValueNode), 0, (GInstanceInitFunc) absolute_value_node_instance_init, NULL };
		GType absolute_value_node_type_id;
		absolute_value_node_type_id = g_type_register_static (TYPE_RNODE, "AbsoluteValueNode", &g_define_type_info, 0);
		g_once_init_leave (&absolute_value_node_type_id__volatile, absolute_value_node_type_id);
	}
	return absolute_value_node_type_id__volatile;
}


FloorNode* floor_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	FloorNode* self = NULL;
	Parser* _tmp0_;
	LexerToken* _tmp1_;
	guint _tmp2_;
	Associativity _tmp3_;
	g_return_val_if_fail (parser != NULL, NULL);
	_tmp0_ = parser;
	_tmp1_ = token;
	_tmp2_ = precedence;
	_tmp3_ = associativity;
	self = (FloorNode*) rnode_construct (object_type, _tmp0_, _tmp1_, _tmp2_, _tmp3_);
	return self;
}


FloorNode* floor_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	return floor_node_construct (TYPE_FLOOR_NODE, parser, token, precedence, associativity);
}


static Number* floor_node_real_solve_r (RNode* base, Number* r) {
	FloorNode * self;
	Number* result = NULL;
	Number* _tmp0_;
	Number* _tmp1_ = NULL;
	self = (FloorNode*) base;
	g_return_val_if_fail (r != NULL, NULL);
	_tmp0_ = r;
	_tmp1_ = number_floor (_tmp0_);
	result = _tmp1_;
	return result;
}


static void floor_node_class_init (FloorNodeClass * klass) {
	floor_node_parent_class = g_type_class_peek_parent (klass);
	RNODE_CLASS (klass)->solve_r = floor_node_real_solve_r;
}


static void floor_node_instance_init (FloorNode * self) {
}


GType floor_node_get_type (void) {
	static volatile gsize floor_node_type_id__volatile = 0;
	if (g_once_init_enter (&floor_node_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FloorNodeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) floor_node_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FloorNode), 0, (GInstanceInitFunc) floor_node_instance_init, NULL };
		GType floor_node_type_id;
		floor_node_type_id = g_type_register_static (TYPE_RNODE, "FloorNode", &g_define_type_info, 0);
		g_once_init_leave (&floor_node_type_id__volatile, floor_node_type_id);
	}
	return floor_node_type_id__volatile;
}


CeilingNode* ceiling_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	CeilingNode* self = NULL;
	Parser* _tmp0_;
	LexerToken* _tmp1_;
	guint _tmp2_;
	Associativity _tmp3_;
	g_return_val_if_fail (parser != NULL, NULL);
	_tmp0_ = parser;
	_tmp1_ = token;
	_tmp2_ = precedence;
	_tmp3_ = associativity;
	self = (CeilingNode*) rnode_construct (object_type, _tmp0_, _tmp1_, _tmp2_, _tmp3_);
	return self;
}


CeilingNode* ceiling_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	return ceiling_node_construct (TYPE_CEILING_NODE, parser, token, precedence, associativity);
}


static Number* ceiling_node_real_solve_r (RNode* base, Number* r) {
	CeilingNode * self;
	Number* result = NULL;
	Number* _tmp0_;
	Number* _tmp1_ = NULL;
	self = (CeilingNode*) base;
	g_return_val_if_fail (r != NULL, NULL);
	_tmp0_ = r;
	_tmp1_ = number_ceiling (_tmp0_);
	result = _tmp1_;
	return result;
}


static void ceiling_node_class_init (CeilingNodeClass * klass) {
	ceiling_node_parent_class = g_type_class_peek_parent (klass);
	RNODE_CLASS (klass)->solve_r = ceiling_node_real_solve_r;
}


static void ceiling_node_instance_init (CeilingNode * self) {
}


GType ceiling_node_get_type (void) {
	static volatile gsize ceiling_node_type_id__volatile = 0;
	if (g_once_init_enter (&ceiling_node_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (CeilingNodeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) ceiling_node_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (CeilingNode), 0, (GInstanceInitFunc) ceiling_node_instance_init, NULL };
		GType ceiling_node_type_id;
		ceiling_node_type_id = g_type_register_static (TYPE_RNODE, "CeilingNode", &g_define_type_info, 0);
		g_once_init_leave (&ceiling_node_type_id__volatile, ceiling_node_type_id);
	}
	return ceiling_node_type_id__volatile;
}


FractionalComponentNode* fractional_component_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	FractionalComponentNode* self = NULL;
	Parser* _tmp0_;
	LexerToken* _tmp1_;
	guint _tmp2_;
	Associativity _tmp3_;
	g_return_val_if_fail (parser != NULL, NULL);
	_tmp0_ = parser;
	_tmp1_ = token;
	_tmp2_ = precedence;
	_tmp3_ = associativity;
	self = (FractionalComponentNode*) rnode_construct (object_type, _tmp0_, _tmp1_, _tmp2_, _tmp3_);
	return self;
}


FractionalComponentNode* fractional_component_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	return fractional_component_node_construct (TYPE_FRACTIONAL_COMPONENT_NODE, parser, token, precedence, associativity);
}


static Number* fractional_component_node_real_solve_r (RNode* base, Number* r) {
	FractionalComponentNode * self;
	Number* result = NULL;
	Number* _tmp0_;
	Number* _tmp1_ = NULL;
	self = (FractionalComponentNode*) base;
	g_return_val_if_fail (r != NULL, NULL);
	_tmp0_ = r;
	_tmp1_ = number_fractional_part (_tmp0_);
	result = _tmp1_;
	return result;
}


static void fractional_component_node_class_init (FractionalComponentNodeClass * klass) {
	fractional_component_node_parent_class = g_type_class_peek_parent (klass);
	RNODE_CLASS (klass)->solve_r = fractional_component_node_real_solve_r;
}


static void fractional_component_node_instance_init (FractionalComponentNode * self) {
}


GType fractional_component_node_get_type (void) {
	static volatile gsize fractional_component_node_type_id__volatile = 0;
	if (g_once_init_enter (&fractional_component_node_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FractionalComponentNodeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) fractional_component_node_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FractionalComponentNode), 0, (GInstanceInitFunc) fractional_component_node_instance_init, NULL };
		GType fractional_component_node_type_id;
		fractional_component_node_type_id = g_type_register_static (TYPE_RNODE, "FractionalComponentNode", &g_define_type_info, 0);
		g_once_init_leave (&fractional_component_node_type_id__volatile, fractional_component_node_type_id);
	}
	return fractional_component_node_type_id__volatile;
}


RoundNode* round_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	RoundNode* self = NULL;
	Parser* _tmp0_;
	LexerToken* _tmp1_;
	guint _tmp2_;
	Associativity _tmp3_;
	g_return_val_if_fail (parser != NULL, NULL);
	_tmp0_ = parser;
	_tmp1_ = token;
	_tmp2_ = precedence;
	_tmp3_ = associativity;
	self = (RoundNode*) rnode_construct (object_type, _tmp0_, _tmp1_, _tmp2_, _tmp3_);
	return self;
}


RoundNode* round_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	return round_node_construct (TYPE_ROUND_NODE, parser, token, precedence, associativity);
}


static Number* round_node_real_solve_r (RNode* base, Number* r) {
	RoundNode * self;
	Number* result = NULL;
	Number* _tmp0_;
	Number* _tmp1_ = NULL;
	self = (RoundNode*) base;
	g_return_val_if_fail (r != NULL, NULL);
	_tmp0_ = r;
	_tmp1_ = number_round (_tmp0_);
	result = _tmp1_;
	return result;
}


static void round_node_class_init (RoundNodeClass * klass) {
	round_node_parent_class = g_type_class_peek_parent (klass);
	RNODE_CLASS (klass)->solve_r = round_node_real_solve_r;
}


static void round_node_instance_init (RoundNode * self) {
}


GType round_node_get_type (void) {
	static volatile gsize round_node_type_id__volatile = 0;
	if (g_once_init_enter (&round_node_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (RoundNodeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) round_node_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RoundNode), 0, (GInstanceInitFunc) round_node_instance_init, NULL };
		GType round_node_type_id;
		round_node_type_id = g_type_register_static (TYPE_RNODE, "RoundNode", &g_define_type_info, 0);
		g_once_init_leave (&round_node_type_id__volatile, round_node_type_id);
	}
	return round_node_type_id__volatile;
}


PercentNode* percent_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	PercentNode* self = NULL;
	Parser* _tmp0_;
	LexerToken* _tmp1_;
	guint _tmp2_;
	Associativity _tmp3_;
	g_return_val_if_fail (parser != NULL, NULL);
	_tmp0_ = parser;
	_tmp1_ = token;
	_tmp2_ = precedence;
	_tmp3_ = associativity;
	self = (PercentNode*) rnode_construct (object_type, _tmp0_, _tmp1_, _tmp2_, _tmp3_);
	return self;
}


PercentNode* percent_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	return percent_node_construct (TYPE_PERCENT_NODE, parser, token, precedence, associativity);
}


static Number* percent_node_real_solve_r (RNode* base, Number* r) {
	PercentNode * self;
	Number* result = NULL;
	Number* _tmp0_;
	Number* _tmp1_ = NULL;
	self = (PercentNode*) base;
	g_return_val_if_fail (r != NULL, NULL);
	_tmp0_ = r;
	_tmp1_ = number_divide_integer (_tmp0_, (gint64) 100);
	result = _tmp1_;
	return result;
}


static void percent_node_class_init (PercentNodeClass * klass) {
	percent_node_parent_class = g_type_class_peek_parent (klass);
	RNODE_CLASS (klass)->solve_r = percent_node_real_solve_r;
}


static void percent_node_instance_init (PercentNode * self) {
}


GType percent_node_get_type (void) {
	static volatile gsize percent_node_type_id__volatile = 0;
	if (g_once_init_enter (&percent_node_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (PercentNodeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) percent_node_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (PercentNode), 0, (GInstanceInitFunc) percent_node_instance_init, NULL };
		GType percent_node_type_id;
		percent_node_type_id = g_type_register_static (TYPE_RNODE, "PercentNode", &g_define_type_info, 0);
		g_once_init_leave (&percent_node_type_id__volatile, percent_node_type_id);
	}
	return percent_node_type_id__volatile;
}


FactorialNode* factorial_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	FactorialNode* self = NULL;
	Parser* _tmp0_;
	LexerToken* _tmp1_;
	guint _tmp2_;
	Associativity _tmp3_;
	g_return_val_if_fail (parser != NULL, NULL);
	_tmp0_ = parser;
	_tmp1_ = token;
	_tmp2_ = precedence;
	_tmp3_ = associativity;
	self = (FactorialNode*) rnode_construct (object_type, _tmp0_, _tmp1_, _tmp2_, _tmp3_);
	return self;
}


FactorialNode* factorial_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	return factorial_node_construct (TYPE_FACTORIAL_NODE, parser, token, precedence, associativity);
}


static Number* factorial_node_real_solve_r (RNode* base, Number* r) {
	FactorialNode * self;
	Number* result = NULL;
	Number* _tmp0_;
	Number* _tmp1_ = NULL;
	self = (FactorialNode*) base;
	g_return_val_if_fail (r != NULL, NULL);
	_tmp0_ = r;
	_tmp1_ = number_factorial (_tmp0_);
	result = _tmp1_;
	return result;
}


static void factorial_node_class_init (FactorialNodeClass * klass) {
	factorial_node_parent_class = g_type_class_peek_parent (klass);
	RNODE_CLASS (klass)->solve_r = factorial_node_real_solve_r;
}


static void factorial_node_instance_init (FactorialNode * self) {
}


GType factorial_node_get_type (void) {
	static volatile gsize factorial_node_type_id__volatile = 0;
	if (g_once_init_enter (&factorial_node_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FactorialNodeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) factorial_node_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FactorialNode), 0, (GInstanceInitFunc) factorial_node_instance_init, NULL };
		GType factorial_node_type_id;
		factorial_node_type_id = g_type_register_static (TYPE_RNODE, "FactorialNode", &g_define_type_info, 0);
		g_once_init_leave (&factorial_node_type_id__volatile, factorial_node_type_id);
	}
	return factorial_node_type_id__volatile;
}


AddNode* add_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	AddNode* self = NULL;
	Parser* _tmp0_;
	LexerToken* _tmp1_;
	guint _tmp2_;
	Associativity _tmp3_;
	g_return_val_if_fail (parser != NULL, NULL);
	_tmp0_ = parser;
	_tmp1_ = token;
	_tmp2_ = precedence;
	_tmp3_ = associativity;
	self = (AddNode*) lr_node_construct (object_type, _tmp0_, _tmp1_, _tmp2_, _tmp3_);
	return self;
}


AddNode* add_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	return add_node_construct (TYPE_ADD_NODE, parser, token, precedence, associativity);
}


static Number* add_node_real_solve_lr (LRNode* base, Number* l, Number* r) {
	AddNode * self;
	Number* result = NULL;
	gboolean _tmp0_;
	self = (AddNode*) base;
	g_return_val_if_fail (l != NULL, NULL);
	g_return_val_if_fail (r != NULL, NULL);
	_tmp0_ = self->do_percentage;
	if (_tmp0_) {
		Number* _tmp1_;
		Number* _tmp2_;
		Number* _tmp3_;
		Number* _tmp4_ = NULL;
		Number* _tmp5_;
		Number* per;
		Number* _tmp6_;
		Number* _tmp7_ = NULL;
		Number* _tmp8_;
		Number* _tmp9_;
		Number* _tmp10_ = NULL;
		_tmp1_ = r;
		_tmp2_ = number_new_integer ((gint64) 100);
		_tmp3_ = _tmp2_;
		_tmp4_ = number_add (_tmp1_, _tmp3_);
		_tmp5_ = _tmp4_;
		_number_unref0 (_tmp3_);
		per = _tmp5_;
		_tmp6_ = per;
		_tmp7_ = number_divide_integer (_tmp6_, (gint64) 100);
		_number_unref0 (per);
		per = _tmp7_;
		_tmp8_ = l;
		_tmp9_ = per;
		_tmp10_ = number_multiply (_tmp8_, _tmp9_);
		result = _tmp10_;
		_number_unref0 (per);
		return result;
	} else {
		Number* _tmp11_;
		Number* _tmp12_;
		Number* _tmp13_ = NULL;
		_tmp11_ = l;
		_tmp12_ = r;
		_tmp13_ = number_add (_tmp11_, _tmp12_);
		result = _tmp13_;
		return result;
	}
}


static void add_node_class_init (AddNodeClass * klass) {
	add_node_parent_class = g_type_class_peek_parent (klass);
	PARSE_NODE_CLASS (klass)->finalize = add_node_finalize;
	LR_NODE_CLASS (klass)->solve_lr = add_node_real_solve_lr;
}


static void add_node_instance_init (AddNode * self) {
	self->do_percentage = FALSE;
}


static void add_node_finalize (ParseNode* obj) {
	AddNode * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_ADD_NODE, AddNode);
	PARSE_NODE_CLASS (add_node_parent_class)->finalize (obj);
}


GType add_node_get_type (void) {
	static volatile gsize add_node_type_id__volatile = 0;
	if (g_once_init_enter (&add_node_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (AddNodeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) add_node_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (AddNode), 0, (GInstanceInitFunc) add_node_instance_init, NULL };
		GType add_node_type_id;
		add_node_type_id = g_type_register_static (TYPE_LR_NODE, "AddNode", &g_define_type_info, 0);
		g_once_init_leave (&add_node_type_id__volatile, add_node_type_id);
	}
	return add_node_type_id__volatile;
}


SubtractNode* subtract_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	SubtractNode* self = NULL;
	Parser* _tmp0_;
	LexerToken* _tmp1_;
	guint _tmp2_;
	Associativity _tmp3_;
	g_return_val_if_fail (parser != NULL, NULL);
	_tmp0_ = parser;
	_tmp1_ = token;
	_tmp2_ = precedence;
	_tmp3_ = associativity;
	self = (SubtractNode*) lr_node_construct (object_type, _tmp0_, _tmp1_, _tmp2_, _tmp3_);
	return self;
}


SubtractNode* subtract_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	return subtract_node_construct (TYPE_SUBTRACT_NODE, parser, token, precedence, associativity);
}


static Number* subtract_node_real_solve_lr (LRNode* base, Number* l, Number* r) {
	SubtractNode * self;
	Number* result = NULL;
	gboolean _tmp0_;
	self = (SubtractNode*) base;
	g_return_val_if_fail (l != NULL, NULL);
	g_return_val_if_fail (r != NULL, NULL);
	_tmp0_ = self->do_percentage;
	if (_tmp0_) {
		Number* _tmp1_;
		Number* _tmp2_;
		Number* _tmp3_;
		Number* _tmp4_ = NULL;
		Number* _tmp5_;
		Number* per;
		Number* _tmp6_;
		Number* _tmp7_ = NULL;
		Number* _tmp8_;
		Number* _tmp9_;
		Number* _tmp10_ = NULL;
		_tmp1_ = r;
		_tmp2_ = number_new_integer ((gint64) (-100));
		_tmp3_ = _tmp2_;
		_tmp4_ = number_add (_tmp1_, _tmp3_);
		_tmp5_ = _tmp4_;
		_number_unref0 (_tmp3_);
		per = _tmp5_;
		_tmp6_ = per;
		_tmp7_ = number_divide_integer (_tmp6_, (gint64) (-100));
		_number_unref0 (per);
		per = _tmp7_;
		_tmp8_ = l;
		_tmp9_ = per;
		_tmp10_ = number_multiply (_tmp8_, _tmp9_);
		result = _tmp10_;
		_number_unref0 (per);
		return result;
	} else {
		Number* _tmp11_;
		Number* _tmp12_;
		Number* _tmp13_ = NULL;
		_tmp11_ = l;
		_tmp12_ = r;
		_tmp13_ = number_subtract (_tmp11_, _tmp12_);
		result = _tmp13_;
		return result;
	}
}


static void subtract_node_class_init (SubtractNodeClass * klass) {
	subtract_node_parent_class = g_type_class_peek_parent (klass);
	PARSE_NODE_CLASS (klass)->finalize = subtract_node_finalize;
	LR_NODE_CLASS (klass)->solve_lr = subtract_node_real_solve_lr;
}


static void subtract_node_instance_init (SubtractNode * self) {
	self->do_percentage = FALSE;
}


static void subtract_node_finalize (ParseNode* obj) {
	SubtractNode * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_SUBTRACT_NODE, SubtractNode);
	PARSE_NODE_CLASS (subtract_node_parent_class)->finalize (obj);
}


GType subtract_node_get_type (void) {
	static volatile gsize subtract_node_type_id__volatile = 0;
	if (g_once_init_enter (&subtract_node_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (SubtractNodeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) subtract_node_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (SubtractNode), 0, (GInstanceInitFunc) subtract_node_instance_init, NULL };
		GType subtract_node_type_id;
		subtract_node_type_id = g_type_register_static (TYPE_LR_NODE, "SubtractNode", &g_define_type_info, 0);
		g_once_init_leave (&subtract_node_type_id__volatile, subtract_node_type_id);
	}
	return subtract_node_type_id__volatile;
}


MultiplyNode* multiply_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	MultiplyNode* self = NULL;
	Parser* _tmp0_;
	LexerToken* _tmp1_;
	guint _tmp2_;
	Associativity _tmp3_;
	g_return_val_if_fail (parser != NULL, NULL);
	_tmp0_ = parser;
	_tmp1_ = token;
	_tmp2_ = precedence;
	_tmp3_ = associativity;
	self = (MultiplyNode*) lr_node_construct (object_type, _tmp0_, _tmp1_, _tmp2_, _tmp3_);
	return self;
}


MultiplyNode* multiply_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	return multiply_node_construct (TYPE_MULTIPLY_NODE, parser, token, precedence, associativity);
}


static Number* multiply_node_real_solve_lr (LRNode* base, Number* l, Number* r) {
	MultiplyNode * self;
	Number* result = NULL;
	Number* _tmp0_;
	Number* _tmp1_;
	Number* _tmp2_ = NULL;
	self = (MultiplyNode*) base;
	g_return_val_if_fail (l != NULL, NULL);
	g_return_val_if_fail (r != NULL, NULL);
	_tmp0_ = l;
	_tmp1_ = r;
	_tmp2_ = number_multiply (_tmp0_, _tmp1_);
	result = _tmp2_;
	return result;
}


static void multiply_node_class_init (MultiplyNodeClass * klass) {
	multiply_node_parent_class = g_type_class_peek_parent (klass);
	LR_NODE_CLASS (klass)->solve_lr = multiply_node_real_solve_lr;
}


static void multiply_node_instance_init (MultiplyNode * self) {
}


GType multiply_node_get_type (void) {
	static volatile gsize multiply_node_type_id__volatile = 0;
	if (g_once_init_enter (&multiply_node_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (MultiplyNodeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) multiply_node_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (MultiplyNode), 0, (GInstanceInitFunc) multiply_node_instance_init, NULL };
		GType multiply_node_type_id;
		multiply_node_type_id = g_type_register_static (TYPE_LR_NODE, "MultiplyNode", &g_define_type_info, 0);
		g_once_init_leave (&multiply_node_type_id__volatile, multiply_node_type_id);
	}
	return multiply_node_type_id__volatile;
}


DivideNode* divide_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	DivideNode* self = NULL;
	Parser* _tmp0_;
	LexerToken* _tmp1_;
	guint _tmp2_;
	Associativity _tmp3_;
	g_return_val_if_fail (parser != NULL, NULL);
	_tmp0_ = parser;
	_tmp1_ = token;
	_tmp2_ = precedence;
	_tmp3_ = associativity;
	self = (DivideNode*) lr_node_construct (object_type, _tmp0_, _tmp1_, _tmp2_, _tmp3_);
	return self;
}


DivideNode* divide_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	return divide_node_construct (TYPE_DIVIDE_NODE, parser, token, precedence, associativity);
}


static Number* divide_node_real_solve_lr (LRNode* base, Number* l, Number* r) {
	DivideNode * self;
	Number* result = NULL;
	Number* _tmp0_;
	Number* _tmp1_;
	Number* _tmp2_ = NULL;
	self = (DivideNode*) base;
	g_return_val_if_fail (l != NULL, NULL);
	g_return_val_if_fail (r != NULL, NULL);
	_tmp0_ = l;
	_tmp1_ = r;
	_tmp2_ = number_divide (_tmp0_, _tmp1_);
	result = _tmp2_;
	return result;
}


static void divide_node_class_init (DivideNodeClass * klass) {
	divide_node_parent_class = g_type_class_peek_parent (klass);
	LR_NODE_CLASS (klass)->solve_lr = divide_node_real_solve_lr;
}


static void divide_node_instance_init (DivideNode * self) {
}


GType divide_node_get_type (void) {
	static volatile gsize divide_node_type_id__volatile = 0;
	if (g_once_init_enter (&divide_node_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (DivideNodeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) divide_node_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (DivideNode), 0, (GInstanceInitFunc) divide_node_instance_init, NULL };
		GType divide_node_type_id;
		divide_node_type_id = g_type_register_static (TYPE_LR_NODE, "DivideNode", &g_define_type_info, 0);
		g_once_init_leave (&divide_node_type_id__volatile, divide_node_type_id);
	}
	return divide_node_type_id__volatile;
}


ModulusDivideNode* modulus_divide_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	ModulusDivideNode* self = NULL;
	Parser* _tmp0_;
	LexerToken* _tmp1_;
	guint _tmp2_;
	Associativity _tmp3_;
	g_return_val_if_fail (parser != NULL, NULL);
	_tmp0_ = parser;
	_tmp1_ = token;
	_tmp2_ = precedence;
	_tmp3_ = associativity;
	self = (ModulusDivideNode*) lr_node_construct (object_type, _tmp0_, _tmp1_, _tmp2_, _tmp3_);
	return self;
}


ModulusDivideNode* modulus_divide_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	return modulus_divide_node_construct (TYPE_MODULUS_DIVIDE_NODE, parser, token, precedence, associativity);
}


static Number* modulus_divide_node_real_solve_lr (LRNode* base, Number* l, Number* r) {
	ModulusDivideNode * self;
	Number* result = NULL;
	Number* _tmp0_;
	Number* _tmp1_;
	Number* _tmp2_ = NULL;
	self = (ModulusDivideNode*) base;
	g_return_val_if_fail (l != NULL, NULL);
	g_return_val_if_fail (r != NULL, NULL);
	_tmp0_ = l;
	_tmp1_ = r;
	_tmp2_ = number_modulus_divide (_tmp0_, _tmp1_);
	result = _tmp2_;
	return result;
}


static void modulus_divide_node_class_init (ModulusDivideNodeClass * klass) {
	modulus_divide_node_parent_class = g_type_class_peek_parent (klass);
	LR_NODE_CLASS (klass)->solve_lr = modulus_divide_node_real_solve_lr;
}


static void modulus_divide_node_instance_init (ModulusDivideNode * self) {
}


GType modulus_divide_node_get_type (void) {
	static volatile gsize modulus_divide_node_type_id__volatile = 0;
	if (g_once_init_enter (&modulus_divide_node_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ModulusDivideNodeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) modulus_divide_node_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ModulusDivideNode), 0, (GInstanceInitFunc) modulus_divide_node_instance_init, NULL };
		GType modulus_divide_node_type_id;
		modulus_divide_node_type_id = g_type_register_static (TYPE_LR_NODE, "ModulusDivideNode", &g_define_type_info, 0);
		g_once_init_leave (&modulus_divide_node_type_id__volatile, modulus_divide_node_type_id);
	}
	return modulus_divide_node_type_id__volatile;
}


RootNode* root_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity, gint n) {
	RootNode* self = NULL;
	Parser* _tmp0_;
	LexerToken* _tmp1_;
	guint _tmp2_;
	Associativity _tmp3_;
	gint _tmp4_;
	g_return_val_if_fail (parser != NULL, NULL);
	_tmp0_ = parser;
	_tmp1_ = token;
	_tmp2_ = precedence;
	_tmp3_ = associativity;
	self = (RootNode*) rnode_construct (object_type, _tmp0_, _tmp1_, _tmp2_, _tmp3_);
	_tmp4_ = n;
	self->priv->n = _tmp4_;
	return self;
}


RootNode* root_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity, gint n) {
	return root_node_construct (TYPE_ROOT_NODE, parser, token, precedence, associativity, n);
}


static Number* root_node_real_solve_r (RNode* base, Number* r) {
	RootNode * self;
	Number* result = NULL;
	Number* _tmp0_;
	gint _tmp1_;
	Number* _tmp2_ = NULL;
	self = (RootNode*) base;
	g_return_val_if_fail (r != NULL, NULL);
	_tmp0_ = r;
	_tmp1_ = self->priv->n;
	_tmp2_ = number_root (_tmp0_, (gint64) _tmp1_);
	result = _tmp2_;
	return result;
}


static void root_node_class_init (RootNodeClass * klass) {
	root_node_parent_class = g_type_class_peek_parent (klass);
	PARSE_NODE_CLASS (klass)->finalize = root_node_finalize;
	g_type_class_add_private (klass, sizeof (RootNodePrivate));
	RNODE_CLASS (klass)->solve_r = root_node_real_solve_r;
}


static void root_node_instance_init (RootNode * self) {
	self->priv = ROOT_NODE_GET_PRIVATE (self);
}


static void root_node_finalize (ParseNode* obj) {
	RootNode * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_ROOT_NODE, RootNode);
	PARSE_NODE_CLASS (root_node_parent_class)->finalize (obj);
}


GType root_node_get_type (void) {
	static volatile gsize root_node_type_id__volatile = 0;
	if (g_once_init_enter (&root_node_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (RootNodeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) root_node_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RootNode), 0, (GInstanceInitFunc) root_node_instance_init, NULL };
		GType root_node_type_id;
		root_node_type_id = g_type_register_static (TYPE_RNODE, "RootNode", &g_define_type_info, 0);
		g_once_init_leave (&root_node_type_id__volatile, root_node_type_id);
	}
	return root_node_type_id__volatile;
}


XPowYNode* xpow_ynode_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	XPowYNode* self = NULL;
	Parser* _tmp0_;
	LexerToken* _tmp1_;
	guint _tmp2_;
	Associativity _tmp3_;
	g_return_val_if_fail (parser != NULL, NULL);
	_tmp0_ = parser;
	_tmp1_ = token;
	_tmp2_ = precedence;
	_tmp3_ = associativity;
	self = (XPowYNode*) lr_node_construct (object_type, _tmp0_, _tmp1_, _tmp2_, _tmp3_);
	return self;
}


XPowYNode* xpow_ynode_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	return xpow_ynode_construct (TYPE_XPOW_YNODE, parser, token, precedence, associativity);
}


static Number* xpow_ynode_real_solve_lr (LRNode* base, Number* l, Number* r) {
	XPowYNode * self;
	Number* result = NULL;
	Number* _tmp0_;
	Number* _tmp1_;
	Number* _tmp2_ = NULL;
	self = (XPowYNode*) base;
	g_return_val_if_fail (l != NULL, NULL);
	g_return_val_if_fail (r != NULL, NULL);
	_tmp0_ = l;
	_tmp1_ = r;
	_tmp2_ = number_xpowy (_tmp0_, _tmp1_);
	result = _tmp2_;
	return result;
}


static void xpow_ynode_class_init (XPowYNodeClass * klass) {
	xpow_ynode_parent_class = g_type_class_peek_parent (klass);
	LR_NODE_CLASS (klass)->solve_lr = xpow_ynode_real_solve_lr;
}


static void xpow_ynode_instance_init (XPowYNode * self) {
}


GType xpow_ynode_get_type (void) {
	static volatile gsize xpow_ynode_type_id__volatile = 0;
	if (g_once_init_enter (&xpow_ynode_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (XPowYNodeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) xpow_ynode_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (XPowYNode), 0, (GInstanceInitFunc) xpow_ynode_instance_init, NULL };
		GType xpow_ynode_type_id;
		xpow_ynode_type_id = g_type_register_static (TYPE_LR_NODE, "XPowYNode", &g_define_type_info, 0);
		g_once_init_leave (&xpow_ynode_type_id__volatile, xpow_ynode_type_id);
	}
	return xpow_ynode_type_id__volatile;
}


XPowYIntegerNode* xpow_yinteger_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	XPowYIntegerNode* self = NULL;
	Parser* _tmp0_;
	LexerToken* _tmp1_;
	guint _tmp2_;
	Associativity _tmp3_;
	g_return_val_if_fail (parser != NULL, NULL);
	_tmp0_ = parser;
	_tmp1_ = token;
	_tmp2_ = precedence;
	_tmp3_ = associativity;
	self = (XPowYIntegerNode*) parse_node_construct (object_type, _tmp0_, _tmp1_, _tmp2_, _tmp3_, NULL);
	return self;
}


XPowYIntegerNode* xpow_yinteger_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	return xpow_yinteger_node_construct (TYPE_XPOW_YINTEGER_NODE, parser, token, precedence, associativity);
}


static Number* xpow_yinteger_node_real_solve (ParseNode* base) {
	XPowYIntegerNode * self;
	Number* result = NULL;
	ParseNode* _tmp0_;
	Number* _tmp1_ = NULL;
	Number* val;
	ParseNode* _tmp2_;
	LexerToken* _tmp3_;
	const gchar* _tmp4_;
	gint _tmp5_ = 0;
	gint pow;
	Number* _tmp6_;
	Number* _tmp7_;
	gint _tmp8_;
	Number* _tmp9_ = NULL;
	self = (XPowYIntegerNode*) base;
	_tmp0_ = ((ParseNode*) self)->left;
	_tmp1_ = parse_node_solve (_tmp0_);
	val = _tmp1_;
	_tmp2_ = ((ParseNode*) self)->right;
	_tmp3_ = _tmp2_->token;
	_tmp4_ = _tmp3_->text;
	_tmp5_ = super_atoi (_tmp4_);
	pow = _tmp5_;
	_tmp6_ = val;
	if (_tmp6_ == NULL) {
		result = NULL;
		_number_unref0 (val);
		return result;
	}
	_tmp7_ = val;
	_tmp8_ = pow;
	_tmp9_ = number_xpowy_integer (_tmp7_, (gint64) _tmp8_);
	result = _tmp9_;
	_number_unref0 (val);
	return result;
}


static void xpow_yinteger_node_class_init (XPowYIntegerNodeClass * klass) {
	xpow_yinteger_node_parent_class = g_type_class_peek_parent (klass);
	PARSE_NODE_CLASS (klass)->solve = xpow_yinteger_node_real_solve;
}


static void xpow_yinteger_node_instance_init (XPowYIntegerNode * self) {
}


GType xpow_yinteger_node_get_type (void) {
	static volatile gsize xpow_yinteger_node_type_id__volatile = 0;
	if (g_once_init_enter (&xpow_yinteger_node_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (XPowYIntegerNodeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) xpow_yinteger_node_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (XPowYIntegerNode), 0, (GInstanceInitFunc) xpow_yinteger_node_instance_init, NULL };
		GType xpow_yinteger_node_type_id;
		xpow_yinteger_node_type_id = g_type_register_static (TYPE_PARSE_NODE, "XPowYIntegerNode", &g_define_type_info, 0);
		g_once_init_leave (&xpow_yinteger_node_type_id__volatile, xpow_yinteger_node_type_id);
	}
	return xpow_yinteger_node_type_id__volatile;
}


NotNode* not_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	NotNode* self = NULL;
	Parser* _tmp0_;
	LexerToken* _tmp1_;
	guint _tmp2_;
	Associativity _tmp3_;
	g_return_val_if_fail (parser != NULL, NULL);
	_tmp0_ = parser;
	_tmp1_ = token;
	_tmp2_ = precedence;
	_tmp3_ = associativity;
	self = (NotNode*) rnode_construct (object_type, _tmp0_, _tmp1_, _tmp2_, _tmp3_);
	return self;
}


NotNode* not_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	return not_node_construct (TYPE_NOT_NODE, parser, token, precedence, associativity);
}


static Number* not_node_real_solve_r (RNode* base, Number* r) {
	NotNode * self;
	Number* result = NULL;
	Number* _tmp0_;
	Parser* _tmp1_;
	gint _tmp2_;
	gboolean _tmp3_ = FALSE;
	Number* _tmp6_;
	Parser* _tmp7_;
	gint _tmp8_;
	Number* _tmp9_ = NULL;
	self = (NotNode*) base;
	g_return_val_if_fail (r != NULL, NULL);
	_tmp0_ = r;
	_tmp1_ = ((ParseNode*) self)->parser;
	_tmp2_ = _tmp1_->wordlen;
	_tmp3_ = mp_is_overflow (_tmp0_, _tmp2_);
	if (!_tmp3_) {
		Parser* _tmp4_;
		Number* _tmp5_;
		_tmp4_ = ((ParseNode*) self)->parser;
		parser_set_error (_tmp4_, ERROR_CODE_OVERFLOW, NULL, (guint) 0, (guint) 0);
		_tmp5_ = number_new_integer ((gint64) 0);
		result = _tmp5_;
		return result;
	}
	_tmp6_ = r;
	_tmp7_ = ((ParseNode*) self)->parser;
	_tmp8_ = _tmp7_->wordlen;
	_tmp9_ = number_not (_tmp6_, _tmp8_);
	result = _tmp9_;
	return result;
}


static void not_node_class_init (NotNodeClass * klass) {
	not_node_parent_class = g_type_class_peek_parent (klass);
	RNODE_CLASS (klass)->solve_r = not_node_real_solve_r;
}


static void not_node_instance_init (NotNode * self) {
}


GType not_node_get_type (void) {
	static volatile gsize not_node_type_id__volatile = 0;
	if (g_once_init_enter (&not_node_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (NotNodeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) not_node_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (NotNode), 0, (GInstanceInitFunc) not_node_instance_init, NULL };
		GType not_node_type_id;
		not_node_type_id = g_type_register_static (TYPE_RNODE, "NotNode", &g_define_type_info, 0);
		g_once_init_leave (&not_node_type_id__volatile, not_node_type_id);
	}
	return not_node_type_id__volatile;
}


AndNode* and_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	AndNode* self = NULL;
	Parser* _tmp0_;
	LexerToken* _tmp1_;
	guint _tmp2_;
	Associativity _tmp3_;
	g_return_val_if_fail (parser != NULL, NULL);
	_tmp0_ = parser;
	_tmp1_ = token;
	_tmp2_ = precedence;
	_tmp3_ = associativity;
	self = (AndNode*) lr_node_construct (object_type, _tmp0_, _tmp1_, _tmp2_, _tmp3_);
	return self;
}


AndNode* and_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	return and_node_construct (TYPE_AND_NODE, parser, token, precedence, associativity);
}


static Number* and_node_real_solve_lr (LRNode* base, Number* l, Number* r) {
	AndNode * self;
	Number* result = NULL;
	Number* _tmp0_;
	Number* _tmp1_;
	Number* _tmp2_ = NULL;
	self = (AndNode*) base;
	g_return_val_if_fail (l != NULL, NULL);
	g_return_val_if_fail (r != NULL, NULL);
	_tmp0_ = l;
	_tmp1_ = r;
	_tmp2_ = number_and (_tmp0_, _tmp1_);
	result = _tmp2_;
	return result;
}


static void and_node_class_init (AndNodeClass * klass) {
	and_node_parent_class = g_type_class_peek_parent (klass);
	LR_NODE_CLASS (klass)->solve_lr = and_node_real_solve_lr;
}


static void and_node_instance_init (AndNode * self) {
}


GType and_node_get_type (void) {
	static volatile gsize and_node_type_id__volatile = 0;
	if (g_once_init_enter (&and_node_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (AndNodeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) and_node_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (AndNode), 0, (GInstanceInitFunc) and_node_instance_init, NULL };
		GType and_node_type_id;
		and_node_type_id = g_type_register_static (TYPE_LR_NODE, "AndNode", &g_define_type_info, 0);
		g_once_init_leave (&and_node_type_id__volatile, and_node_type_id);
	}
	return and_node_type_id__volatile;
}


OrNode* or_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	OrNode* self = NULL;
	Parser* _tmp0_;
	LexerToken* _tmp1_;
	guint _tmp2_;
	Associativity _tmp3_;
	g_return_val_if_fail (parser != NULL, NULL);
	_tmp0_ = parser;
	_tmp1_ = token;
	_tmp2_ = precedence;
	_tmp3_ = associativity;
	self = (OrNode*) lr_node_construct (object_type, _tmp0_, _tmp1_, _tmp2_, _tmp3_);
	return self;
}


OrNode* or_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	return or_node_construct (TYPE_OR_NODE, parser, token, precedence, associativity);
}


static Number* or_node_real_solve_lr (LRNode* base, Number* l, Number* r) {
	OrNode * self;
	Number* result = NULL;
	Number* _tmp0_;
	Number* _tmp1_;
	Number* _tmp2_ = NULL;
	self = (OrNode*) base;
	g_return_val_if_fail (l != NULL, NULL);
	g_return_val_if_fail (r != NULL, NULL);
	_tmp0_ = l;
	_tmp1_ = r;
	_tmp2_ = number_or (_tmp0_, _tmp1_);
	result = _tmp2_;
	return result;
}


static void or_node_class_init (OrNodeClass * klass) {
	or_node_parent_class = g_type_class_peek_parent (klass);
	LR_NODE_CLASS (klass)->solve_lr = or_node_real_solve_lr;
}


static void or_node_instance_init (OrNode * self) {
}


GType or_node_get_type (void) {
	static volatile gsize or_node_type_id__volatile = 0;
	if (g_once_init_enter (&or_node_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (OrNodeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) or_node_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (OrNode), 0, (GInstanceInitFunc) or_node_instance_init, NULL };
		GType or_node_type_id;
		or_node_type_id = g_type_register_static (TYPE_LR_NODE, "OrNode", &g_define_type_info, 0);
		g_once_init_leave (&or_node_type_id__volatile, or_node_type_id);
	}
	return or_node_type_id__volatile;
}


XorNode* xor_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	XorNode* self = NULL;
	Parser* _tmp0_;
	LexerToken* _tmp1_;
	guint _tmp2_;
	Associativity _tmp3_;
	g_return_val_if_fail (parser != NULL, NULL);
	_tmp0_ = parser;
	_tmp1_ = token;
	_tmp2_ = precedence;
	_tmp3_ = associativity;
	self = (XorNode*) lr_node_construct (object_type, _tmp0_, _tmp1_, _tmp2_, _tmp3_);
	return self;
}


XorNode* xor_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	return xor_node_construct (TYPE_XOR_NODE, parser, token, precedence, associativity);
}


static Number* xor_node_real_solve_lr (LRNode* base, Number* l, Number* r) {
	XorNode * self;
	Number* result = NULL;
	Number* _tmp0_;
	Number* _tmp1_;
	Number* _tmp2_ = NULL;
	self = (XorNode*) base;
	g_return_val_if_fail (l != NULL, NULL);
	g_return_val_if_fail (r != NULL, NULL);
	_tmp0_ = l;
	_tmp1_ = r;
	_tmp2_ = number_xor (_tmp0_, _tmp1_);
	result = _tmp2_;
	return result;
}


static void xor_node_class_init (XorNodeClass * klass) {
	xor_node_parent_class = g_type_class_peek_parent (klass);
	LR_NODE_CLASS (klass)->solve_lr = xor_node_real_solve_lr;
}


static void xor_node_instance_init (XorNode * self) {
}


GType xor_node_get_type (void) {
	static volatile gsize xor_node_type_id__volatile = 0;
	if (g_once_init_enter (&xor_node_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (XorNodeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) xor_node_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (XorNode), 0, (GInstanceInitFunc) xor_node_instance_init, NULL };
		GType xor_node_type_id;
		xor_node_type_id = g_type_register_static (TYPE_LR_NODE, "XorNode", &g_define_type_info, 0);
		g_once_init_leave (&xor_node_type_id__volatile, xor_node_type_id);
	}
	return xor_node_type_id__volatile;
}


ConvertNode* convert_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	ConvertNode* self = NULL;
	Parser* _tmp0_;
	LexerToken* _tmp1_;
	guint _tmp2_;
	Associativity _tmp3_;
	g_return_val_if_fail (parser != NULL, NULL);
	_tmp0_ = parser;
	_tmp1_ = token;
	_tmp2_ = precedence;
	_tmp3_ = associativity;
	self = (ConvertNode*) lr_node_construct (object_type, _tmp0_, _tmp1_, _tmp2_, _tmp3_);
	return self;
}


ConvertNode* convert_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	return convert_node_construct (TYPE_CONVERT_NODE, parser, token, precedence, associativity);
}


static Number* convert_node_real_solve_lr (LRNode* base, Number* l, Number* r) {
	ConvertNode * self;
	Number* result = NULL;
	gchar* from = NULL;
	ParseNode* _tmp0_;
	const gchar* _tmp1_;
	gchar* to = NULL;
	ParseNode* _tmp10_;
	const gchar* _tmp11_;
	Number* _tmp20_;
	Number* tmp;
	Parser* _tmp21_;
	Number* _tmp22_;
	const gchar* _tmp23_;
	const gchar* _tmp24_;
	Number* _tmp25_ = NULL;
	Number* ans;
	Number* _tmp26_;
	self = (ConvertNode*) base;
	g_return_val_if_fail (l != NULL, NULL);
	g_return_val_if_fail (r != NULL, NULL);
	_tmp0_ = ((ParseNode*) self)->left;
	_tmp1_ = _tmp0_->value;
	if (_tmp1_ != NULL) {
		ParseNode* _tmp2_;
		const gchar* _tmp3_;
		gchar* _tmp4_;
		ParseNode* _tmp5_;
		_tmp2_ = ((ParseNode*) self)->left;
		_tmp3_ = _tmp2_->value;
		_tmp4_ = g_strdup (_tmp3_);
		_g_free0 (from);
		from = _tmp4_;
		_tmp5_ = ((ParseNode*) self)->left;
		_g_free0 (_tmp5_->value);
		_tmp5_->value = NULL;
	} else {
		ParseNode* _tmp6_;
		LexerToken* _tmp7_;
		const gchar* _tmp8_;
		gchar* _tmp9_;
		_tmp6_ = ((ParseNode*) self)->left;
		_tmp7_ = _tmp6_->token;
		_tmp8_ = _tmp7_->text;
		_tmp9_ = g_strdup (_tmp8_);
		_g_free0 (from);
		from = _tmp9_;
	}
	_tmp10_ = ((ParseNode*) self)->right;
	_tmp11_ = _tmp10_->value;
	if (_tmp11_ != NULL) {
		ParseNode* _tmp12_;
		const gchar* _tmp13_;
		gchar* _tmp14_;
		ParseNode* _tmp15_;
		_tmp12_ = ((ParseNode*) self)->right;
		_tmp13_ = _tmp12_->value;
		_tmp14_ = g_strdup (_tmp13_);
		_g_free0 (to);
		to = _tmp14_;
		_tmp15_ = ((ParseNode*) self)->right;
		_g_free0 (_tmp15_->value);
		_tmp15_->value = NULL;
	} else {
		ParseNode* _tmp16_;
		LexerToken* _tmp17_;
		const gchar* _tmp18_;
		gchar* _tmp19_;
		_tmp16_ = ((ParseNode*) self)->right;
		_tmp17_ = _tmp16_->token;
		_tmp18_ = _tmp17_->text;
		_tmp19_ = g_strdup (_tmp18_);
		_g_free0 (to);
		to = _tmp19_;
	}
	_tmp20_ = number_new_integer ((gint64) 1);
	tmp = _tmp20_;
	_tmp21_ = ((ParseNode*) self)->parser;
	_tmp22_ = tmp;
	_tmp23_ = from;
	_tmp24_ = to;
	_tmp25_ = parser_convert (_tmp21_, _tmp22_, _tmp23_, _tmp24_);
	ans = _tmp25_;
	_tmp26_ = ans;
	if (_tmp26_ == NULL) {
		Parser* _tmp27_;
		_tmp27_ = ((ParseNode*) self)->parser;
		parser_set_error (_tmp27_, ERROR_CODE_UNKNOWN_CONVERSION, NULL, (guint) 0, (guint) 0);
	}
	result = ans;
	_number_unref0 (tmp);
	_g_free0 (to);
	_g_free0 (from);
	return result;
}


static void convert_node_class_init (ConvertNodeClass * klass) {
	convert_node_parent_class = g_type_class_peek_parent (klass);
	LR_NODE_CLASS (klass)->solve_lr = convert_node_real_solve_lr;
}


static void convert_node_instance_init (ConvertNode * self) {
}


GType convert_node_get_type (void) {
	static volatile gsize convert_node_type_id__volatile = 0;
	if (g_once_init_enter (&convert_node_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ConvertNodeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) convert_node_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ConvertNode), 0, (GInstanceInitFunc) convert_node_instance_init, NULL };
		GType convert_node_type_id;
		convert_node_type_id = g_type_register_static (TYPE_LR_NODE, "ConvertNode", &g_define_type_info, 0);
		g_once_init_leave (&convert_node_type_id__volatile, convert_node_type_id);
	}
	return convert_node_type_id__volatile;
}


ConvertBaseNode* convert_base_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity, const gchar* value) {
	ConvertBaseNode* self = NULL;
	Parser* _tmp0_;
	LexerToken* _tmp1_;
	guint _tmp2_;
	Associativity _tmp3_;
	const gchar* _tmp4_;
	g_return_val_if_fail (parser != NULL, NULL);
	_tmp0_ = parser;
	_tmp1_ = token;
	_tmp2_ = precedence;
	_tmp3_ = associativity;
	_tmp4_ = value;
	self = (ConvertBaseNode*) parse_node_construct (object_type, _tmp0_, _tmp1_, _tmp2_, _tmp3_, _tmp4_);
	return self;
}


ConvertBaseNode* convert_base_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity, const gchar* value) {
	return convert_base_node_construct (TYPE_CONVERT_BASE_NODE, parser, token, precedence, associativity, value);
}


static Number* convert_base_node_real_solve (ParseNode* base) {
	ConvertBaseNode * self;
	Number* result = NULL;
	gboolean _tmp0_ = FALSE;
	const gchar* _tmp1_;
	gboolean _tmp3_;
	ParseNode* _tmp27_;
	Number* _tmp28_ = NULL;
	self = (ConvertBaseNode*) base;
	_tmp1_ = ((ParseNode*) self)->value;
	if (g_strcmp0 (_tmp1_, "hex") == 0) {
		_tmp0_ = TRUE;
	} else {
		const gchar* _tmp2_;
		_tmp2_ = ((ParseNode*) self)->value;
		_tmp0_ = g_strcmp0 (_tmp2_, "hexadecimal") == 0;
	}
	_tmp3_ = _tmp0_;
	if (_tmp3_) {
		Parser* _tmp4_;
		_tmp4_ = ((ParseNode*) self)->parser;
		parser_set_representation_base (_tmp4_, (guint) 16);
	} else {
		gboolean _tmp5_ = FALSE;
		const gchar* _tmp6_;
		gboolean _tmp8_;
		_tmp6_ = ((ParseNode*) self)->value;
		if (g_strcmp0 (_tmp6_, "dec") == 0) {
			_tmp5_ = TRUE;
		} else {
			const gchar* _tmp7_;
			_tmp7_ = ((ParseNode*) self)->value;
			_tmp5_ = g_strcmp0 (_tmp7_, "decimal") == 0;
		}
		_tmp8_ = _tmp5_;
		if (_tmp8_) {
			Parser* _tmp9_;
			_tmp9_ = ((ParseNode*) self)->parser;
			parser_set_representation_base (_tmp9_, (guint) 10);
		} else {
			gboolean _tmp10_ = FALSE;
			const gchar* _tmp11_;
			gboolean _tmp13_;
			_tmp11_ = ((ParseNode*) self)->value;
			if (g_strcmp0 (_tmp11_, "oct") == 0) {
				_tmp10_ = TRUE;
			} else {
				const gchar* _tmp12_;
				_tmp12_ = ((ParseNode*) self)->value;
				_tmp10_ = g_strcmp0 (_tmp12_, "octal") == 0;
			}
			_tmp13_ = _tmp10_;
			if (_tmp13_) {
				Parser* _tmp14_;
				_tmp14_ = ((ParseNode*) self)->parser;
				parser_set_representation_base (_tmp14_, (guint) 8);
			} else {
				gboolean _tmp15_ = FALSE;
				const gchar* _tmp16_;
				gboolean _tmp18_;
				_tmp16_ = ((ParseNode*) self)->value;
				if (g_strcmp0 (_tmp16_, "bin") == 0) {
					_tmp15_ = TRUE;
				} else {
					const gchar* _tmp17_;
					_tmp17_ = ((ParseNode*) self)->value;
					_tmp15_ = g_strcmp0 (_tmp17_, "binary") == 0;
				}
				_tmp18_ = _tmp15_;
				if (_tmp18_) {
					Parser* _tmp19_;
					_tmp19_ = ((ParseNode*) self)->parser;
					parser_set_representation_base (_tmp19_, (guint) 2);
				} else {
					Parser* _tmp20_;
					LexerToken* _tmp21_;
					const gchar* _tmp22_;
					LexerToken* _tmp23_;
					guint _tmp24_;
					LexerToken* _tmp25_;
					guint _tmp26_;
					_tmp20_ = ((ParseNode*) self)->parser;
					_tmp21_ = ((ParseNode*) self)->token;
					_tmp22_ = _tmp21_->text;
					_tmp23_ = ((ParseNode*) self)->token;
					_tmp24_ = _tmp23_->start_index;
					_tmp25_ = ((ParseNode*) self)->token;
					_tmp26_ = _tmp25_->end_index;
					parser_set_error (_tmp20_, ERROR_CODE_UNKNOWN_CONVERSION, _tmp22_, _tmp24_, _tmp26_);
					result = NULL;
					return result;
				}
			}
		}
	}
	_tmp27_ = ((ParseNode*) self)->left;
	_tmp28_ = parse_node_solve (_tmp27_);
	result = _tmp28_;
	return result;
}


static void convert_base_node_class_init (ConvertBaseNodeClass * klass) {
	convert_base_node_parent_class = g_type_class_peek_parent (klass);
	PARSE_NODE_CLASS (klass)->solve = convert_base_node_real_solve;
}


static void convert_base_node_instance_init (ConvertBaseNode * self) {
}


GType convert_base_node_get_type (void) {
	static volatile gsize convert_base_node_type_id__volatile = 0;
	if (g_once_init_enter (&convert_base_node_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ConvertBaseNodeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) convert_base_node_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ConvertBaseNode), 0, (GInstanceInitFunc) convert_base_node_instance_init, NULL };
		GType convert_base_node_type_id;
		convert_base_node_type_id = g_type_register_static (TYPE_PARSE_NODE, "ConvertBaseNode", &g_define_type_info, 0);
		g_once_init_leave (&convert_base_node_type_id__volatile, convert_base_node_type_id);
	}
	return convert_base_node_type_id__volatile;
}


ConvertNumberNode* convert_number_node_construct (GType object_type, Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	ConvertNumberNode* self = NULL;
	Parser* _tmp0_;
	LexerToken* _tmp1_;
	guint _tmp2_;
	Associativity _tmp3_;
	g_return_val_if_fail (parser != NULL, NULL);
	_tmp0_ = parser;
	_tmp1_ = token;
	_tmp2_ = precedence;
	_tmp3_ = associativity;
	self = (ConvertNumberNode*) parse_node_construct (object_type, _tmp0_, _tmp1_, _tmp2_, _tmp3_, NULL);
	return self;
}


ConvertNumberNode* convert_number_node_new (Parser* parser, LexerToken* token, guint precedence, Associativity associativity) {
	return convert_number_node_construct (TYPE_CONVERT_NUMBER_NODE, parser, token, precedence, associativity);
}


static Number* convert_number_node_real_solve (ParseNode* base) {
	ConvertNumberNode * self;
	Number* result = NULL;
	gchar* from = NULL;
	ParseNode* _tmp0_;
	const gchar* _tmp1_;
	gchar* to = NULL;
	ParseNode* _tmp10_;
	const gchar* _tmp11_;
	ParseNode* _tmp20_;
	ParseNode* _tmp21_;
	LexerToken* _tmp22_;
	const gchar* _tmp23_;
	Parser* _tmp24_;
	gint _tmp25_;
	Number* _tmp26_ = NULL;
	Number* tmp;
	Number* _tmp27_;
	Parser* _tmp28_;
	Number* _tmp29_;
	const gchar* _tmp30_;
	const gchar* _tmp31_;
	Number* _tmp32_ = NULL;
	Number* ans;
	Number* _tmp33_;
	self = (ConvertNumberNode*) base;
	_tmp0_ = ((ParseNode*) self)->left;
	_tmp1_ = _tmp0_->value;
	if (_tmp1_ != NULL) {
		ParseNode* _tmp2_;
		const gchar* _tmp3_;
		gchar* _tmp4_;
		ParseNode* _tmp5_;
		_tmp2_ = ((ParseNode*) self)->left;
		_tmp3_ = _tmp2_->value;
		_tmp4_ = g_strdup (_tmp3_);
		_g_free0 (from);
		from = _tmp4_;
		_tmp5_ = ((ParseNode*) self)->left;
		_g_free0 (_tmp5_->value);
		_tmp5_->value = NULL;
	} else {
		ParseNode* _tmp6_;
		LexerToken* _tmp7_;
		const gchar* _tmp8_;
		gchar* _tmp9_;
		_tmp6_ = ((ParseNode*) self)->left;
		_tmp7_ = _tmp6_->token;
		_tmp8_ = _tmp7_->text;
		_tmp9_ = g_strdup (_tmp8_);
		_g_free0 (from);
		from = _tmp9_;
	}
	_tmp10_ = ((ParseNode*) self)->right;
	_tmp11_ = _tmp10_->value;
	if (_tmp11_ != NULL) {
		ParseNode* _tmp12_;
		const gchar* _tmp13_;
		gchar* _tmp14_;
		ParseNode* _tmp15_;
		_tmp12_ = ((ParseNode*) self)->right;
		_tmp13_ = _tmp12_->value;
		_tmp14_ = g_strdup (_tmp13_);
		_g_free0 (to);
		to = _tmp14_;
		_tmp15_ = ((ParseNode*) self)->right;
		_g_free0 (_tmp15_->value);
		_tmp15_->value = NULL;
	} else {
		ParseNode* _tmp16_;
		LexerToken* _tmp17_;
		const gchar* _tmp18_;
		gchar* _tmp19_;
		_tmp16_ = ((ParseNode*) self)->right;
		_tmp17_ = _tmp16_->token;
		_tmp18_ = _tmp17_->text;
		_tmp19_ = g_strdup (_tmp18_);
		_g_free0 (to);
		to = _tmp19_;
	}
	_tmp20_ = ((ParseNode*) self)->left;
	_tmp21_ = _tmp20_->left;
	_tmp22_ = _tmp21_->token;
	_tmp23_ = _tmp22_->text;
	_tmp24_ = ((ParseNode*) self)->parser;
	_tmp25_ = _tmp24_->number_base;
	_tmp26_ = mp_set_from_string (_tmp23_, _tmp25_);
	tmp = _tmp26_;
	_tmp27_ = tmp;
	if (_tmp27_ == NULL) {
		result = NULL;
		_number_unref0 (tmp);
		_g_free0 (to);
		_g_free0 (from);
		return result;
	}
	_tmp28_ = ((ParseNode*) self)->parser;
	_tmp29_ = tmp;
	_tmp30_ = from;
	_tmp31_ = to;
	_tmp32_ = parser_convert (_tmp28_, _tmp29_, _tmp30_, _tmp31_);
	ans = _tmp32_;
	_tmp33_ = ans;
	if (_tmp33_ == NULL) {
		Parser* _tmp34_;
		_tmp34_ = ((ParseNode*) self)->parser;
		parser_set_error (_tmp34_, ERROR_CODE_UNKNOWN_CONVERSION, NULL, (guint) 0, (guint) 0);
	}
	result = ans;
	_number_unref0 (tmp);
	_g_free0 (to);
	_g_free0 (from);
	return result;
}


static void convert_number_node_class_init (ConvertNumberNodeClass * klass) {
	convert_number_node_parent_class = g_type_class_peek_parent (klass);
	PARSE_NODE_CLASS (klass)->solve = convert_number_node_real_solve;
}


static void convert_number_node_instance_init (ConvertNumberNode * self) {
}


GType convert_number_node_get_type (void) {
	static volatile gsize convert_number_node_type_id__volatile = 0;
	if (g_once_init_enter (&convert_number_node_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ConvertNumberNodeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) convert_number_node_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ConvertNumberNode), 0, (GInstanceInitFunc) convert_number_node_instance_init, NULL };
		GType convert_number_node_type_id;
		convert_number_node_type_id = g_type_register_static (TYPE_PARSE_NODE, "ConvertNumberNode", &g_define_type_info, 0);
		g_once_init_leave (&convert_number_node_type_id__volatile, convert_number_node_type_id);
	}
	return convert_number_node_type_id__volatile;
}


Parser* parser_construct (GType object_type, const gchar* input, gint number_base, gint wordlen) {
	Parser* self = NULL;
	const gchar* _tmp0_;
	gchar* _tmp1_;
	const gchar* _tmp2_;
	gint _tmp3_;
	Lexer* _tmp4_;
	gint _tmp5_;
	gint _tmp6_;
	gint _tmp7_;
	g_return_val_if_fail (input != NULL, NULL);
	self = (Parser*) g_type_create_instance (object_type);
	_tmp0_ = input;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->input);
	self->priv->input = _tmp1_;
	_tmp2_ = input;
	_tmp3_ = number_base;
	_tmp4_ = lexer_new (_tmp2_, self, _tmp3_);
	_lexer_unref0 (self->priv->lexer);
	self->priv->lexer = _tmp4_;
	_parse_node_unref0 (self->priv->root);
	self->priv->root = NULL;
	self->priv->depth_level = (guint) 0;
	_parse_node_unref0 (self->priv->right_most);
	self->priv->right_most = NULL;
	_tmp5_ = number_base;
	self->number_base = _tmp5_;
	_tmp6_ = number_base;
	self->priv->representation_base = (guint) _tmp6_;
	_tmp7_ = wordlen;
	self->wordlen = _tmp7_;
	self->priv->error = ERROR_CODE_NONE;
	_g_free0 (self->priv->error_token);
	self->priv->error_token = NULL;
	self->priv->error_token_start = 0;
	self->priv->error_token_end = 0;
	return self;
}


Parser* parser_new (const gchar* input, gint number_base, gint wordlen) {
	return parser_construct (TYPE_PARSER, input, number_base, wordlen);
}


void parser_set_error (Parser* self, ErrorCode errorno, const gchar* token, guint token_start, guint token_end) {
	ErrorCode _tmp0_;
	const gchar* _tmp1_;
	gchar* _tmp2_;
	const gchar* _tmp3_;
	guint _tmp4_;
	gint _tmp5_ = 0;
	const gchar* _tmp6_;
	guint _tmp7_;
	gint _tmp8_ = 0;
	g_return_if_fail (self != NULL);
	_tmp0_ = errorno;
	self->priv->error = _tmp0_;
	_tmp1_ = token;
	_tmp2_ = g_strdup (_tmp1_);
	_g_free0 (self->priv->error_token);
	self->priv->error_token = _tmp2_;
	_tmp3_ = self->priv->input;
	_tmp4_ = token_start;
	_tmp5_ = g_utf8_strlen (_tmp3_, (gssize) _tmp4_);
	self->priv->error_token_start = _tmp5_;
	_tmp6_ = self->priv->input;
	_tmp7_ = token_end;
	_tmp8_ = g_utf8_strlen (_tmp6_, (gssize) _tmp7_);
	self->priv->error_token_end = _tmp8_;
}


void parser_set_representation_base (Parser* self, guint new_base) {
	guint _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = new_base;
	self->priv->representation_base = _tmp0_;
}


static gboolean parser_real_variable_is_defined (Parser* self, const gchar* name) {
	gboolean result = FALSE;
	g_return_val_if_fail (name != NULL, FALSE);
	result = FALSE;
	return result;
}


gboolean parser_variable_is_defined (Parser* self, const gchar* name) {
	g_return_val_if_fail (self != NULL, FALSE);
	return PARSER_GET_CLASS (self)->variable_is_defined (self, name);
}


static Number* parser_real_get_variable (Parser* self, const gchar* name) {
	Number* result = NULL;
	g_return_val_if_fail (name != NULL, NULL);
	result = NULL;
	return result;
}


Number* parser_get_variable (Parser* self, const gchar* name) {
	g_return_val_if_fail (self != NULL, NULL);
	return PARSER_GET_CLASS (self)->get_variable (self, name);
}


static void parser_real_set_variable (Parser* self, const gchar* name, Number* x) {
	g_return_if_fail (name != NULL);
	g_return_if_fail (x != NULL);
}


void parser_set_variable (Parser* self, const gchar* name, Number* x) {
	g_return_if_fail (self != NULL);
	PARSER_GET_CLASS (self)->set_variable (self, name, x);
}


static gboolean parser_real_function_is_defined (Parser* self, const gchar* name) {
	gboolean result = FALSE;
	g_return_val_if_fail (name != NULL, FALSE);
	result = FALSE;
	return result;
}


gboolean parser_function_is_defined (Parser* self, const gchar* name) {
	g_return_val_if_fail (self != NULL, FALSE);
	return PARSER_GET_CLASS (self)->function_is_defined (self, name);
}


static Number* parser_real_get_function (Parser* self, const gchar* name, Number* x) {
	Number* result = NULL;
	g_return_val_if_fail (name != NULL, NULL);
	g_return_val_if_fail (x != NULL, NULL);
	result = NULL;
	return result;
}


Number* parser_get_function (Parser* self, const gchar* name, Number* x) {
	g_return_val_if_fail (self != NULL, NULL);
	return PARSER_GET_CLASS (self)->get_function (self, name, x);
}


static Number* parser_real_convert (Parser* self, Number* x, const gchar* x_units, const gchar* z_units) {
	Number* result = NULL;
	g_return_val_if_fail (x != NULL, NULL);
	g_return_val_if_fail (x_units != NULL, NULL);
	g_return_val_if_fail (z_units != NULL, NULL);
	result = NULL;
	return result;
}


Number* parser_convert (Parser* self, Number* x, const gchar* x_units, const gchar* z_units) {
	g_return_val_if_fail (self != NULL, NULL);
	return PARSER_GET_CLASS (self)->convert (self, x, x_units, z_units);
}


Number* parser_parse (Parser* self, guint* representation_base, ErrorCode* error_code, gchar** error_token, guint* error_start, guint* error_end) {
	guint _vala_representation_base = 0U;
	ErrorCode _vala_error_code = 0;
	gchar* _vala_error_token = NULL;
	guint _vala_error_start = 0U;
	guint _vala_error_end = 0U;
	Number* result = NULL;
	gint _tmp0_;
	Lexer* _tmp1_;
	gboolean _tmp2_ = FALSE;
	gboolean ret;
	Lexer* _tmp3_;
	LexerToken* _tmp4_ = NULL;
	LexerToken* token;
	LexerToken* _tmp5_;
	LexerTokenType _tmp6_;
	LexerToken* _tmp23_;
	LexerTokenType _tmp24_;
	gboolean _tmp37_;
	ParseNode* _tmp44_;
	Number* _tmp45_ = NULL;
	Number* ans;
	Number* _tmp46_;
	guint _tmp49_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->number_base;
	_vala_representation_base = (guint) _tmp0_;
	_tmp1_ = self->priv->lexer;
	lexer_scan (_tmp1_);
	_tmp2_ = parser_statement (self);
	ret = _tmp2_;
	_tmp3_ = self->priv->lexer;
	_tmp4_ = lexer_get_next_token (_tmp3_);
	token = _tmp4_;
	_tmp5_ = token;
	_tmp6_ = _tmp5_->type;
	if (_tmp6_ == LEXER_TOKEN_TYPE_ASSIGN) {
		Lexer* _tmp7_;
		LexerToken* _tmp8_ = NULL;
		LexerToken* _tmp9_;
		LexerTokenType _tmp10_;
		_tmp7_ = self->priv->lexer;
		_tmp8_ = lexer_get_next_token (_tmp7_);
		_lexer_token_unref0 (token);
		token = _tmp8_;
		_tmp9_ = token;
		_tmp10_ = _tmp9_->type;
		if (_tmp10_ != LEXER_TOKEN_TYPE_PL_EOS) {
			ErrorCode _tmp11_;
			ErrorCode _tmp18_;
			const gchar* _tmp19_;
			gchar* _tmp20_;
			gint _tmp21_;
			gint _tmp22_;
			_tmp11_ = self->priv->error;
			if (_tmp11_ == ERROR_CODE_NONE) {
				LexerToken* _tmp12_;
				const gchar* _tmp13_;
				LexerToken* _tmp14_;
				guint _tmp15_;
				LexerToken* _tmp16_;
				guint _tmp17_;
				_tmp12_ = token;
				_tmp13_ = _tmp12_->text;
				_tmp14_ = token;
				_tmp15_ = _tmp14_->start_index;
				_tmp16_ = token;
				_tmp17_ = _tmp16_->end_index;
				parser_set_error (self, ERROR_CODE_INVALID, _tmp13_, _tmp15_, _tmp17_);
			}
			_tmp18_ = self->priv->error;
			_vala_error_code = _tmp18_;
			_tmp19_ = self->priv->error_token;
			_tmp20_ = g_strdup (_tmp19_);
			_g_free0 (_vala_error_token);
			_vala_error_token = _tmp20_;
			_tmp21_ = self->priv->error_token_start;
			_vala_error_start = (guint) _tmp21_;
			_tmp22_ = self->priv->error_token_end;
			_vala_error_end = (guint) _tmp22_;
			result = NULL;
			_lexer_token_unref0 (token);
			if (representation_base) {
				*representation_base = _vala_representation_base;
			}
			if (error_code) {
				*error_code = _vala_error_code;
			}
			if (error_token) {
				*error_token = _vala_error_token;
			} else {
				_g_free0 (_vala_error_token);
			}
			if (error_start) {
				*error_start = _vala_error_start;
			}
			if (error_end) {
				*error_end = _vala_error_end;
			}
			return result;
		}
	}
	_tmp23_ = token;
	_tmp24_ = _tmp23_->type;
	if (_tmp24_ != LEXER_TOKEN_TYPE_PL_EOS) {
		ErrorCode _tmp25_;
		ErrorCode _tmp32_;
		const gchar* _tmp33_;
		gchar* _tmp34_;
		gint _tmp35_;
		gint _tmp36_;
		_tmp25_ = self->priv->error;
		if (_tmp25_ == ERROR_CODE_NONE) {
			LexerToken* _tmp26_;
			const gchar* _tmp27_;
			LexerToken* _tmp28_;
			guint _tmp29_;
			LexerToken* _tmp30_;
			guint _tmp31_;
			_tmp26_ = token;
			_tmp27_ = _tmp26_->text;
			_tmp28_ = token;
			_tmp29_ = _tmp28_->start_index;
			_tmp30_ = token;
			_tmp31_ = _tmp30_->end_index;
			parser_set_error (self, ERROR_CODE_INVALID, _tmp27_, _tmp29_, _tmp31_);
		}
		_tmp32_ = self->priv->error;
		_vala_error_code = _tmp32_;
		_tmp33_ = self->priv->error_token;
		_tmp34_ = g_strdup (_tmp33_);
		_g_free0 (_vala_error_token);
		_vala_error_token = _tmp34_;
		_tmp35_ = self->priv->error_token_start;
		_vala_error_start = (guint) _tmp35_;
		_tmp36_ = self->priv->error_token_end;
		_vala_error_end = (guint) _tmp36_;
		result = NULL;
		_lexer_token_unref0 (token);
		if (representation_base) {
			*representation_base = _vala_representation_base;
		}
		if (error_code) {
			*error_code = _vala_error_code;
		}
		if (error_token) {
			*error_token = _vala_error_token;
		} else {
			_g_free0 (_vala_error_token);
		}
		if (error_start) {
			*error_start = _vala_error_start;
		}
		if (error_end) {
			*error_end = _vala_error_end;
		}
		return result;
	}
	_tmp37_ = ret;
	if (!_tmp37_) {
		ErrorCode _tmp38_;
		ErrorCode _tmp39_;
		const gchar* _tmp40_;
		gchar* _tmp41_;
		gint _tmp42_;
		gint _tmp43_;
		_tmp38_ = self->priv->error;
		if (_tmp38_ == ERROR_CODE_NONE) {
			parser_set_error (self, ERROR_CODE_INVALID, NULL, (guint) 0, (guint) 0);
		}
		_tmp39_ = self->priv->error;
		_vala_error_code = _tmp39_;
		_tmp40_ = self->priv->error_token;
		_tmp41_ = g_strdup (_tmp40_);
		_g_free0 (_vala_error_token);
		_vala_error_token = _tmp41_;
		_tmp42_ = self->priv->error_token_start;
		_vala_error_start = (guint) _tmp42_;
		_tmp43_ = self->priv->error_token_end;
		_vala_error_end = (guint) _tmp43_;
		result = NULL;
		_lexer_token_unref0 (token);
		if (representation_base) {
			*representation_base = _vala_representation_base;
		}
		if (error_code) {
			*error_code = _vala_error_code;
		}
		if (error_token) {
			*error_token = _vala_error_token;
		} else {
			_g_free0 (_vala_error_token);
		}
		if (error_start) {
			*error_start = _vala_error_start;
		}
		if (error_end) {
			*error_end = _vala_error_end;
		}
		return result;
	}
	_tmp44_ = self->priv->root;
	_tmp45_ = parse_node_solve (_tmp44_);
	ans = _tmp45_;
	_tmp46_ = ans;
	if (_tmp46_ == NULL) {
		gint _tmp47_;
		gint _tmp48_;
		_vala_error_code = ERROR_CODE_INVALID;
		_g_free0 (_vala_error_token);
		_vala_error_token = NULL;
		_tmp47_ = self->priv->error_token_start;
		_vala_error_start = (guint) _tmp47_;
		_tmp48_ = self->priv->error_token_end;
		_vala_error_end = (guint) _tmp48_;
		result = NULL;
		_number_unref0 (ans);
		_lexer_token_unref0 (token);
		if (representation_base) {
			*representation_base = _vala_representation_base;
		}
		if (error_code) {
			*error_code = _vala_error_code;
		}
		if (error_token) {
			*error_token = _vala_error_token;
		} else {
			_g_free0 (_vala_error_token);
		}
		if (error_start) {
			*error_start = _vala_error_start;
		}
		if (error_end) {
			*error_end = _vala_error_end;
		}
		return result;
	}
	_tmp49_ = self->priv->representation_base;
	_vala_representation_base = _tmp49_;
	_vala_error_code = ERROR_CODE_NONE;
	_g_free0 (_vala_error_token);
	_vala_error_token = NULL;
	_vala_error_start = (guint) 0;
	_vala_error_end = (guint) 0;
	result = ans;
	_lexer_token_unref0 (token);
	if (representation_base) {
		*representation_base = _vala_representation_base;
	}
	if (error_code) {
		*error_code = _vala_error_code;
	}
	if (error_token) {
		*error_token = _vala_error_token;
	} else {
		_g_free0 (_vala_error_token);
	}
	if (error_start) {
		*error_start = _vala_error_start;
	}
	if (error_end) {
		*error_end = _vala_error_end;
	}
	return result;
}


static Precedence parser_get_precedence (Parser* self, LexerTokenType type) {
	Precedence result = 0;
	gboolean _tmp0_ = FALSE;
	LexerTokenType _tmp1_;
	gboolean _tmp3_;
	LexerTokenType _tmp4_;
	LexerTokenType _tmp5_;
	LexerTokenType _tmp6_;
	LexerTokenType _tmp7_;
	gboolean _tmp8_ = FALSE;
	gboolean _tmp9_ = FALSE;
	LexerTokenType _tmp10_;
	gboolean _tmp12_;
	gboolean _tmp14_;
	LexerTokenType _tmp15_;
	gboolean _tmp16_ = FALSE;
	gboolean _tmp17_ = FALSE;
	LexerTokenType _tmp18_;
	gboolean _tmp20_;
	gboolean _tmp22_;
	LexerTokenType _tmp23_;
	LexerTokenType _tmp24_;
	LexerTokenType _tmp25_;
	gboolean _tmp26_ = FALSE;
	LexerTokenType _tmp27_;
	gboolean _tmp29_;
	g_return_val_if_fail (self != NULL, 0);
	_tmp1_ = type;
	if (_tmp1_ == LEXER_TOKEN_TYPE_ADD) {
		_tmp0_ = TRUE;
	} else {
		LexerTokenType _tmp2_;
		_tmp2_ = type;
		_tmp0_ = _tmp2_ == LEXER_TOKEN_TYPE_SUBTRACT;
	}
	_tmp3_ = _tmp0_;
	if (_tmp3_) {
		result = PRECEDENCE_ADD_SUBTRACT;
		return result;
	}
	_tmp4_ = type;
	if (_tmp4_ == LEXER_TOKEN_TYPE_MULTIPLY) {
		result = PRECEDENCE_MULTIPLY;
		return result;
	}
	_tmp5_ = type;
	if (_tmp5_ == LEXER_TOKEN_TYPE_MOD) {
		result = PRECEDENCE_MOD;
		return result;
	}
	_tmp6_ = type;
	if (_tmp6_ == LEXER_TOKEN_TYPE_DIVIDE) {
		result = PRECEDENCE_DIVIDE;
		return result;
	}
	_tmp7_ = type;
	if (_tmp7_ == LEXER_TOKEN_TYPE_NOT) {
		result = PRECEDENCE_NOT;
		return result;
	}
	_tmp10_ = type;
	if (_tmp10_ == LEXER_TOKEN_TYPE_ROOT) {
		_tmp9_ = TRUE;
	} else {
		LexerTokenType _tmp11_;
		_tmp11_ = type;
		_tmp9_ = _tmp11_ == LEXER_TOKEN_TYPE_ROOT_3;
	}
	_tmp12_ = _tmp9_;
	if (_tmp12_) {
		_tmp8_ = TRUE;
	} else {
		LexerTokenType _tmp13_;
		_tmp13_ = type;
		_tmp8_ = _tmp13_ == LEXER_TOKEN_TYPE_ROOT_4;
	}
	_tmp14_ = _tmp8_;
	if (_tmp14_) {
		result = PRECEDENCE_ROOT;
		return result;
	}
	_tmp15_ = type;
	if (_tmp15_ == LEXER_TOKEN_TYPE_FUNCTION) {
		result = PRECEDENCE_FUNCTION;
		return result;
	}
	_tmp18_ = type;
	if (_tmp18_ == LEXER_TOKEN_TYPE_AND) {
		_tmp17_ = TRUE;
	} else {
		LexerTokenType _tmp19_;
		_tmp19_ = type;
		_tmp17_ = _tmp19_ == LEXER_TOKEN_TYPE_OR;
	}
	_tmp20_ = _tmp17_;
	if (_tmp20_) {
		_tmp16_ = TRUE;
	} else {
		LexerTokenType _tmp21_;
		_tmp21_ = type;
		_tmp16_ = _tmp21_ == LEXER_TOKEN_TYPE_XOR;
	}
	_tmp22_ = _tmp16_;
	if (_tmp22_) {
		result = PRECEDENCE_BOOLEAN;
		return result;
	}
	_tmp23_ = type;
	if (_tmp23_ == LEXER_TOKEN_TYPE_PERCENTAGE) {
		result = PRECEDENCE_PERCENTAGE;
		return result;
	}
	_tmp24_ = type;
	if (_tmp24_ == LEXER_TOKEN_TYPE_POWER) {
		result = PRECEDENCE_POWER;
		return result;
	}
	_tmp25_ = type;
	if (_tmp25_ == LEXER_TOKEN_TYPE_FACTORIAL) {
		result = PRECEDENCE_FACTORIAL;
		return result;
	}
	_tmp27_ = type;
	if (_tmp27_ == LEXER_TOKEN_TYPE_NUMBER) {
		_tmp26_ = TRUE;
	} else {
		LexerTokenType _tmp28_;
		_tmp28_ = type;
		_tmp26_ = _tmp28_ == LEXER_TOKEN_TYPE_VARIABLE;
	}
	_tmp29_ = _tmp26_;
	if (_tmp29_) {
		result = PRECEDENCE_NUMBER_VARIABLE;
		return result;
	}
	result = PRECEDENCE_UNKNOWN;
	return result;
}


static Associativity parser_get_associativity_p (Parser* self, Precedence type) {
	Associativity result = 0;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp2_ = FALSE;
	gboolean _tmp3_ = FALSE;
	Precedence _tmp4_;
	gboolean _tmp6_;
	gboolean _tmp8_;
	gboolean _tmp10_;
	gboolean _tmp12_;
	Precedence _tmp13_;
	g_return_val_if_fail (self != NULL, 0);
	_tmp4_ = type;
	if (_tmp4_ == PRECEDENCE_BOOLEAN) {
		_tmp3_ = TRUE;
	} else {
		Precedence _tmp5_;
		_tmp5_ = type;
		_tmp3_ = _tmp5_ == PRECEDENCE_DIVIDE;
	}
	_tmp6_ = _tmp3_;
	if (_tmp6_) {
		_tmp2_ = TRUE;
	} else {
		Precedence _tmp7_;
		_tmp7_ = type;
		_tmp2_ = _tmp7_ == PRECEDENCE_MOD;
	}
	_tmp8_ = _tmp2_;
	if (_tmp8_) {
		_tmp1_ = TRUE;
	} else {
		Precedence _tmp9_;
		_tmp9_ = type;
		_tmp1_ = _tmp9_ == PRECEDENCE_MULTIPLY;
	}
	_tmp10_ = _tmp1_;
	if (_tmp10_) {
		_tmp0_ = TRUE;
	} else {
		Precedence _tmp11_;
		_tmp11_ = type;
		_tmp0_ = _tmp11_ == PRECEDENCE_ADD_SUBTRACT;
	}
	_tmp12_ = _tmp0_;
	if (_tmp12_) {
		result = ASSOCIATIVITY_LEFT;
		return result;
	}
	_tmp13_ = type;
	if (_tmp13_ == PRECEDENCE_POWER) {
		result = ASSOCIATIVITY_RIGHT;
		return result;
	}
	result = ASSOCIATIVITY_LEFT;
	return result;
}


static Associativity parser_get_associativity (Parser* self, LexerToken* token) {
	Associativity result = 0;
	LexerToken* _tmp0_;
	LexerTokenType _tmp1_;
	Precedence _tmp2_ = 0;
	Associativity _tmp3_ = 0;
	g_return_val_if_fail (self != NULL, 0);
	g_return_val_if_fail (token != NULL, 0);
	_tmp0_ = token;
	_tmp1_ = _tmp0_->type;
	_tmp2_ = parser_get_precedence (self, _tmp1_);
	_tmp3_ = parser_get_associativity_p (self, _tmp2_);
	result = _tmp3_;
	return result;
}


static guint parser_make_precedence_p (Parser* self, Precedence p) {
	guint result = 0U;
	Precedence _tmp0_;
	guint _tmp1_;
	g_return_val_if_fail (self != NULL, 0U);
	_tmp0_ = p;
	_tmp1_ = self->priv->depth_level;
	result = _tmp0_ + (_tmp1_ * PRECEDENCE_DEPTH);
	return result;
}


static guint parser_make_precedence_t (Parser* self, LexerTokenType type) {
	guint result = 0U;
	LexerTokenType _tmp0_;
	Precedence _tmp1_ = 0;
	guint _tmp2_;
	g_return_val_if_fail (self != NULL, 0U);
	_tmp0_ = type;
	_tmp1_ = parser_get_precedence (self, _tmp0_);
	_tmp2_ = self->priv->depth_level;
	result = _tmp1_ + (_tmp2_ * PRECEDENCE_DEPTH);
	return result;
}


static gboolean parser_cmp_nodes (Parser* self, ParseNode* left, ParseNode* right) {
	gboolean result = FALSE;
	ParseNode* _tmp0_;
	ParseNode* _tmp1_;
	guint _tmp2_;
	ParseNode* _tmp3_;
	guint _tmp4_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = left;
	if (_tmp0_ == NULL) {
		result = FALSE;
		return result;
	}
	_tmp1_ = left;
	_tmp2_ = _tmp1_->precedence;
	_tmp3_ = right;
	_tmp4_ = _tmp3_->precedence;
	if (_tmp2_ > _tmp4_) {
		result = TRUE;
		return result;
	} else {
		ParseNode* _tmp5_;
		guint _tmp6_;
		ParseNode* _tmp7_;
		guint _tmp8_;
		_tmp5_ = left;
		_tmp6_ = _tmp5_->precedence;
		_tmp7_ = right;
		_tmp8_ = _tmp7_->precedence;
		if (_tmp6_ < _tmp8_) {
			result = FALSE;
			return result;
		} else {
			ParseNode* _tmp9_;
			Associativity _tmp10_;
			_tmp9_ = right;
			_tmp10_ = _tmp9_->associativity;
			result = _tmp10_ != ASSOCIATIVITY_RIGHT;
			return result;
		}
	}
}


static gpointer _parse_node_ref0 (gpointer self) {
	return self ? parse_node_ref (self) : NULL;
}


static void parser_insert_into_tree_all (Parser* self, ParseNode* node, gboolean unary_function) {
	ParseNode* _tmp0_;
	ParseNode* _tmp5_;
	ParseNode* _tmp6_;
	ParseNode* tmp;
	gboolean _tmp13_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (node != NULL);
	_tmp0_ = self->priv->root;
	if (_tmp0_ == NULL) {
		ParseNode* _tmp1_;
		ParseNode* _tmp2_;
		ParseNode* _tmp3_;
		ParseNode* _tmp4_;
		_tmp1_ = node;
		_tmp2_ = _parse_node_ref0 (_tmp1_);
		_parse_node_unref0 (self->priv->root);
		self->priv->root = _tmp2_;
		_tmp3_ = self->priv->root;
		_tmp4_ = _parse_node_ref0 (_tmp3_);
		_parse_node_unref0 (self->priv->right_most);
		self->priv->right_most = _tmp4_;
		return;
	}
	_tmp5_ = self->priv->right_most;
	_tmp6_ = _parse_node_ref0 (_tmp5_);
	tmp = _tmp6_;
	while (TRUE) {
		ParseNode* _tmp7_;
		ParseNode* _tmp8_;
		gboolean _tmp9_ = FALSE;
		ParseNode* _tmp10_;
		ParseNode* _tmp11_;
		ParseNode* _tmp12_;
		_tmp7_ = tmp;
		_tmp8_ = node;
		_tmp9_ = parser_cmp_nodes (self, _tmp7_, _tmp8_);
		if (!_tmp9_) {
			break;
		}
		_tmp10_ = tmp;
		_tmp11_ = _tmp10_->parent;
		_tmp12_ = _parse_node_ref0 (_tmp11_);
		_parse_node_unref0 (tmp);
		tmp = _tmp12_;
	}
	_tmp13_ = unary_function;
	if (_tmp13_) {
		ParseNode* _tmp14_;
		ParseNode* _tmp43_;
		ParseNode* _tmp44_;
		_tmp14_ = tmp;
		if (_tmp14_ == NULL) {
			ParseNode* _tmp15_;
			ParseNode* _tmp16_;
			ParseNode* _tmp17_;
			ParseNode* _tmp18_;
			ParseNode* _tmp19_;
			ParseNode* _tmp20_;
			ParseNode* _tmp21_;
			ParseNode* _tmp22_;
			ParseNode* _tmp23_;
			_tmp15_ = node;
			_tmp16_ = self->priv->root;
			_tmp17_ = _parse_node_ref0 (_tmp16_);
			_parse_node_unref0 (_tmp15_->right);
			_tmp15_->right = _tmp17_;
			_tmp18_ = node;
			_tmp19_ = _tmp18_->right;
			_tmp20_ = node;
			_tmp21_ = _parse_node_ref0 (_tmp20_);
			_parse_node_unref0 (_tmp19_->parent);
			_tmp19_->parent = _tmp21_;
			_tmp22_ = node;
			_tmp23_ = _parse_node_ref0 (_tmp22_);
			_parse_node_unref0 (self->priv->root);
			self->priv->root = _tmp23_;
		} else {
			ParseNode* _tmp24_;
			ParseNode* _tmp25_;
			ParseNode* _tmp26_;
			ParseNode* _tmp27_;
			ParseNode* _tmp28_;
			ParseNode* _tmp29_;
			ParseNode* _tmp34_;
			ParseNode* _tmp35_;
			ParseNode* _tmp36_;
			ParseNode* _tmp37_;
			ParseNode* _tmp38_;
			_tmp24_ = node;
			_tmp25_ = tmp;
			_tmp26_ = _tmp25_->right;
			_tmp27_ = _parse_node_ref0 (_tmp26_);
			_parse_node_unref0 (_tmp24_->right);
			_tmp24_->right = _tmp27_;
			_tmp28_ = node;
			_tmp29_ = _tmp28_->right;
			if (_tmp29_ != NULL) {
				ParseNode* _tmp30_;
				ParseNode* _tmp31_;
				ParseNode* _tmp32_;
				ParseNode* _tmp33_;
				_tmp30_ = node;
				_tmp31_ = _tmp30_->right;
				_tmp32_ = node;
				_tmp33_ = _parse_node_ref0 (_tmp32_);
				_parse_node_unref0 (_tmp31_->parent);
				_tmp31_->parent = _tmp33_;
			}
			_tmp34_ = tmp;
			_tmp35_ = node;
			_tmp36_ = _parse_node_ref0 (_tmp35_);
			_parse_node_unref0 (_tmp34_->right);
			_tmp34_->right = _tmp36_;
			_tmp37_ = tmp;
			_tmp38_ = _tmp37_->right;
			if (_tmp38_ != NULL) {
				ParseNode* _tmp39_;
				ParseNode* _tmp40_;
				ParseNode* _tmp41_;
				ParseNode* _tmp42_;
				_tmp39_ = tmp;
				_tmp40_ = _tmp39_->right;
				_tmp41_ = tmp;
				_tmp42_ = _parse_node_ref0 (_tmp41_);
				_parse_node_unref0 (_tmp40_->parent);
				_tmp40_->parent = _tmp42_;
			}
		}
		_tmp43_ = node;
		_tmp44_ = _parse_node_ref0 (_tmp43_);
		_parse_node_unref0 (self->priv->right_most);
		self->priv->right_most = _tmp44_;
		while (TRUE) {
			ParseNode* _tmp45_;
			ParseNode* _tmp46_;
			ParseNode* _tmp47_;
			ParseNode* _tmp48_;
			ParseNode* _tmp49_;
			_tmp45_ = self->priv->right_most;
			_tmp46_ = _tmp45_->right;
			if (!(_tmp46_ != NULL)) {
				break;
			}
			_tmp47_ = self->priv->right_most;
			_tmp48_ = _tmp47_->right;
			_tmp49_ = _parse_node_ref0 (_tmp48_);
			_parse_node_unref0 (self->priv->right_most);
			self->priv->right_most = _tmp49_;
		}
	} else {
		ParseNode* _tmp50_;
		ParseNode* _tmp79_;
		ParseNode* _tmp80_;
		_tmp50_ = tmp;
		if (_tmp50_ == NULL) {
			ParseNode* _tmp51_;
			ParseNode* _tmp52_;
			ParseNode* _tmp53_;
			ParseNode* _tmp54_;
			ParseNode* _tmp55_;
			ParseNode* _tmp56_;
			ParseNode* _tmp57_;
			ParseNode* _tmp58_;
			ParseNode* _tmp59_;
			_tmp51_ = node;
			_tmp52_ = self->priv->root;
			_tmp53_ = _parse_node_ref0 (_tmp52_);
			_parse_node_unref0 (_tmp51_->left);
			_tmp51_->left = _tmp53_;
			_tmp54_ = node;
			_tmp55_ = _tmp54_->left;
			_tmp56_ = node;
			_tmp57_ = _parse_node_ref0 (_tmp56_);
			_parse_node_unref0 (_tmp55_->parent);
			_tmp55_->parent = _tmp57_;
			_tmp58_ = node;
			_tmp59_ = _parse_node_ref0 (_tmp58_);
			_parse_node_unref0 (self->priv->root);
			self->priv->root = _tmp59_;
		} else {
			ParseNode* _tmp60_;
			ParseNode* _tmp61_;
			ParseNode* _tmp62_;
			ParseNode* _tmp63_;
			ParseNode* _tmp64_;
			ParseNode* _tmp65_;
			ParseNode* _tmp70_;
			ParseNode* _tmp71_;
			ParseNode* _tmp72_;
			ParseNode* _tmp73_;
			ParseNode* _tmp74_;
			_tmp60_ = node;
			_tmp61_ = tmp;
			_tmp62_ = _tmp61_->right;
			_tmp63_ = _parse_node_ref0 (_tmp62_);
			_parse_node_unref0 (_tmp60_->left);
			_tmp60_->left = _tmp63_;
			_tmp64_ = node;
			_tmp65_ = _tmp64_->left;
			if (_tmp65_ != NULL) {
				ParseNode* _tmp66_;
				ParseNode* _tmp67_;
				ParseNode* _tmp68_;
				ParseNode* _tmp69_;
				_tmp66_ = node;
				_tmp67_ = _tmp66_->left;
				_tmp68_ = node;
				_tmp69_ = _parse_node_ref0 (_tmp68_);
				_parse_node_unref0 (_tmp67_->parent);
				_tmp67_->parent = _tmp69_;
			}
			_tmp70_ = tmp;
			_tmp71_ = node;
			_tmp72_ = _parse_node_ref0 (_tmp71_);
			_parse_node_unref0 (_tmp70_->right);
			_tmp70_->right = _tmp72_;
			_tmp73_ = tmp;
			_tmp74_ = _tmp73_->right;
			if (_tmp74_ != NULL) {
				ParseNode* _tmp75_;
				ParseNode* _tmp76_;
				ParseNode* _tmp77_;
				ParseNode* _tmp78_;
				_tmp75_ = tmp;
				_tmp76_ = _tmp75_->right;
				_tmp77_ = tmp;
				_tmp78_ = _parse_node_ref0 (_tmp77_);
				_parse_node_unref0 (_tmp76_->parent);
				_tmp76_->parent = _tmp78_;
			}
		}
		_tmp79_ = node;
		_tmp80_ = _parse_node_ref0 (_tmp79_);
		_parse_node_unref0 (self->priv->right_most);
		self->priv->right_most = _tmp80_;
	}
	_parse_node_unref0 (tmp);
}


static void parser_insert_into_tree (Parser* self, ParseNode* node) {
	ParseNode* _tmp0_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (node != NULL);
	_tmp0_ = node;
	parser_insert_into_tree_all (self, _tmp0_, FALSE);
}


static void parser_insert_into_tree_unary (Parser* self, ParseNode* node) {
	ParseNode* _tmp0_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (node != NULL);
	_tmp0_ = node;
	parser_insert_into_tree_all (self, _tmp0_, TRUE);
}


static void parser_destroy_all_nodes (Parser* self, ParseNode* node) {
	ParseNode* _tmp0_;
	ParseNode* _tmp1_;
	ParseNode* _tmp2_;
	ParseNode* _tmp3_;
	ParseNode* _tmp4_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (node != NULL);
	_tmp0_ = node;
	if (_tmp0_ == NULL) {
		return;
	}
	_tmp1_ = node;
	_tmp2_ = _tmp1_->left;
	parser_destroy_all_nodes (self, _tmp2_);
	_tmp3_ = node;
	_tmp4_ = _tmp3_->right;
	parser_destroy_all_nodes (self, _tmp4_);
}


static gboolean parser_check_variable (Parser* self, const gchar* name) {
	gboolean result = FALSE;
	const gchar* _tmp0_;
	gboolean _tmp1_ = FALSE;
	gint index;
	gunichar c = 0U;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (name != NULL, FALSE);
	_tmp0_ = name;
	_tmp1_ = parser_variable_is_defined (self, _tmp0_);
	if (_tmp1_) {
		result = TRUE;
		return result;
	}
	index = 0;
	while (TRUE) {
		const gchar* _tmp2_;
		gunichar _tmp3_ = 0U;
		gboolean _tmp4_ = FALSE;
		gunichar _tmp5_;
		gchar* _tmp6_ = NULL;
		gchar* _tmp7_;
		gboolean _tmp8_ = FALSE;
		gboolean _tmp9_;
		_tmp2_ = name;
		_tmp4_ = string_get_next_char (_tmp2_, &index, &_tmp3_);
		c = _tmp3_;
		if (!_tmp4_) {
			break;
		}
		_tmp5_ = c;
		_tmp6_ = g_unichar_to_string (_tmp5_);
		_tmp7_ = _tmp6_;
		_tmp8_ = parser_variable_is_defined (self, _tmp7_);
		_tmp9_ = !_tmp8_;
		_g_free0 (_tmp7_);
		if (_tmp9_) {
			result = FALSE;
			return result;
		}
	}
	result = TRUE;
	return result;
}


static gboolean parser_statement (Parser* self) {
	gboolean result = FALSE;
	Lexer* _tmp0_;
	LexerToken* _tmp1_ = NULL;
	LexerToken* token;
	LexerToken* _tmp2_;
	LexerTokenType _tmp3_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->lexer;
	_tmp1_ = lexer_get_next_token (_tmp0_);
	token = _tmp1_;
	_tmp2_ = token;
	_tmp3_ = _tmp2_->type;
	if (_tmp3_ == LEXER_TOKEN_TYPE_VARIABLE) {
		LexerToken* _tmp4_;
		LexerToken* _tmp5_;
		LexerToken* token_old;
		Lexer* _tmp6_;
		LexerToken* _tmp7_ = NULL;
		LexerToken* _tmp8_;
		LexerTokenType _tmp9_;
		_tmp4_ = token;
		_tmp5_ = _lexer_token_ref0 (_tmp4_);
		token_old = _tmp5_;
		_tmp6_ = self->priv->lexer;
		_tmp7_ = lexer_get_next_token (_tmp6_);
		_lexer_token_unref0 (token);
		token = _tmp7_;
		_tmp8_ = token;
		_tmp9_ = _tmp8_->type;
		if (_tmp9_ == LEXER_TOKEN_TYPE_ASSIGN) {
			LexerToken* _tmp10_;
			guint _tmp11_ = 0U;
			LexerToken* _tmp12_;
			Associativity _tmp13_ = 0;
			NameNode* _tmp14_;
			NameNode* _tmp15_;
			LexerToken* _tmp16_;
			LexerToken* _tmp17_;
			Associativity _tmp18_ = 0;
			AssignNode* _tmp19_;
			AssignNode* _tmp20_;
			gboolean _tmp21_ = FALSE;
			_tmp10_ = token_old;
			_tmp11_ = parser_make_precedence_p (self, PRECEDENCE_NUMBER_VARIABLE);
			_tmp12_ = token_old;
			_tmp13_ = parser_get_associativity (self, _tmp12_);
			_tmp14_ = name_node_new (self, _tmp10_, _tmp11_, _tmp13_, NULL);
			_tmp15_ = _tmp14_;
			parser_insert_into_tree (self, (ParseNode*) _tmp15_);
			_parse_node_unref0 (_tmp15_);
			_tmp16_ = token;
			_tmp17_ = token;
			_tmp18_ = parser_get_associativity (self, _tmp17_);
			_tmp19_ = assign_node_new (self, _tmp16_, (guint) 0, _tmp18_);
			_tmp20_ = _tmp19_;
			parser_insert_into_tree (self, (ParseNode*) _tmp20_);
			_parse_node_unref0 (_tmp20_);
			_tmp21_ = parser_expression (self);
			if (!_tmp21_) {
				result = FALSE;
				_lexer_token_unref0 (token_old);
				_lexer_token_unref0 (token);
				return result;
			}
			result = TRUE;
			_lexer_token_unref0 (token_old);
			_lexer_token_unref0 (token);
			return result;
		} else {
			LexerToken* _tmp22_;
			LexerTokenType _tmp23_;
			_tmp22_ = token;
			_tmp23_ = _tmp22_->type;
			if (_tmp23_ == LEXER_TOKEN_TYPE_IN) {
				gboolean _tmp24_ = FALSE;
				_tmp24_ = parser_check_base (self);
				if (!_tmp24_) {
					Lexer* _tmp25_;
					Lexer* _tmp26_;
					gboolean _tmp27_ = FALSE;
					Lexer* _tmp28_;
					LexerToken* _tmp29_ = NULL;
					LexerToken* _tmp30_;
					LexerToken* _tmp31_;
					LexerToken* _tmp32_;
					Associativity _tmp33_ = 0;
					ConvertNode* _tmp34_;
					ConvertNode* _tmp35_;
					gboolean _tmp36_ = FALSE;
					_tmp25_ = self->priv->lexer;
					lexer_roll_back (_tmp25_);
					_tmp26_ = self->priv->lexer;
					lexer_roll_back (_tmp26_);
					_tmp27_ = parser_unit (self);
					if (!_tmp27_) {
						result = FALSE;
						_lexer_token_unref0 (token_old);
						_lexer_token_unref0 (token);
						return result;
					}
					_tmp28_ = self->priv->lexer;
					_tmp29_ = lexer_get_next_token (_tmp28_);
					_tmp30_ = _tmp29_;
					_lexer_token_unref0 (_tmp30_);
					_tmp31_ = token;
					_tmp32_ = token;
					_tmp33_ = parser_get_associativity (self, _tmp32_);
					_tmp34_ = convert_node_new (self, _tmp31_, (guint) 0, _tmp33_);
					_tmp35_ = _tmp34_;
					parser_insert_into_tree (self, (ParseNode*) _tmp35_);
					_parse_node_unref0 (_tmp35_);
					_tmp36_ = parser_unit (self);
					if (!_tmp36_) {
						result = FALSE;
						_lexer_token_unref0 (token_old);
						_lexer_token_unref0 (token);
						return result;
					}
					result = TRUE;
					_lexer_token_unref0 (token_old);
					_lexer_token_unref0 (token);
					return result;
				} else {
					Lexer* _tmp37_;
					LexerToken* _tmp38_ = NULL;
					LexerToken* _tmp39_;
					LexerTokenType _tmp40_;
					_tmp37_ = self->priv->lexer;
					_tmp38_ = lexer_get_next_token (_tmp37_);
					_lexer_token_unref0 (token);
					token = _tmp38_;
					_tmp39_ = token;
					_tmp40_ = _tmp39_->type;
					if (_tmp40_ == LEXER_TOKEN_TYPE_VARIABLE) {
						LexerToken* _tmp41_;
						LexerToken* _tmp42_;
						LexerTokenType _tmp43_;
						guint _tmp44_ = 0U;
						LexerToken* _tmp45_;
						Associativity _tmp46_ = 0;
						VariableNode* _tmp47_;
						VariableNode* _tmp48_;
						LexerToken* _tmp49_;
						LexerToken* _tmp50_;
						Associativity _tmp51_ = 0;
						LexerToken* _tmp52_;
						const gchar* _tmp53_;
						ConvertBaseNode* _tmp54_;
						ConvertBaseNode* _tmp55_;
						_tmp41_ = token_old;
						_tmp42_ = token_old;
						_tmp43_ = _tmp42_->type;
						_tmp44_ = parser_make_precedence_t (self, _tmp43_);
						_tmp45_ = token_old;
						_tmp46_ = parser_get_associativity (self, _tmp45_);
						_tmp47_ = variable_node_new (self, _tmp41_, _tmp44_, _tmp46_);
						_tmp48_ = _tmp47_;
						parser_insert_into_tree (self, (ParseNode*) _tmp48_);
						_parse_node_unref0 (_tmp48_);
						_tmp49_ = token;
						_tmp50_ = token;
						_tmp51_ = parser_get_associativity (self, _tmp50_);
						_tmp52_ = token;
						_tmp53_ = _tmp52_->text;
						_tmp54_ = convert_base_node_new (self, _tmp49_, (guint) 0, _tmp51_, _tmp53_);
						_tmp55_ = _tmp54_;
						parser_insert_into_tree (self, (ParseNode*) _tmp55_);
						_parse_node_unref0 (_tmp55_);
						result = TRUE;
						_lexer_token_unref0 (token_old);
						_lexer_token_unref0 (token);
						return result;
					} else {
						Lexer* _tmp56_;
						Lexer* _tmp57_;
						Lexer* _tmp58_;
						LexerToken* _tmp59_;
						const gchar* _tmp60_;
						LexerToken* _tmp61_;
						guint _tmp62_;
						LexerToken* _tmp63_;
						guint _tmp64_;
						_tmp56_ = self->priv->lexer;
						lexer_roll_back (_tmp56_);
						_tmp57_ = self->priv->lexer;
						lexer_roll_back (_tmp57_);
						_tmp58_ = self->priv->lexer;
						lexer_roll_back (_tmp58_);
						_tmp59_ = token;
						_tmp60_ = _tmp59_->text;
						_tmp61_ = token;
						_tmp62_ = _tmp61_->start_index;
						_tmp63_ = token;
						_tmp64_ = _tmp63_->end_index;
						parser_set_error (self, ERROR_CODE_UNKNOWN_CONVERSION, _tmp60_, _tmp62_, _tmp64_);
						result = FALSE;
						_lexer_token_unref0 (token_old);
						_lexer_token_unref0 (token);
						return result;
					}
				}
			} else {
				LexerToken* _tmp65_;
				LexerTokenType _tmp66_;
				_tmp65_ = token;
				_tmp66_ = _tmp65_->type;
				if (_tmp66_ == LEXER_TOKEN_TYPE_SUP_NUMBER) {
					Lexer* _tmp67_;
					LexerToken* _tmp68_ = NULL;
					LexerToken* _tmp69_;
					LexerTokenType _tmp70_;
					_tmp67_ = self->priv->lexer;
					_tmp68_ = lexer_get_next_token (_tmp67_);
					_lexer_token_unref0 (token);
					token = _tmp68_;
					_tmp69_ = token;
					_tmp70_ = _tmp69_->type;
					if (_tmp70_ == LEXER_TOKEN_TYPE_IN) {
						Lexer* _tmp71_;
						Lexer* _tmp72_;
						Lexer* _tmp73_;
						gboolean _tmp74_ = FALSE;
						Lexer* _tmp75_;
						LexerToken* _tmp76_ = NULL;
						LexerToken* _tmp77_;
						LexerToken* _tmp78_;
						LexerToken* _tmp79_;
						Associativity _tmp80_ = 0;
						ConvertNode* _tmp81_;
						ConvertNode* _tmp82_;
						gboolean _tmp83_ = FALSE;
						_tmp71_ = self->priv->lexer;
						lexer_roll_back (_tmp71_);
						_tmp72_ = self->priv->lexer;
						lexer_roll_back (_tmp72_);
						_tmp73_ = self->priv->lexer;
						lexer_roll_back (_tmp73_);
						_tmp74_ = parser_unit (self);
						if (!_tmp74_) {
							result = FALSE;
							_lexer_token_unref0 (token_old);
							_lexer_token_unref0 (token);
							return result;
						}
						_tmp75_ = self->priv->lexer;
						_tmp76_ = lexer_get_next_token (_tmp75_);
						_tmp77_ = _tmp76_;
						_lexer_token_unref0 (_tmp77_);
						_tmp78_ = token;
						_tmp79_ = token;
						_tmp80_ = parser_get_associativity (self, _tmp79_);
						_tmp81_ = convert_node_new (self, _tmp78_, (guint) 0, _tmp80_);
						_tmp82_ = _tmp81_;
						parser_insert_into_tree (self, (ParseNode*) _tmp82_);
						_parse_node_unref0 (_tmp82_);
						_tmp83_ = parser_unit (self);
						if (!_tmp83_) {
							result = FALSE;
							_lexer_token_unref0 (token_old);
							_lexer_token_unref0 (token);
							return result;
						}
						result = TRUE;
						_lexer_token_unref0 (token_old);
						_lexer_token_unref0 (token);
						return result;
					} else {
						Lexer* _tmp84_;
						Lexer* _tmp85_;
						Lexer* _tmp86_;
						gboolean _tmp87_ = FALSE;
						_tmp84_ = self->priv->lexer;
						lexer_roll_back (_tmp84_);
						_tmp85_ = self->priv->lexer;
						lexer_roll_back (_tmp85_);
						_tmp86_ = self->priv->lexer;
						lexer_roll_back (_tmp86_);
						_tmp87_ = parser_expression (self);
						if (!_tmp87_) {
							result = FALSE;
							_lexer_token_unref0 (token_old);
							_lexer_token_unref0 (token);
							return result;
						}
						result = TRUE;
						_lexer_token_unref0 (token_old);
						_lexer_token_unref0 (token);
						return result;
					}
				} else {
					Lexer* _tmp88_;
					Lexer* _tmp89_;
					gboolean _tmp90_ = FALSE;
					_tmp88_ = self->priv->lexer;
					lexer_roll_back (_tmp88_);
					_tmp89_ = self->priv->lexer;
					lexer_roll_back (_tmp89_);
					_tmp90_ = parser_expression (self);
					if (!_tmp90_) {
						result = FALSE;
						_lexer_token_unref0 (token_old);
						_lexer_token_unref0 (token);
						return result;
					}
					result = TRUE;
					_lexer_token_unref0 (token_old);
					_lexer_token_unref0 (token);
					return result;
				}
			}
		}
		_lexer_token_unref0 (token_old);
	} else {
		LexerToken* _tmp91_;
		LexerTokenType _tmp92_;
		_tmp91_ = token;
		_tmp92_ = _tmp91_->type;
		if (_tmp92_ == LEXER_TOKEN_TYPE_NUMBER) {
			LexerToken* _tmp93_;
			LexerToken* _tmp94_;
			LexerToken* token_old;
			Lexer* _tmp95_;
			LexerToken* _tmp96_ = NULL;
			LexerToken* _tmp97_;
			LexerTokenType _tmp98_;
			_tmp93_ = token;
			_tmp94_ = _lexer_token_ref0 (_tmp93_);
			token_old = _tmp94_;
			_tmp95_ = self->priv->lexer;
			_tmp96_ = lexer_get_next_token (_tmp95_);
			_lexer_token_unref0 (token);
			token = _tmp96_;
			_tmp97_ = token;
			_tmp98_ = _tmp97_->type;
			if (_tmp98_ == LEXER_TOKEN_TYPE_VARIABLE) {
				Lexer* _tmp99_;
				LexerToken* _tmp100_ = NULL;
				LexerToken* _tmp101_;
				LexerTokenType _tmp102_;
				_tmp99_ = self->priv->lexer;
				_tmp100_ = lexer_get_next_token (_tmp99_);
				_lexer_token_unref0 (token);
				token = _tmp100_;
				_tmp101_ = token;
				_tmp102_ = _tmp101_->type;
				if (_tmp102_ == LEXER_TOKEN_TYPE_IN) {
					Lexer* _tmp103_;
					Lexer* _tmp104_;
					LexerToken* _tmp105_;
					LexerToken* _tmp106_;
					LexerTokenType _tmp107_;
					guint _tmp108_ = 0U;
					LexerToken* _tmp109_;
					Associativity _tmp110_ = 0;
					ConstantNode* _tmp111_;
					ConstantNode* _tmp112_;
					gboolean _tmp113_ = FALSE;
					Lexer* _tmp114_;
					LexerToken* _tmp115_ = NULL;
					LexerToken* _tmp116_;
					LexerToken* _tmp117_;
					Associativity _tmp118_ = 0;
					ConvertNumberNode* _tmp119_;
					ConvertNumberNode* _tmp120_;
					gboolean _tmp121_ = FALSE;
					_tmp103_ = self->priv->lexer;
					lexer_roll_back (_tmp103_);
					_tmp104_ = self->priv->lexer;
					lexer_roll_back (_tmp104_);
					_tmp105_ = token_old;
					_tmp106_ = token_old;
					_tmp107_ = _tmp106_->type;
					_tmp108_ = parser_make_precedence_t (self, _tmp107_);
					_tmp109_ = token;
					_tmp110_ = parser_get_associativity (self, _tmp109_);
					_tmp111_ = constant_node_new (self, _tmp105_, _tmp108_, _tmp110_);
					_tmp112_ = _tmp111_;
					parser_insert_into_tree (self, (ParseNode*) _tmp112_);
					_parse_node_unref0 (_tmp112_);
					_tmp113_ = parser_unit (self);
					if (!_tmp113_) {
						result = FALSE;
						_lexer_token_unref0 (token_old);
						_lexer_token_unref0 (token);
						return result;
					}
					_tmp114_ = self->priv->lexer;
					_tmp115_ = lexer_get_next_token (_tmp114_);
					_lexer_token_unref0 (token);
					token = _tmp115_;
					_tmp116_ = token;
					_tmp117_ = token;
					_tmp118_ = parser_get_associativity (self, _tmp117_);
					_tmp119_ = convert_number_node_new (self, _tmp116_, (guint) 0, _tmp118_);
					_tmp120_ = _tmp119_;
					parser_insert_into_tree (self, (ParseNode*) _tmp120_);
					_parse_node_unref0 (_tmp120_);
					_tmp121_ = parser_unit (self);
					if (!_tmp121_) {
						result = FALSE;
						_lexer_token_unref0 (token_old);
						_lexer_token_unref0 (token);
						return result;
					}
					result = TRUE;
					_lexer_token_unref0 (token_old);
					_lexer_token_unref0 (token);
					return result;
				} else {
					LexerToken* _tmp122_;
					LexerTokenType _tmp123_;
					_tmp122_ = token;
					_tmp123_ = _tmp122_->type;
					if (_tmp123_ == LEXER_TOKEN_TYPE_SUP_NUMBER) {
						Lexer* _tmp124_;
						LexerToken* _tmp125_ = NULL;
						LexerToken* _tmp126_;
						LexerTokenType _tmp127_;
						_tmp124_ = self->priv->lexer;
						_tmp125_ = lexer_get_next_token (_tmp124_);
						_lexer_token_unref0 (token);
						token = _tmp125_;
						_tmp126_ = token;
						_tmp127_ = _tmp126_->type;
						if (_tmp127_ == LEXER_TOKEN_TYPE_IN) {
							Lexer* _tmp128_;
							Lexer* _tmp129_;
							Lexer* _tmp130_;
							LexerToken* _tmp131_;
							LexerToken* _tmp132_;
							LexerTokenType _tmp133_;
							guint _tmp134_ = 0U;
							LexerToken* _tmp135_;
							Associativity _tmp136_ = 0;
							ConstantNode* _tmp137_;
							ConstantNode* _tmp138_;
							gboolean _tmp139_ = FALSE;
							Lexer* _tmp140_;
							LexerToken* _tmp141_ = NULL;
							LexerToken* _tmp142_;
							LexerToken* _tmp143_;
							Associativity _tmp144_ = 0;
							ConvertNumberNode* _tmp145_;
							ConvertNumberNode* _tmp146_;
							gboolean _tmp147_ = FALSE;
							_tmp128_ = self->priv->lexer;
							lexer_roll_back (_tmp128_);
							_tmp129_ = self->priv->lexer;
							lexer_roll_back (_tmp129_);
							_tmp130_ = self->priv->lexer;
							lexer_roll_back (_tmp130_);
							_tmp131_ = token_old;
							_tmp132_ = token_old;
							_tmp133_ = _tmp132_->type;
							_tmp134_ = parser_make_precedence_t (self, _tmp133_);
							_tmp135_ = token;
							_tmp136_ = parser_get_associativity (self, _tmp135_);
							_tmp137_ = constant_node_new (self, _tmp131_, _tmp134_, _tmp136_);
							_tmp138_ = _tmp137_;
							parser_insert_into_tree (self, (ParseNode*) _tmp138_);
							_parse_node_unref0 (_tmp138_);
							_tmp139_ = parser_unit (self);
							if (!_tmp139_) {
								result = FALSE;
								_lexer_token_unref0 (token_old);
								_lexer_token_unref0 (token);
								return result;
							}
							_tmp140_ = self->priv->lexer;
							_tmp141_ = lexer_get_next_token (_tmp140_);
							_lexer_token_unref0 (token);
							token = _tmp141_;
							_tmp142_ = token;
							_tmp143_ = token;
							_tmp144_ = parser_get_associativity (self, _tmp143_);
							_tmp145_ = convert_number_node_new (self, _tmp142_, (guint) 0, _tmp144_);
							_tmp146_ = _tmp145_;
							parser_insert_into_tree (self, (ParseNode*) _tmp146_);
							_parse_node_unref0 (_tmp146_);
							_tmp147_ = parser_unit (self);
							if (!_tmp147_) {
								result = FALSE;
								_lexer_token_unref0 (token_old);
								_lexer_token_unref0 (token);
								return result;
							}
							result = TRUE;
							_lexer_token_unref0 (token_old);
							_lexer_token_unref0 (token);
							return result;
						} else {
							Lexer* _tmp148_;
							Lexer* _tmp149_;
							Lexer* _tmp150_;
							Lexer* _tmp151_;
							gboolean _tmp152_ = FALSE;
							_tmp148_ = self->priv->lexer;
							lexer_roll_back (_tmp148_);
							_tmp149_ = self->priv->lexer;
							lexer_roll_back (_tmp149_);
							_tmp150_ = self->priv->lexer;
							lexer_roll_back (_tmp150_);
							_tmp151_ = self->priv->lexer;
							lexer_roll_back (_tmp151_);
							_tmp152_ = parser_expression (self);
							if (!_tmp152_) {
								result = FALSE;
								_lexer_token_unref0 (token_old);
								_lexer_token_unref0 (token);
								return result;
							}
							result = TRUE;
							_lexer_token_unref0 (token_old);
							_lexer_token_unref0 (token);
							return result;
						}
					} else {
						Lexer* _tmp153_;
						Lexer* _tmp154_;
						Lexer* _tmp155_;
						gboolean _tmp156_ = FALSE;
						_tmp153_ = self->priv->lexer;
						lexer_roll_back (_tmp153_);
						_tmp154_ = self->priv->lexer;
						lexer_roll_back (_tmp154_);
						_tmp155_ = self->priv->lexer;
						lexer_roll_back (_tmp155_);
						_tmp156_ = parser_expression (self);
						if (!_tmp156_) {
							result = FALSE;
							_lexer_token_unref0 (token_old);
							_lexer_token_unref0 (token);
							return result;
						}
						result = TRUE;
						_lexer_token_unref0 (token_old);
						_lexer_token_unref0 (token);
						return result;
					}
				}
			} else {
				LexerToken* _tmp157_;
				LexerTokenType _tmp158_;
				_tmp157_ = token;
				_tmp158_ = _tmp157_->type;
				if (_tmp158_ == LEXER_TOKEN_TYPE_IN) {
					Lexer* _tmp159_;
					LexerToken* _tmp160_ = NULL;
					LexerToken* _tmp161_;
					LexerTokenType _tmp162_;
					_tmp159_ = self->priv->lexer;
					_tmp160_ = lexer_get_next_token (_tmp159_);
					_lexer_token_unref0 (token);
					token = _tmp160_;
					_tmp161_ = token;
					_tmp162_ = _tmp161_->type;
					if (_tmp162_ == LEXER_TOKEN_TYPE_VARIABLE) {
						LexerToken* _tmp163_;
						LexerToken* _tmp164_;
						LexerTokenType _tmp165_;
						guint _tmp166_ = 0U;
						LexerToken* _tmp167_;
						Associativity _tmp168_ = 0;
						ConstantNode* _tmp169_;
						ConstantNode* _tmp170_;
						LexerToken* _tmp171_;
						LexerToken* _tmp172_;
						Associativity _tmp173_ = 0;
						LexerToken* _tmp174_;
						const gchar* _tmp175_;
						ConvertBaseNode* _tmp176_;
						ConvertBaseNode* _tmp177_;
						_tmp163_ = token_old;
						_tmp164_ = token_old;
						_tmp165_ = _tmp164_->type;
						_tmp166_ = parser_make_precedence_t (self, _tmp165_);
						_tmp167_ = token;
						_tmp168_ = parser_get_associativity (self, _tmp167_);
						_tmp169_ = constant_node_new (self, _tmp163_, _tmp166_, _tmp168_);
						_tmp170_ = _tmp169_;
						parser_insert_into_tree (self, (ParseNode*) _tmp170_);
						_parse_node_unref0 (_tmp170_);
						_tmp171_ = token;
						_tmp172_ = token;
						_tmp173_ = parser_get_associativity (self, _tmp172_);
						_tmp174_ = token;
						_tmp175_ = _tmp174_->text;
						_tmp176_ = convert_base_node_new (self, _tmp171_, (guint) 0, _tmp173_, _tmp175_);
						_tmp177_ = _tmp176_;
						parser_insert_into_tree (self, (ParseNode*) _tmp177_);
						_parse_node_unref0 (_tmp177_);
						result = TRUE;
						_lexer_token_unref0 (token_old);
						_lexer_token_unref0 (token);
						return result;
					} else {
						Lexer* _tmp178_;
						Lexer* _tmp179_;
						Lexer* _tmp180_;
						LexerToken* _tmp181_;
						const gchar* _tmp182_;
						LexerToken* _tmp183_;
						guint _tmp184_;
						LexerToken* _tmp185_;
						guint _tmp186_;
						_tmp178_ = self->priv->lexer;
						lexer_roll_back (_tmp178_);
						_tmp179_ = self->priv->lexer;
						lexer_roll_back (_tmp179_);
						_tmp180_ = self->priv->lexer;
						lexer_roll_back (_tmp180_);
						_tmp181_ = token;
						_tmp182_ = _tmp181_->text;
						_tmp183_ = token;
						_tmp184_ = _tmp183_->start_index;
						_tmp185_ = token;
						_tmp186_ = _tmp185_->end_index;
						parser_set_error (self, ERROR_CODE_UNKNOWN_CONVERSION, _tmp182_, _tmp184_, _tmp186_);
						result = FALSE;
						_lexer_token_unref0 (token_old);
						_lexer_token_unref0 (token);
						return result;
					}
				} else {
					Lexer* _tmp187_;
					Lexer* _tmp188_;
					gboolean _tmp189_ = FALSE;
					_tmp187_ = self->priv->lexer;
					lexer_roll_back (_tmp187_);
					_tmp188_ = self->priv->lexer;
					lexer_roll_back (_tmp188_);
					_tmp189_ = parser_expression (self);
					if (!_tmp189_) {
						result = FALSE;
						_lexer_token_unref0 (token_old);
						_lexer_token_unref0 (token);
						return result;
					}
					result = TRUE;
					_lexer_token_unref0 (token_old);
					_lexer_token_unref0 (token);
					return result;
				}
			}
			_lexer_token_unref0 (token_old);
		} else {
			Lexer* _tmp190_;
			gboolean _tmp191_ = FALSE;
			_tmp190_ = self->priv->lexer;
			lexer_roll_back (_tmp190_);
			_tmp191_ = parser_expression (self);
			if (!_tmp191_) {
				result = FALSE;
				_lexer_token_unref0 (token);
				return result;
			}
			result = TRUE;
			_lexer_token_unref0 (token);
			return result;
		}
	}
	_lexer_token_unref0 (token);
}


static gboolean parser_check_base (Parser* self) {
	gboolean result = FALSE;
	Lexer* _tmp0_;
	LexerToken* _tmp1_ = NULL;
	LexerToken* token;
	gchar** _tmp2_;
	gchar** _tmp3_ = NULL;
	Lexer* _tmp9_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->lexer;
	_tmp1_ = lexer_get_next_token (_tmp0_);
	token = _tmp1_;
	_tmp3_ = _tmp2_ = g_strsplit ("hex,hexadecimal,dec,decimal,oct,octal,bin,binary", ",", 0);
	{
		gchar** s_collection = NULL;
		gint s_collection_length1 = 0;
		gint _s_collection_size_ = 0;
		gint s_it = 0;
		s_collection = _tmp3_;
		s_collection_length1 = _vala_array_length (_tmp2_);
		for (s_it = 0; s_it < _vala_array_length (_tmp2_); s_it = s_it + 1) {
			gchar* _tmp4_;
			gchar* s = NULL;
			_tmp4_ = g_strdup (s_collection[s_it]);
			s = _tmp4_;
			{
				LexerToken* _tmp5_;
				const gchar* _tmp6_;
				const gchar* _tmp7_;
				_tmp5_ = token;
				_tmp6_ = _tmp5_->text;
				_tmp7_ = s;
				if (g_strcmp0 (_tmp6_, _tmp7_) == 0) {
					Lexer* _tmp8_;
					_tmp8_ = self->priv->lexer;
					lexer_roll_back (_tmp8_);
					result = TRUE;
					_g_free0 (s);
					s_collection = (_vala_array_free (s_collection, s_collection_length1, (GDestroyNotify) g_free), NULL);
					_lexer_token_unref0 (token);
					return result;
				}
				_g_free0 (s);
			}
		}
		s_collection = (_vala_array_free (s_collection, s_collection_length1, (GDestroyNotify) g_free), NULL);
	}
	_tmp9_ = self->priv->lexer;
	lexer_roll_back (_tmp9_);
	result = FALSE;
	_lexer_token_unref0 (token);
	return result;
}


static gboolean parser_unit (Parser* self) {
	gboolean result = FALSE;
	Lexer* _tmp0_;
	LexerToken* _tmp1_ = NULL;
	LexerToken* token;
	LexerToken* _tmp2_;
	LexerTokenType _tmp3_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->lexer;
	_tmp1_ = lexer_get_next_token (_tmp0_);
	token = _tmp1_;
	_tmp2_ = token;
	_tmp3_ = _tmp2_->type;
	if (_tmp3_ == LEXER_TOKEN_TYPE_VARIABLE) {
		LexerToken* _tmp4_;
		LexerToken* _tmp5_;
		LexerToken* token_old;
		Lexer* _tmp6_;
		LexerToken* _tmp7_ = NULL;
		LexerToken* _tmp8_;
		LexerTokenType _tmp9_;
		_tmp4_ = token;
		_tmp5_ = _lexer_token_ref0 (_tmp4_);
		token_old = _tmp5_;
		_tmp6_ = self->priv->lexer;
		_tmp7_ = lexer_get_next_token (_tmp6_);
		_lexer_token_unref0 (token);
		token = _tmp7_;
		_tmp8_ = token;
		_tmp9_ = _tmp8_->type;
		if (_tmp9_ == LEXER_TOKEN_TYPE_SUP_NUMBER) {
			LexerToken* _tmp10_;
			LexerToken* _tmp11_;
			LexerTokenType _tmp12_;
			guint _tmp13_ = 0U;
			LexerToken* _tmp14_;
			Associativity _tmp15_ = 0;
			LexerToken* _tmp16_;
			const gchar* _tmp17_;
			LexerToken* _tmp18_;
			const gchar* _tmp19_;
			gchar* _tmp20_;
			gchar* _tmp21_;
			NameNode* _tmp22_;
			NameNode* _tmp23_;
			_tmp10_ = token_old;
			_tmp11_ = token_old;
			_tmp12_ = _tmp11_->type;
			_tmp13_ = parser_make_precedence_t (self, _tmp12_);
			_tmp14_ = token_old;
			_tmp15_ = parser_get_associativity (self, _tmp14_);
			_tmp16_ = token_old;
			_tmp17_ = _tmp16_->text;
			_tmp18_ = token;
			_tmp19_ = _tmp18_->text;
			_tmp20_ = g_strconcat (_tmp17_, _tmp19_, NULL);
			_tmp21_ = _tmp20_;
			_tmp22_ = name_node_new (self, _tmp10_, _tmp13_, _tmp15_, _tmp21_);
			_tmp23_ = _tmp22_;
			parser_insert_into_tree (self, (ParseNode*) _tmp23_);
			_parse_node_unref0 (_tmp23_);
			_g_free0 (_tmp21_);
			result = TRUE;
			_lexer_token_unref0 (token_old);
			_lexer_token_unref0 (token);
			return result;
		} else {
			Lexer* _tmp24_;
			LexerToken* _tmp25_;
			LexerToken* _tmp26_;
			LexerTokenType _tmp27_;
			guint _tmp28_ = 0U;
			LexerToken* _tmp29_;
			Associativity _tmp30_ = 0;
			NameNode* _tmp31_;
			NameNode* _tmp32_;
			_tmp24_ = self->priv->lexer;
			lexer_roll_back (_tmp24_);
			_tmp25_ = token_old;
			_tmp26_ = token_old;
			_tmp27_ = _tmp26_->type;
			_tmp28_ = parser_make_precedence_t (self, _tmp27_);
			_tmp29_ = token_old;
			_tmp30_ = parser_get_associativity (self, _tmp29_);
			_tmp31_ = name_node_new (self, _tmp25_, _tmp28_, _tmp30_, NULL);
			_tmp32_ = _tmp31_;
			parser_insert_into_tree (self, (ParseNode*) _tmp32_);
			_parse_node_unref0 (_tmp32_);
			result = TRUE;
			_lexer_token_unref0 (token_old);
			_lexer_token_unref0 (token);
			return result;
		}
		_lexer_token_unref0 (token_old);
	} else {
		Lexer* _tmp33_;
		_tmp33_ = self->priv->lexer;
		lexer_roll_back (_tmp33_);
		result = FALSE;
		_lexer_token_unref0 (token);
		return result;
	}
	_lexer_token_unref0 (token);
}


static gboolean parser_expression (Parser* self) {
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = parser_expression_1 (self);
	if (!_tmp0_) {
		result = FALSE;
		return result;
	}
	_tmp1_ = parser_expression_2 (self);
	if (!_tmp1_) {
		result = FALSE;
		return result;
	}
	result = TRUE;
	return result;
}


static gboolean parser_expression_1 (Parser* self) {
	gboolean result = FALSE;
	Lexer* _tmp0_;
	LexerToken* _tmp1_ = NULL;
	LexerToken* token;
	gboolean _tmp2_ = FALSE;
	LexerToken* _tmp3_;
	LexerTokenType _tmp4_;
	gboolean _tmp7_;
	LexerToken* _tmp9_;
	LexerTokenType _tmp10_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->lexer;
	_tmp1_ = lexer_get_next_token (_tmp0_);
	token = _tmp1_;
	_tmp3_ = token;
	_tmp4_ = _tmp3_->type;
	if (_tmp4_ == LEXER_TOKEN_TYPE_PL_EOS) {
		_tmp2_ = TRUE;
	} else {
		LexerToken* _tmp5_;
		LexerTokenType _tmp6_;
		_tmp5_ = token;
		_tmp6_ = _tmp5_->type;
		_tmp2_ = _tmp6_ == LEXER_TOKEN_TYPE_ASSIGN;
	}
	_tmp7_ = _tmp2_;
	if (_tmp7_) {
		Lexer* _tmp8_;
		_tmp8_ = self->priv->lexer;
		lexer_roll_back (_tmp8_);
		result = FALSE;
		_lexer_token_unref0 (token);
		return result;
	}
	_tmp9_ = token;
	_tmp10_ = _tmp9_->type;
	if (_tmp10_ == LEXER_TOKEN_TYPE_L_R_BRACKET) {
		guint _tmp11_;
		gboolean _tmp12_ = FALSE;
		Lexer* _tmp13_;
		LexerToken* _tmp14_ = NULL;
		LexerToken* _tmp15_;
		LexerTokenType _tmp16_;
		_tmp11_ = self->priv->depth_level;
		self->priv->depth_level = _tmp11_ + 1;
		_tmp12_ = parser_expression (self);
		if (!_tmp12_) {
			result = FALSE;
			_lexer_token_unref0 (token);
			return result;
		}
		_tmp13_ = self->priv->lexer;
		_tmp14_ = lexer_get_next_token (_tmp13_);
		_lexer_token_unref0 (token);
		token = _tmp14_;
		_tmp15_ = token;
		_tmp16_ = _tmp15_->type;
		if (_tmp16_ == LEXER_TOKEN_TYPE_R_R_BRACKET) {
			guint _tmp17_;
			_tmp17_ = self->priv->depth_level;
			self->priv->depth_level = _tmp17_ - 1;
			result = TRUE;
			_lexer_token_unref0 (token);
			return result;
		} else {
			result = FALSE;
			_lexer_token_unref0 (token);
			return result;
		}
	} else {
		LexerToken* _tmp18_;
		LexerTokenType _tmp19_;
		_tmp18_ = token;
		_tmp19_ = _tmp18_->type;
		if (_tmp19_ == LEXER_TOKEN_TYPE_L_S_BRACKET) {
			guint _tmp20_;
			LexerToken* _tmp21_;
			guint _tmp22_ = 0U;
			LexerToken* _tmp23_;
			Associativity _tmp24_ = 0;
			RoundNode* _tmp25_;
			RoundNode* _tmp26_;
			gboolean _tmp27_ = FALSE;
			Lexer* _tmp28_;
			LexerToken* _tmp29_ = NULL;
			LexerToken* _tmp30_;
			LexerTokenType _tmp31_;
			_tmp20_ = self->priv->depth_level;
			self->priv->depth_level = _tmp20_ + 1;
			_tmp21_ = token;
			_tmp22_ = parser_make_precedence_p (self, PRECEDENCE_UNKNOWN);
			_tmp23_ = token;
			_tmp24_ = parser_get_associativity (self, _tmp23_);
			_tmp25_ = round_node_new (self, _tmp21_, _tmp22_, _tmp24_);
			_tmp26_ = _tmp25_;
			parser_insert_into_tree_unary (self, (ParseNode*) _tmp26_);
			_parse_node_unref0 (_tmp26_);
			_tmp27_ = parser_expression (self);
			if (!_tmp27_) {
				result = FALSE;
				_lexer_token_unref0 (token);
				return result;
			}
			_tmp28_ = self->priv->lexer;
			_tmp29_ = lexer_get_next_token (_tmp28_);
			_lexer_token_unref0 (token);
			token = _tmp29_;
			_tmp30_ = token;
			_tmp31_ = _tmp30_->type;
			if (_tmp31_ == LEXER_TOKEN_TYPE_R_S_BRACKET) {
				guint _tmp32_;
				_tmp32_ = self->priv->depth_level;
				self->priv->depth_level = _tmp32_ - 1;
				result = TRUE;
				_lexer_token_unref0 (token);
				return result;
			} else {
				result = FALSE;
				_lexer_token_unref0 (token);
				return result;
			}
		} else {
			LexerToken* _tmp33_;
			LexerTokenType _tmp34_;
			_tmp33_ = token;
			_tmp34_ = _tmp33_->type;
			if (_tmp34_ == LEXER_TOKEN_TYPE_L_C_BRACKET) {
				guint _tmp35_;
				LexerToken* _tmp36_;
				guint _tmp37_ = 0U;
				LexerToken* _tmp38_;
				Associativity _tmp39_ = 0;
				FractionalComponentNode* _tmp40_;
				FractionalComponentNode* _tmp41_;
				gboolean _tmp42_ = FALSE;
				Lexer* _tmp43_;
				LexerToken* _tmp44_ = NULL;
				LexerToken* _tmp45_;
				LexerTokenType _tmp46_;
				_tmp35_ = self->priv->depth_level;
				self->priv->depth_level = _tmp35_ + 1;
				_tmp36_ = token;
				_tmp37_ = parser_make_precedence_p (self, PRECEDENCE_UNKNOWN);
				_tmp38_ = token;
				_tmp39_ = parser_get_associativity (self, _tmp38_);
				_tmp40_ = fractional_component_node_new (self, _tmp36_, _tmp37_, _tmp39_);
				_tmp41_ = _tmp40_;
				parser_insert_into_tree_unary (self, (ParseNode*) _tmp41_);
				_parse_node_unref0 (_tmp41_);
				_tmp42_ = parser_expression (self);
				if (!_tmp42_) {
					result = FALSE;
					_lexer_token_unref0 (token);
					return result;
				}
				_tmp43_ = self->priv->lexer;
				_tmp44_ = lexer_get_next_token (_tmp43_);
				_lexer_token_unref0 (token);
				token = _tmp44_;
				_tmp45_ = token;
				_tmp46_ = _tmp45_->type;
				if (_tmp46_ == LEXER_TOKEN_TYPE_R_C_BRACKET) {
					guint _tmp47_;
					_tmp47_ = self->priv->depth_level;
					self->priv->depth_level = _tmp47_ - 1;
					result = TRUE;
					_lexer_token_unref0 (token);
					return result;
				} else {
					result = FALSE;
					_lexer_token_unref0 (token);
					return result;
				}
			} else {
				LexerToken* _tmp48_;
				LexerTokenType _tmp49_;
				_tmp48_ = token;
				_tmp49_ = _tmp48_->type;
				if (_tmp49_ == LEXER_TOKEN_TYPE_ABS) {
					guint _tmp50_;
					LexerToken* _tmp51_;
					guint _tmp52_ = 0U;
					LexerToken* _tmp53_;
					Associativity _tmp54_ = 0;
					AbsoluteValueNode* _tmp55_;
					AbsoluteValueNode* _tmp56_;
					gboolean _tmp57_ = FALSE;
					Lexer* _tmp58_;
					LexerToken* _tmp59_ = NULL;
					LexerToken* _tmp60_;
					LexerTokenType _tmp61_;
					_tmp50_ = self->priv->depth_level;
					self->priv->depth_level = _tmp50_ + 1;
					_tmp51_ = token;
					_tmp52_ = parser_make_precedence_p (self, PRECEDENCE_UNKNOWN);
					_tmp53_ = token;
					_tmp54_ = parser_get_associativity (self, _tmp53_);
					_tmp55_ = absolute_value_node_new (self, _tmp51_, _tmp52_, _tmp54_);
					_tmp56_ = _tmp55_;
					parser_insert_into_tree_unary (self, (ParseNode*) _tmp56_);
					_parse_node_unref0 (_tmp56_);
					_tmp57_ = parser_expression (self);
					if (!_tmp57_) {
						result = FALSE;
						_lexer_token_unref0 (token);
						return result;
					}
					_tmp58_ = self->priv->lexer;
					_tmp59_ = lexer_get_next_token (_tmp58_);
					_lexer_token_unref0 (token);
					token = _tmp59_;
					_tmp60_ = token;
					_tmp61_ = _tmp60_->type;
					if (_tmp61_ == LEXER_TOKEN_TYPE_ABS) {
						guint _tmp62_;
						_tmp62_ = self->priv->depth_level;
						self->priv->depth_level = _tmp62_ - 1;
						result = TRUE;
						_lexer_token_unref0 (token);
						return result;
					} else {
						result = FALSE;
						_lexer_token_unref0 (token);
						return result;
					}
				} else {
					LexerToken* _tmp63_;
					LexerTokenType _tmp64_;
					_tmp63_ = token;
					_tmp64_ = _tmp63_->type;
					if (_tmp64_ == LEXER_TOKEN_TYPE_NOT) {
						LexerToken* _tmp65_;
						guint _tmp66_ = 0U;
						LexerToken* _tmp67_;
						Associativity _tmp68_ = 0;
						NotNode* _tmp69_;
						NotNode* _tmp70_;
						gboolean _tmp71_ = FALSE;
						_tmp65_ = token;
						_tmp66_ = parser_make_precedence_p (self, PRECEDENCE_NOT);
						_tmp67_ = token;
						_tmp68_ = parser_get_associativity (self, _tmp67_);
						_tmp69_ = not_node_new (self, _tmp65_, _tmp66_, _tmp68_);
						_tmp70_ = _tmp69_;
						parser_insert_into_tree_unary (self, (ParseNode*) _tmp70_);
						_parse_node_unref0 (_tmp70_);
						_tmp71_ = parser_expression (self);
						if (!_tmp71_) {
							result = FALSE;
							_lexer_token_unref0 (token);
							return result;
						}
						result = TRUE;
						_lexer_token_unref0 (token);
						return result;
					} else {
						LexerToken* _tmp72_;
						LexerTokenType _tmp73_;
						_tmp72_ = token;
						_tmp73_ = _tmp72_->type;
						if (_tmp73_ == LEXER_TOKEN_TYPE_NUMBER) {
							LexerToken* _tmp74_;
							LexerToken* _tmp75_;
							LexerTokenType _tmp76_;
							guint _tmp77_ = 0U;
							LexerToken* _tmp78_;
							Associativity _tmp79_ = 0;
							ConstantNode* _tmp80_;
							ConstantNode* _tmp81_;
							Lexer* _tmp82_;
							LexerToken* _tmp83_ = NULL;
							Lexer* _tmp84_;
							gboolean _tmp85_ = FALSE;
							gboolean _tmp86_ = FALSE;
							gboolean _tmp87_ = FALSE;
							gboolean _tmp88_ = FALSE;
							gboolean _tmp89_ = FALSE;
							LexerToken* _tmp90_;
							LexerTokenType _tmp91_;
							gboolean _tmp94_;
							gboolean _tmp97_;
							gboolean _tmp100_;
							gboolean _tmp103_;
							gboolean _tmp106_;
							_tmp74_ = token;
							_tmp75_ = token;
							_tmp76_ = _tmp75_->type;
							_tmp77_ = parser_make_precedence_t (self, _tmp76_);
							_tmp78_ = token;
							_tmp79_ = parser_get_associativity (self, _tmp78_);
							_tmp80_ = constant_node_new (self, _tmp74_, _tmp77_, _tmp79_);
							_tmp81_ = _tmp80_;
							parser_insert_into_tree (self, (ParseNode*) _tmp81_);
							_parse_node_unref0 (_tmp81_);
							_tmp82_ = self->priv->lexer;
							_tmp83_ = lexer_get_next_token (_tmp82_);
							_lexer_token_unref0 (token);
							token = _tmp83_;
							_tmp84_ = self->priv->lexer;
							lexer_roll_back (_tmp84_);
							_tmp90_ = token;
							_tmp91_ = _tmp90_->type;
							if (_tmp91_ == LEXER_TOKEN_TYPE_FUNCTION) {
								_tmp89_ = TRUE;
							} else {
								LexerToken* _tmp92_;
								LexerTokenType _tmp93_;
								_tmp92_ = token;
								_tmp93_ = _tmp92_->type;
								_tmp89_ = _tmp93_ == LEXER_TOKEN_TYPE_VARIABLE;
							}
							_tmp94_ = _tmp89_;
							if (_tmp94_) {
								_tmp88_ = TRUE;
							} else {
								LexerToken* _tmp95_;
								LexerTokenType _tmp96_;
								_tmp95_ = token;
								_tmp96_ = _tmp95_->type;
								_tmp88_ = _tmp96_ == LEXER_TOKEN_TYPE_SUB_NUMBER;
							}
							_tmp97_ = _tmp88_;
							if (_tmp97_) {
								_tmp87_ = TRUE;
							} else {
								LexerToken* _tmp98_;
								LexerTokenType _tmp99_;
								_tmp98_ = token;
								_tmp99_ = _tmp98_->type;
								_tmp87_ = _tmp99_ == LEXER_TOKEN_TYPE_ROOT;
							}
							_tmp100_ = _tmp87_;
							if (_tmp100_) {
								_tmp86_ = TRUE;
							} else {
								LexerToken* _tmp101_;
								LexerTokenType _tmp102_;
								_tmp101_ = token;
								_tmp102_ = _tmp101_->type;
								_tmp86_ = _tmp102_ == LEXER_TOKEN_TYPE_ROOT_3;
							}
							_tmp103_ = _tmp86_;
							if (_tmp103_) {
								_tmp85_ = TRUE;
							} else {
								LexerToken* _tmp104_;
								LexerTokenType _tmp105_;
								_tmp104_ = token;
								_tmp105_ = _tmp104_->type;
								_tmp85_ = _tmp105_ == LEXER_TOKEN_TYPE_ROOT_4;
							}
							_tmp106_ = _tmp85_;
							if (_tmp106_) {
								guint _tmp107_ = 0U;
								Associativity _tmp108_ = 0;
								MultiplyNode* _tmp109_;
								MultiplyNode* _tmp110_;
								gboolean _tmp111_ = FALSE;
								_tmp107_ = parser_make_precedence_p (self, PRECEDENCE_MULTIPLY);
								_tmp108_ = parser_get_associativity_p (self, PRECEDENCE_MULTIPLY);
								_tmp109_ = multiply_node_new (self, NULL, _tmp107_, _tmp108_);
								_tmp110_ = _tmp109_;
								parser_insert_into_tree (self, (ParseNode*) _tmp110_);
								_parse_node_unref0 (_tmp110_);
								_tmp111_ = parser_variable (self);
								if (!_tmp111_) {
									result = FALSE;
									_lexer_token_unref0 (token);
									return result;
								} else {
									result = TRUE;
									_lexer_token_unref0 (token);
									return result;
								}
							} else {
								result = TRUE;
								_lexer_token_unref0 (token);
								return result;
							}
						} else {
							LexerToken* _tmp112_;
							LexerTokenType _tmp113_;
							_tmp112_ = token;
							_tmp113_ = _tmp112_->type;
							if (_tmp113_ == LEXER_TOKEN_TYPE_L_FLOOR) {
								guint _tmp114_;
								guint _tmp115_ = 0U;
								Associativity _tmp116_ = 0;
								FloorNode* _tmp117_;
								FloorNode* _tmp118_;
								gboolean _tmp119_ = FALSE;
								Lexer* _tmp120_;
								LexerToken* _tmp121_ = NULL;
								LexerToken* _tmp122_;
								LexerTokenType _tmp123_;
								_tmp114_ = self->priv->depth_level;
								self->priv->depth_level = _tmp114_ + 1;
								_tmp115_ = parser_make_precedence_p (self, PRECEDENCE_UNKNOWN);
								_tmp116_ = parser_get_associativity_p (self, PRECEDENCE_UNKNOWN);
								_tmp117_ = floor_node_new (self, NULL, _tmp115_, _tmp116_);
								_tmp118_ = _tmp117_;
								parser_insert_into_tree_unary (self, (ParseNode*) _tmp118_);
								_parse_node_unref0 (_tmp118_);
								_tmp119_ = parser_expression (self);
								if (!_tmp119_) {
									result = FALSE;
									_lexer_token_unref0 (token);
									return result;
								}
								_tmp120_ = self->priv->lexer;
								_tmp121_ = lexer_get_next_token (_tmp120_);
								_lexer_token_unref0 (token);
								token = _tmp121_;
								_tmp122_ = token;
								_tmp123_ = _tmp122_->type;
								if (_tmp123_ == LEXER_TOKEN_TYPE_R_FLOOR) {
									guint _tmp124_;
									_tmp124_ = self->priv->depth_level;
									self->priv->depth_level = _tmp124_ - 1;
									result = TRUE;
									_lexer_token_unref0 (token);
									return result;
								} else {
									result = FALSE;
									_lexer_token_unref0 (token);
									return result;
								}
							} else {
								LexerToken* _tmp125_;
								LexerTokenType _tmp126_;
								_tmp125_ = token;
								_tmp126_ = _tmp125_->type;
								if (_tmp126_ == LEXER_TOKEN_TYPE_L_CEILING) {
									guint _tmp127_;
									guint _tmp128_ = 0U;
									Associativity _tmp129_ = 0;
									CeilingNode* _tmp130_;
									CeilingNode* _tmp131_;
									gboolean _tmp132_ = FALSE;
									Lexer* _tmp133_;
									LexerToken* _tmp134_ = NULL;
									LexerToken* _tmp135_;
									LexerTokenType _tmp136_;
									_tmp127_ = self->priv->depth_level;
									self->priv->depth_level = _tmp127_ + 1;
									_tmp128_ = parser_make_precedence_p (self, PRECEDENCE_UNKNOWN);
									_tmp129_ = parser_get_associativity_p (self, PRECEDENCE_UNKNOWN);
									_tmp130_ = ceiling_node_new (self, NULL, _tmp128_, _tmp129_);
									_tmp131_ = _tmp130_;
									parser_insert_into_tree_unary (self, (ParseNode*) _tmp131_);
									_parse_node_unref0 (_tmp131_);
									_tmp132_ = parser_expression (self);
									if (!_tmp132_) {
										result = FALSE;
										_lexer_token_unref0 (token);
										return result;
									}
									_tmp133_ = self->priv->lexer;
									_tmp134_ = lexer_get_next_token (_tmp133_);
									_lexer_token_unref0 (token);
									token = _tmp134_;
									_tmp135_ = token;
									_tmp136_ = _tmp135_->type;
									if (_tmp136_ == LEXER_TOKEN_TYPE_R_CEILING) {
										guint _tmp137_;
										_tmp137_ = self->priv->depth_level;
										self->priv->depth_level = _tmp137_ - 1;
										result = TRUE;
										_lexer_token_unref0 (token);
										return result;
									} else {
										result = FALSE;
										_lexer_token_unref0 (token);
										return result;
									}
								} else {
									LexerToken* _tmp138_;
									LexerTokenType _tmp139_;
									_tmp138_ = token;
									_tmp139_ = _tmp138_->type;
									if (_tmp139_ == LEXER_TOKEN_TYPE_SUBTRACT) {
										LexerToken* _tmp140_;
										guint _tmp141_ = 0U;
										Associativity _tmp142_ = 0;
										UnaryMinusNode* _tmp143_;
										UnaryMinusNode* _tmp144_;
										gboolean _tmp145_ = FALSE;
										_tmp140_ = token;
										_tmp141_ = parser_make_precedence_p (self, PRECEDENCE_UNARY_MINUS);
										_tmp142_ = parser_get_associativity_p (self, PRECEDENCE_UNARY_MINUS);
										_tmp143_ = unary_minus_node_new (self, _tmp140_, _tmp141_, _tmp142_);
										_tmp144_ = _tmp143_;
										parser_insert_into_tree_unary (self, (ParseNode*) _tmp144_);
										_parse_node_unref0 (_tmp144_);
										_tmp145_ = parser_expression_1 (self);
										if (!_tmp145_) {
											result = FALSE;
											_lexer_token_unref0 (token);
											return result;
										}
										result = TRUE;
										_lexer_token_unref0 (token);
										return result;
									} else {
										LexerToken* _tmp146_;
										LexerTokenType _tmp147_;
										_tmp146_ = token;
										_tmp147_ = _tmp146_->type;
										if (_tmp147_ == LEXER_TOKEN_TYPE_ADD) {
											Lexer* _tmp148_;
											LexerToken* _tmp149_ = NULL;
											LexerToken* _tmp150_;
											LexerTokenType _tmp151_;
											_tmp148_ = self->priv->lexer;
											_tmp149_ = lexer_get_next_token (_tmp148_);
											_lexer_token_unref0 (token);
											token = _tmp149_;
											_tmp150_ = token;
											_tmp151_ = _tmp150_->type;
											if (_tmp151_ == LEXER_TOKEN_TYPE_NUMBER) {
												LexerToken* _tmp152_;
												LexerToken* _tmp153_;
												LexerTokenType _tmp154_;
												guint _tmp155_ = 0U;
												LexerToken* _tmp156_;
												Associativity _tmp157_ = 0;
												ConstantNode* _tmp158_;
												ConstantNode* _tmp159_;
												_tmp152_ = token;
												_tmp153_ = token;
												_tmp154_ = _tmp153_->type;
												_tmp155_ = parser_make_precedence_t (self, _tmp154_);
												_tmp156_ = token;
												_tmp157_ = parser_get_associativity (self, _tmp156_);
												_tmp158_ = constant_node_new (self, _tmp152_, _tmp155_, _tmp157_);
												_tmp159_ = _tmp158_;
												parser_insert_into_tree (self, (ParseNode*) _tmp159_);
												_parse_node_unref0 (_tmp159_);
												result = TRUE;
												_lexer_token_unref0 (token);
												return result;
											} else {
												result = FALSE;
												_lexer_token_unref0 (token);
												return result;
											}
										} else {
											Lexer* _tmp160_;
											gboolean _tmp161_ = FALSE;
											_tmp160_ = self->priv->lexer;
											lexer_roll_back (_tmp160_);
											_tmp161_ = parser_variable (self);
											if (!_tmp161_) {
												result = FALSE;
												_lexer_token_unref0 (token);
												return result;
											} else {
												result = TRUE;
												_lexer_token_unref0 (token);
												return result;
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	_lexer_token_unref0 (token);
}


static gboolean parser_expression_2 (Parser* self) {
	gboolean result = FALSE;
	Lexer* _tmp0_;
	LexerToken* _tmp1_ = NULL;
	LexerToken* token;
	LexerToken* _tmp2_;
	LexerTokenType _tmp3_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->lexer;
	_tmp1_ = lexer_get_next_token (_tmp0_);
	token = _tmp1_;
	_tmp2_ = token;
	_tmp3_ = _tmp2_->type;
	if (_tmp3_ == LEXER_TOKEN_TYPE_L_R_BRACKET) {
		guint _tmp4_ = 0U;
		Associativity _tmp5_ = 0;
		MultiplyNode* _tmp6_;
		MultiplyNode* _tmp7_;
		guint _tmp8_;
		gboolean _tmp9_ = FALSE;
		Lexer* _tmp10_;
		LexerToken* _tmp11_ = NULL;
		LexerToken* _tmp12_;
		LexerTokenType _tmp13_;
		_tmp4_ = parser_make_precedence_p (self, PRECEDENCE_MULTIPLY);
		_tmp5_ = parser_get_associativity_p (self, PRECEDENCE_MULTIPLY);
		_tmp6_ = multiply_node_new (self, NULL, _tmp4_, _tmp5_);
		_tmp7_ = _tmp6_;
		parser_insert_into_tree (self, (ParseNode*) _tmp7_);
		_parse_node_unref0 (_tmp7_);
		_tmp8_ = self->priv->depth_level;
		self->priv->depth_level = _tmp8_ + 1;
		_tmp9_ = parser_expression (self);
		if (!_tmp9_) {
			result = FALSE;
			_lexer_token_unref0 (token);
			return result;
		}
		_tmp10_ = self->priv->lexer;
		_tmp11_ = lexer_get_next_token (_tmp10_);
		_lexer_token_unref0 (token);
		token = _tmp11_;
		_tmp12_ = token;
		_tmp13_ = _tmp12_->type;
		if (_tmp13_ == LEXER_TOKEN_TYPE_R_R_BRACKET) {
			guint _tmp14_;
			gboolean _tmp15_ = FALSE;
			_tmp14_ = self->priv->depth_level;
			self->priv->depth_level = _tmp14_ - 1;
			_tmp15_ = parser_expression_2 (self);
			if (!_tmp15_) {
				result = FALSE;
				_lexer_token_unref0 (token);
				return result;
			}
			result = TRUE;
			_lexer_token_unref0 (token);
			return result;
		} else {
			result = FALSE;
			_lexer_token_unref0 (token);
			return result;
		}
	} else {
		LexerToken* _tmp16_;
		LexerTokenType _tmp17_;
		_tmp16_ = token;
		_tmp17_ = _tmp16_->type;
		if (_tmp17_ == LEXER_TOKEN_TYPE_POWER) {
			LexerToken* _tmp18_;
			LexerToken* _tmp19_;
			LexerTokenType _tmp20_;
			guint _tmp21_ = 0U;
			LexerToken* _tmp22_;
			Associativity _tmp23_ = 0;
			XPowYNode* _tmp24_;
			XPowYNode* _tmp25_;
			gboolean _tmp26_ = FALSE;
			gboolean _tmp27_ = FALSE;
			_tmp18_ = token;
			_tmp19_ = token;
			_tmp20_ = _tmp19_->type;
			_tmp21_ = parser_make_precedence_t (self, _tmp20_);
			_tmp22_ = token;
			_tmp23_ = parser_get_associativity (self, _tmp22_);
			_tmp24_ = xpow_ynode_new (self, _tmp18_, _tmp21_, _tmp23_);
			_tmp25_ = _tmp24_;
			parser_insert_into_tree (self, (ParseNode*) _tmp25_);
			_parse_node_unref0 (_tmp25_);
			_tmp26_ = parser_expression_1 (self);
			if (!_tmp26_) {
				result = FALSE;
				_lexer_token_unref0 (token);
				return result;
			}
			_tmp27_ = parser_expression_2 (self);
			if (!_tmp27_) {
				result = FALSE;
				_lexer_token_unref0 (token);
				return result;
			}
			result = TRUE;
			_lexer_token_unref0 (token);
			return result;
		} else {
			LexerToken* _tmp28_;
			LexerTokenType _tmp29_;
			_tmp28_ = token;
			_tmp29_ = _tmp28_->type;
			if (_tmp29_ == LEXER_TOKEN_TYPE_SUP_NUMBER) {
				guint _tmp30_ = 0U;
				Associativity _tmp31_ = 0;
				XPowYIntegerNode* _tmp32_;
				XPowYIntegerNode* _tmp33_;
				LexerToken* _tmp34_;
				guint _tmp35_ = 0U;
				Associativity _tmp36_ = 0;
				NameNode* _tmp37_;
				NameNode* _tmp38_;
				gboolean _tmp39_ = FALSE;
				_tmp30_ = parser_make_precedence_p (self, PRECEDENCE_POWER);
				_tmp31_ = parser_get_associativity_p (self, PRECEDENCE_POWER);
				_tmp32_ = xpow_yinteger_node_new (self, NULL, _tmp30_, _tmp31_);
				_tmp33_ = _tmp32_;
				parser_insert_into_tree (self, (ParseNode*) _tmp33_);
				_parse_node_unref0 (_tmp33_);
				_tmp34_ = token;
				_tmp35_ = parser_make_precedence_p (self, PRECEDENCE_NUMBER_VARIABLE);
				_tmp36_ = parser_get_associativity_p (self, PRECEDENCE_NUMBER_VARIABLE);
				_tmp37_ = name_node_new (self, _tmp34_, _tmp35_, _tmp36_, NULL);
				_tmp38_ = _tmp37_;
				parser_insert_into_tree (self, (ParseNode*) _tmp38_);
				_parse_node_unref0 (_tmp38_);
				_tmp39_ = parser_expression_2 (self);
				if (!_tmp39_) {
					result = FALSE;
					_lexer_token_unref0 (token);
					return result;
				}
				result = TRUE;
				_lexer_token_unref0 (token);
				return result;
			} else {
				LexerToken* _tmp40_;
				LexerTokenType _tmp41_;
				_tmp40_ = token;
				_tmp41_ = _tmp40_->type;
				if (_tmp41_ == LEXER_TOKEN_TYPE_NSUP_NUMBER) {
					guint _tmp42_ = 0U;
					Associativity _tmp43_ = 0;
					XPowYIntegerNode* _tmp44_;
					XPowYIntegerNode* _tmp45_;
					LexerToken* _tmp46_;
					guint _tmp47_ = 0U;
					Associativity _tmp48_ = 0;
					NameNode* _tmp49_;
					NameNode* _tmp50_;
					gboolean _tmp51_ = FALSE;
					_tmp42_ = parser_make_precedence_p (self, PRECEDENCE_POWER);
					_tmp43_ = parser_get_associativity_p (self, PRECEDENCE_POWER);
					_tmp44_ = xpow_yinteger_node_new (self, NULL, _tmp42_, _tmp43_);
					_tmp45_ = _tmp44_;
					parser_insert_into_tree (self, (ParseNode*) _tmp45_);
					_parse_node_unref0 (_tmp45_);
					_tmp46_ = token;
					_tmp47_ = parser_make_precedence_p (self, PRECEDENCE_NUMBER_VARIABLE);
					_tmp48_ = parser_get_associativity_p (self, PRECEDENCE_NUMBER_VARIABLE);
					_tmp49_ = name_node_new (self, _tmp46_, _tmp47_, _tmp48_, NULL);
					_tmp50_ = _tmp49_;
					parser_insert_into_tree (self, (ParseNode*) _tmp50_);
					_parse_node_unref0 (_tmp50_);
					_tmp51_ = parser_expression_2 (self);
					if (!_tmp51_) {
						result = FALSE;
						_lexer_token_unref0 (token);
						return result;
					}
					result = TRUE;
					_lexer_token_unref0 (token);
					return result;
				} else {
					LexerToken* _tmp52_;
					LexerTokenType _tmp53_;
					_tmp52_ = token;
					_tmp53_ = _tmp52_->type;
					if (_tmp53_ == LEXER_TOKEN_TYPE_FACTORIAL) {
						LexerToken* _tmp54_;
						LexerToken* _tmp55_;
						LexerTokenType _tmp56_;
						guint _tmp57_ = 0U;
						LexerToken* _tmp58_;
						Associativity _tmp59_ = 0;
						FactorialNode* _tmp60_;
						FactorialNode* _tmp61_;
						gboolean _tmp62_ = FALSE;
						_tmp54_ = token;
						_tmp55_ = token;
						_tmp56_ = _tmp55_->type;
						_tmp57_ = parser_make_precedence_t (self, _tmp56_);
						_tmp58_ = token;
						_tmp59_ = parser_get_associativity (self, _tmp58_);
						_tmp60_ = factorial_node_new (self, _tmp54_, _tmp57_, _tmp59_);
						_tmp61_ = _tmp60_;
						parser_insert_into_tree_unary (self, (ParseNode*) _tmp61_);
						_parse_node_unref0 (_tmp61_);
						_tmp62_ = parser_expression_2 (self);
						if (!_tmp62_) {
							result = FALSE;
							_lexer_token_unref0 (token);
							return result;
						}
						result = TRUE;
						_lexer_token_unref0 (token);
						return result;
					} else {
						LexerToken* _tmp63_;
						LexerTokenType _tmp64_;
						_tmp63_ = token;
						_tmp64_ = _tmp63_->type;
						if (_tmp64_ == LEXER_TOKEN_TYPE_MULTIPLY) {
							LexerToken* _tmp65_;
							LexerToken* _tmp66_;
							LexerTokenType _tmp67_;
							guint _tmp68_ = 0U;
							LexerToken* _tmp69_;
							Associativity _tmp70_ = 0;
							MultiplyNode* _tmp71_;
							MultiplyNode* _tmp72_;
							gboolean _tmp73_ = FALSE;
							gboolean _tmp74_ = FALSE;
							_tmp65_ = token;
							_tmp66_ = token;
							_tmp67_ = _tmp66_->type;
							_tmp68_ = parser_make_precedence_t (self, _tmp67_);
							_tmp69_ = token;
							_tmp70_ = parser_get_associativity (self, _tmp69_);
							_tmp71_ = multiply_node_new (self, _tmp65_, _tmp68_, _tmp70_);
							_tmp72_ = _tmp71_;
							parser_insert_into_tree (self, (ParseNode*) _tmp72_);
							_parse_node_unref0 (_tmp72_);
							_tmp73_ = parser_expression_1 (self);
							if (!_tmp73_) {
								result = FALSE;
								_lexer_token_unref0 (token);
								return result;
							}
							_tmp74_ = parser_expression_2 (self);
							if (!_tmp74_) {
								result = FALSE;
								_lexer_token_unref0 (token);
								return result;
							}
							result = TRUE;
							_lexer_token_unref0 (token);
							return result;
						} else {
							LexerToken* _tmp75_;
							LexerTokenType _tmp76_;
							_tmp75_ = token;
							_tmp76_ = _tmp75_->type;
							if (_tmp76_ == LEXER_TOKEN_TYPE_PERCENTAGE) {
								LexerToken* _tmp77_;
								LexerToken* _tmp78_;
								LexerTokenType _tmp79_;
								guint _tmp80_ = 0U;
								LexerToken* _tmp81_;
								Associativity _tmp82_ = 0;
								PercentNode* _tmp83_;
								PercentNode* _tmp84_;
								gboolean _tmp85_ = FALSE;
								_tmp77_ = token;
								_tmp78_ = token;
								_tmp79_ = _tmp78_->type;
								_tmp80_ = parser_make_precedence_t (self, _tmp79_);
								_tmp81_ = token;
								_tmp82_ = parser_get_associativity (self, _tmp81_);
								_tmp83_ = percent_node_new (self, _tmp77_, _tmp80_, _tmp82_);
								_tmp84_ = _tmp83_;
								parser_insert_into_tree_unary (self, (ParseNode*) _tmp84_);
								_parse_node_unref0 (_tmp84_);
								_tmp85_ = parser_expression_2 (self);
								if (!_tmp85_) {
									result = FALSE;
									_lexer_token_unref0 (token);
									return result;
								}
								result = TRUE;
								_lexer_token_unref0 (token);
								return result;
							} else {
								LexerToken* _tmp86_;
								LexerTokenType _tmp87_;
								_tmp86_ = token;
								_tmp87_ = _tmp86_->type;
								if (_tmp87_ == LEXER_TOKEN_TYPE_AND) {
									LexerToken* _tmp88_;
									LexerToken* _tmp89_;
									LexerTokenType _tmp90_;
									guint _tmp91_ = 0U;
									LexerToken* _tmp92_;
									Associativity _tmp93_ = 0;
									AndNode* _tmp94_;
									AndNode* _tmp95_;
									gboolean _tmp96_ = FALSE;
									gboolean _tmp97_ = FALSE;
									_tmp88_ = token;
									_tmp89_ = token;
									_tmp90_ = _tmp89_->type;
									_tmp91_ = parser_make_precedence_t (self, _tmp90_);
									_tmp92_ = token;
									_tmp93_ = parser_get_associativity (self, _tmp92_);
									_tmp94_ = and_node_new (self, _tmp88_, _tmp91_, _tmp93_);
									_tmp95_ = _tmp94_;
									parser_insert_into_tree (self, (ParseNode*) _tmp95_);
									_parse_node_unref0 (_tmp95_);
									_tmp96_ = parser_expression_1 (self);
									if (!_tmp96_) {
										result = FALSE;
										_lexer_token_unref0 (token);
										return result;
									}
									_tmp97_ = parser_expression_2 (self);
									if (!_tmp97_) {
										result = FALSE;
										_lexer_token_unref0 (token);
										return result;
									}
									result = TRUE;
									_lexer_token_unref0 (token);
									return result;
								} else {
									LexerToken* _tmp98_;
									LexerTokenType _tmp99_;
									_tmp98_ = token;
									_tmp99_ = _tmp98_->type;
									if (_tmp99_ == LEXER_TOKEN_TYPE_OR) {
										LexerToken* _tmp100_;
										LexerToken* _tmp101_;
										LexerTokenType _tmp102_;
										guint _tmp103_ = 0U;
										LexerToken* _tmp104_;
										Associativity _tmp105_ = 0;
										OrNode* _tmp106_;
										OrNode* _tmp107_;
										gboolean _tmp108_ = FALSE;
										gboolean _tmp109_ = FALSE;
										_tmp100_ = token;
										_tmp101_ = token;
										_tmp102_ = _tmp101_->type;
										_tmp103_ = parser_make_precedence_t (self, _tmp102_);
										_tmp104_ = token;
										_tmp105_ = parser_get_associativity (self, _tmp104_);
										_tmp106_ = or_node_new (self, _tmp100_, _tmp103_, _tmp105_);
										_tmp107_ = _tmp106_;
										parser_insert_into_tree (self, (ParseNode*) _tmp107_);
										_parse_node_unref0 (_tmp107_);
										_tmp108_ = parser_expression_1 (self);
										if (!_tmp108_) {
											result = FALSE;
											_lexer_token_unref0 (token);
											return result;
										}
										_tmp109_ = parser_expression_2 (self);
										if (!_tmp109_) {
											result = FALSE;
											_lexer_token_unref0 (token);
											return result;
										}
										result = TRUE;
										_lexer_token_unref0 (token);
										return result;
									} else {
										LexerToken* _tmp110_;
										LexerTokenType _tmp111_;
										_tmp110_ = token;
										_tmp111_ = _tmp110_->type;
										if (_tmp111_ == LEXER_TOKEN_TYPE_XOR) {
											LexerToken* _tmp112_;
											LexerToken* _tmp113_;
											LexerTokenType _tmp114_;
											guint _tmp115_ = 0U;
											LexerToken* _tmp116_;
											Associativity _tmp117_ = 0;
											XorNode* _tmp118_;
											XorNode* _tmp119_;
											gboolean _tmp120_ = FALSE;
											gboolean _tmp121_ = FALSE;
											_tmp112_ = token;
											_tmp113_ = token;
											_tmp114_ = _tmp113_->type;
											_tmp115_ = parser_make_precedence_t (self, _tmp114_);
											_tmp116_ = token;
											_tmp117_ = parser_get_associativity (self, _tmp116_);
											_tmp118_ = xor_node_new (self, _tmp112_, _tmp115_, _tmp117_);
											_tmp119_ = _tmp118_;
											parser_insert_into_tree (self, (ParseNode*) _tmp119_);
											_parse_node_unref0 (_tmp119_);
											_tmp120_ = parser_expression_1 (self);
											if (!_tmp120_) {
												result = FALSE;
												_lexer_token_unref0 (token);
												return result;
											}
											_tmp121_ = parser_expression_2 (self);
											if (!_tmp121_) {
												result = FALSE;
												_lexer_token_unref0 (token);
												return result;
											}
											result = TRUE;
											_lexer_token_unref0 (token);
											return result;
										} else {
											LexerToken* _tmp122_;
											LexerTokenType _tmp123_;
											_tmp122_ = token;
											_tmp123_ = _tmp122_->type;
											if (_tmp123_ == LEXER_TOKEN_TYPE_DIVIDE) {
												LexerToken* _tmp124_;
												LexerToken* _tmp125_;
												LexerTokenType _tmp126_;
												guint _tmp127_ = 0U;
												LexerToken* _tmp128_;
												Associativity _tmp129_ = 0;
												DivideNode* _tmp130_;
												DivideNode* _tmp131_;
												gboolean _tmp132_ = FALSE;
												gboolean _tmp133_ = FALSE;
												_tmp124_ = token;
												_tmp125_ = token;
												_tmp126_ = _tmp125_->type;
												_tmp127_ = parser_make_precedence_t (self, _tmp126_);
												_tmp128_ = token;
												_tmp129_ = parser_get_associativity (self, _tmp128_);
												_tmp130_ = divide_node_new (self, _tmp124_, _tmp127_, _tmp129_);
												_tmp131_ = _tmp130_;
												parser_insert_into_tree (self, (ParseNode*) _tmp131_);
												_parse_node_unref0 (_tmp131_);
												_tmp132_ = parser_expression_1 (self);
												if (!_tmp132_) {
													result = FALSE;
													_lexer_token_unref0 (token);
													return result;
												}
												_tmp133_ = parser_expression_2 (self);
												if (!_tmp133_) {
													result = FALSE;
													_lexer_token_unref0 (token);
													return result;
												}
												result = TRUE;
												_lexer_token_unref0 (token);
												return result;
											} else {
												LexerToken* _tmp134_;
												LexerTokenType _tmp135_;
												_tmp134_ = token;
												_tmp135_ = _tmp134_->type;
												if (_tmp135_ == LEXER_TOKEN_TYPE_MOD) {
													LexerToken* _tmp136_;
													LexerToken* _tmp137_;
													LexerTokenType _tmp138_;
													guint _tmp139_ = 0U;
													LexerToken* _tmp140_;
													Associativity _tmp141_ = 0;
													ModulusDivideNode* _tmp142_;
													ModulusDivideNode* _tmp143_;
													gboolean _tmp144_ = FALSE;
													gboolean _tmp145_ = FALSE;
													_tmp136_ = token;
													_tmp137_ = token;
													_tmp138_ = _tmp137_->type;
													_tmp139_ = parser_make_precedence_t (self, _tmp138_);
													_tmp140_ = token;
													_tmp141_ = parser_get_associativity (self, _tmp140_);
													_tmp142_ = modulus_divide_node_new (self, _tmp136_, _tmp139_, _tmp141_);
													_tmp143_ = _tmp142_;
													parser_insert_into_tree (self, (ParseNode*) _tmp143_);
													_parse_node_unref0 (_tmp143_);
													_tmp144_ = parser_expression_1 (self);
													if (!_tmp144_) {
														result = FALSE;
														_lexer_token_unref0 (token);
														return result;
													}
													_tmp145_ = parser_expression_2 (self);
													if (!_tmp145_) {
														result = FALSE;
														_lexer_token_unref0 (token);
														return result;
													}
													result = TRUE;
													_lexer_token_unref0 (token);
													return result;
												} else {
													LexerToken* _tmp146_;
													LexerTokenType _tmp147_;
													_tmp146_ = token;
													_tmp147_ = _tmp146_->type;
													if (_tmp147_ == LEXER_TOKEN_TYPE_ADD) {
														LexerToken* _tmp148_;
														LexerToken* _tmp149_;
														LexerTokenType _tmp150_;
														guint _tmp151_ = 0U;
														LexerToken* _tmp152_;
														Associativity _tmp153_ = 0;
														AddNode* _tmp154_;
														AddNode* node;
														AddNode* _tmp155_;
														gboolean _tmp156_ = FALSE;
														Lexer* _tmp157_;
														LexerToken* _tmp158_ = NULL;
														LexerToken* _tmp159_;
														LexerTokenType _tmp160_;
														gboolean _tmp169_ = FALSE;
														_tmp148_ = token;
														_tmp149_ = token;
														_tmp150_ = _tmp149_->type;
														_tmp151_ = parser_make_precedence_t (self, _tmp150_);
														_tmp152_ = token;
														_tmp153_ = parser_get_associativity (self, _tmp152_);
														_tmp154_ = add_node_new (self, _tmp148_, _tmp151_, _tmp153_);
														node = _tmp154_;
														_tmp155_ = node;
														parser_insert_into_tree (self, (ParseNode*) _tmp155_);
														_tmp156_ = parser_expression_1 (self);
														if (!_tmp156_) {
															result = FALSE;
															_parse_node_unref0 (node);
															_lexer_token_unref0 (token);
															return result;
														}
														_tmp157_ = self->priv->lexer;
														_tmp158_ = lexer_get_next_token (_tmp157_);
														_lexer_token_unref0 (token);
														token = _tmp158_;
														_tmp159_ = token;
														_tmp160_ = _tmp159_->type;
														if (_tmp160_ == LEXER_TOKEN_TYPE_PERCENTAGE) {
															AddNode* _tmp161_;
															ParseNode* _tmp162_;
															guint _tmp163_;
															_tmp161_ = node;
															_tmp162_ = ((ParseNode*) _tmp161_)->right;
															_tmp163_ = _tmp162_->precedence;
															if (_tmp163_ > ((guint) PRECEDENCE_PERCENTAGE)) {
																AddNode* _tmp164_;
																AddNode* _tmp165_;
																_tmp164_ = node;
																((ParseNode*) _tmp164_)->precedence = (guint) PRECEDENCE_PERCENTAGE;
																_tmp165_ = node;
																_tmp165_->do_percentage = TRUE;
																result = TRUE;
																_parse_node_unref0 (node);
																_lexer_token_unref0 (token);
																return result;
															} else {
																Lexer* _tmp166_;
																gboolean _tmp167_ = FALSE;
																_tmp166_ = self->priv->lexer;
																lexer_roll_back (_tmp166_);
																_tmp167_ = parser_expression_2 (self);
																if (!_tmp167_) {
																	result = TRUE;
																	_parse_node_unref0 (node);
																	_lexer_token_unref0 (token);
																	return result;
																}
															}
														} else {
															Lexer* _tmp168_;
															_tmp168_ = self->priv->lexer;
															lexer_roll_back (_tmp168_);
														}
														_tmp169_ = parser_expression_2 (self);
														if (!_tmp169_) {
															result = FALSE;
															_parse_node_unref0 (node);
															_lexer_token_unref0 (token);
															return result;
														}
														result = TRUE;
														_parse_node_unref0 (node);
														_lexer_token_unref0 (token);
														return result;
													} else {
														LexerToken* _tmp170_;
														LexerTokenType _tmp171_;
														_tmp170_ = token;
														_tmp171_ = _tmp170_->type;
														if (_tmp171_ == LEXER_TOKEN_TYPE_SUBTRACT) {
															LexerToken* _tmp172_;
															LexerToken* _tmp173_;
															LexerTokenType _tmp174_;
															guint _tmp175_ = 0U;
															LexerToken* _tmp176_;
															Associativity _tmp177_ = 0;
															SubtractNode* _tmp178_;
															SubtractNode* node;
															SubtractNode* _tmp179_;
															gboolean _tmp180_ = FALSE;
															Lexer* _tmp181_;
															LexerToken* _tmp182_ = NULL;
															LexerToken* _tmp183_;
															LexerTokenType _tmp184_;
															gboolean _tmp193_ = FALSE;
															_tmp172_ = token;
															_tmp173_ = token;
															_tmp174_ = _tmp173_->type;
															_tmp175_ = parser_make_precedence_t (self, _tmp174_);
															_tmp176_ = token;
															_tmp177_ = parser_get_associativity (self, _tmp176_);
															_tmp178_ = subtract_node_new (self, _tmp172_, _tmp175_, _tmp177_);
															node = _tmp178_;
															_tmp179_ = node;
															parser_insert_into_tree (self, (ParseNode*) _tmp179_);
															_tmp180_ = parser_expression_1 (self);
															if (!_tmp180_) {
																result = FALSE;
																_parse_node_unref0 (node);
																_lexer_token_unref0 (token);
																return result;
															}
															_tmp181_ = self->priv->lexer;
															_tmp182_ = lexer_get_next_token (_tmp181_);
															_lexer_token_unref0 (token);
															token = _tmp182_;
															_tmp183_ = token;
															_tmp184_ = _tmp183_->type;
															if (_tmp184_ == LEXER_TOKEN_TYPE_PERCENTAGE) {
																SubtractNode* _tmp185_;
																ParseNode* _tmp186_;
																guint _tmp187_;
																_tmp185_ = node;
																_tmp186_ = ((ParseNode*) _tmp185_)->right;
																_tmp187_ = _tmp186_->precedence;
																if (_tmp187_ > ((guint) PRECEDENCE_PERCENTAGE)) {
																	SubtractNode* _tmp188_;
																	SubtractNode* _tmp189_;
																	_tmp188_ = node;
																	((ParseNode*) _tmp188_)->precedence = (guint) PRECEDENCE_PERCENTAGE;
																	_tmp189_ = node;
																	_tmp189_->do_percentage = TRUE;
																	result = TRUE;
																	_parse_node_unref0 (node);
																	_lexer_token_unref0 (token);
																	return result;
																} else {
																	Lexer* _tmp190_;
																	gboolean _tmp191_ = FALSE;
																	_tmp190_ = self->priv->lexer;
																	lexer_roll_back (_tmp190_);
																	_tmp191_ = parser_expression_2 (self);
																	if (!_tmp191_) {
																		result = TRUE;
																		_parse_node_unref0 (node);
																		_lexer_token_unref0 (token);
																		return result;
																	}
																}
															} else {
																Lexer* _tmp192_;
																_tmp192_ = self->priv->lexer;
																lexer_roll_back (_tmp192_);
															}
															_tmp193_ = parser_expression_2 (self);
															if (!_tmp193_) {
																result = FALSE;
																_parse_node_unref0 (node);
																_lexer_token_unref0 (token);
																return result;
															}
															result = TRUE;
															_parse_node_unref0 (node);
															_lexer_token_unref0 (token);
															return result;
														} else {
															Lexer* _tmp194_;
															_tmp194_ = self->priv->lexer;
															lexer_roll_back (_tmp194_);
															result = TRUE;
															_lexer_token_unref0 (token);
															return result;
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	_lexer_token_unref0 (token);
}


static gboolean parser_variable (Parser* self) {
	gboolean result = FALSE;
	Lexer* _tmp0_;
	LexerToken* _tmp1_ = NULL;
	LexerToken* token;
	LexerToken* _tmp2_;
	LexerTokenType _tmp3_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->lexer;
	_tmp1_ = lexer_get_next_token (_tmp0_);
	token = _tmp1_;
	_tmp2_ = token;
	_tmp3_ = _tmp2_->type;
	if (_tmp3_ == LEXER_TOKEN_TYPE_FUNCTION) {
		LexerToken* _tmp4_;
		LexerToken* _tmp5_;
		LexerToken* token_old;
		Lexer* _tmp6_;
		LexerToken* _tmp7_ = NULL;
		LexerToken* _tmp8_;
		LexerTokenType _tmp9_;
		_tmp4_ = token;
		_tmp5_ = _lexer_token_ref0 (_tmp4_);
		token_old = _tmp5_;
		_tmp6_ = self->priv->lexer;
		_tmp7_ = lexer_get_next_token (_tmp6_);
		_lexer_token_unref0 (token);
		token = _tmp7_;
		_tmp8_ = token;
		_tmp9_ = _tmp8_->type;
		if (_tmp9_ == LEXER_TOKEN_TYPE_SUP_NUMBER) {
			LexerToken* _tmp10_;
			LexerToken* _tmp11_;
			LexerTokenType _tmp12_;
			guint _tmp13_ = 0U;
			LexerToken* _tmp14_;
			Associativity _tmp15_ = 0;
			LexerToken* _tmp16_;
			const gchar* _tmp17_;
			FunctionWithPowerNode* _tmp18_;
			FunctionWithPowerNode* _tmp19_;
			gboolean _tmp20_ = FALSE;
			_tmp10_ = token_old;
			_tmp11_ = token_old;
			_tmp12_ = _tmp11_->type;
			_tmp13_ = parser_make_precedence_t (self, _tmp12_);
			_tmp14_ = token_old;
			_tmp15_ = parser_get_associativity (self, _tmp14_);
			_tmp16_ = token;
			_tmp17_ = _tmp16_->text;
			_tmp18_ = function_with_power_node_new (self, _tmp10_, _tmp13_, _tmp15_, _tmp17_);
			_tmp19_ = _tmp18_;
			parser_insert_into_tree_unary (self, (ParseNode*) _tmp19_);
			_parse_node_unref0 (_tmp19_);
			_tmp20_ = parser_expression (self);
			if (!_tmp20_) {
				result = FALSE;
				_lexer_token_unref0 (token_old);
				_lexer_token_unref0 (token);
				return result;
			}
			result = TRUE;
			_lexer_token_unref0 (token_old);
			_lexer_token_unref0 (token);
			return result;
		} else {
			LexerToken* _tmp21_;
			LexerTokenType _tmp22_;
			_tmp21_ = token;
			_tmp22_ = _tmp21_->type;
			if (_tmp22_ == LEXER_TOKEN_TYPE_NSUP_NUMBER) {
				LexerToken* _tmp23_;
				LexerToken* _tmp24_;
				LexerTokenType _tmp25_;
				guint _tmp26_ = 0U;
				LexerToken* _tmp27_;
				Associativity _tmp28_ = 0;
				LexerToken* _tmp29_;
				const gchar* _tmp30_;
				FunctionWithNegativePowerNode* _tmp31_;
				FunctionWithNegativePowerNode* _tmp32_;
				gboolean _tmp33_ = FALSE;
				_tmp23_ = token_old;
				_tmp24_ = token_old;
				_tmp25_ = _tmp24_->type;
				_tmp26_ = parser_make_precedence_t (self, _tmp25_);
				_tmp27_ = token_old;
				_tmp28_ = parser_get_associativity (self, _tmp27_);
				_tmp29_ = token;
				_tmp30_ = _tmp29_->text;
				_tmp31_ = function_with_negative_power_node_new (self, _tmp23_, _tmp26_, _tmp28_, _tmp30_);
				_tmp32_ = _tmp31_;
				parser_insert_into_tree_unary (self, (ParseNode*) _tmp32_);
				_parse_node_unref0 (_tmp32_);
				_tmp33_ = parser_expression (self);
				if (!_tmp33_) {
					result = FALSE;
					_lexer_token_unref0 (token_old);
					_lexer_token_unref0 (token);
					return result;
				}
				result = TRUE;
				_lexer_token_unref0 (token_old);
				_lexer_token_unref0 (token);
				return result;
			} else {
				Lexer* _tmp34_;
				LexerToken* _tmp35_;
				LexerToken* _tmp36_;
				LexerTokenType _tmp37_;
				guint _tmp38_ = 0U;
				LexerToken* _tmp39_;
				Associativity _tmp40_ = 0;
				FunctionNode* _tmp41_;
				FunctionNode* _tmp42_;
				gboolean _tmp43_ = FALSE;
				_tmp34_ = self->priv->lexer;
				lexer_roll_back (_tmp34_);
				_tmp35_ = token_old;
				_tmp36_ = token_old;
				_tmp37_ = _tmp36_->type;
				_tmp38_ = parser_make_precedence_t (self, _tmp37_);
				_tmp39_ = token_old;
				_tmp40_ = parser_get_associativity (self, _tmp39_);
				_tmp41_ = function_node_new (self, _tmp35_, _tmp38_, _tmp40_);
				_tmp42_ = _tmp41_;
				parser_insert_into_tree_unary (self, (ParseNode*) _tmp42_);
				_parse_node_unref0 (_tmp42_);
				_tmp43_ = parser_expression (self);
				if (!_tmp43_) {
					result = FALSE;
					_lexer_token_unref0 (token_old);
					_lexer_token_unref0 (token);
					return result;
				}
				result = TRUE;
				_lexer_token_unref0 (token_old);
				_lexer_token_unref0 (token);
				return result;
			}
		}
		_lexer_token_unref0 (token_old);
	} else {
		LexerToken* _tmp44_;
		LexerTokenType _tmp45_;
		_tmp44_ = token;
		_tmp45_ = _tmp44_->type;
		if (_tmp45_ == LEXER_TOKEN_TYPE_SUB_NUMBER) {
			LexerToken* _tmp46_;
			LexerToken* _tmp47_;
			LexerToken* token_old;
			Lexer* _tmp48_;
			LexerToken* _tmp49_ = NULL;
			LexerToken* _tmp50_;
			LexerTokenType _tmp51_;
			_tmp46_ = token;
			_tmp47_ = _lexer_token_ref0 (_tmp46_);
			token_old = _tmp47_;
			_tmp48_ = self->priv->lexer;
			_tmp49_ = lexer_get_next_token (_tmp48_);
			_lexer_token_unref0 (token);
			token = _tmp49_;
			_tmp50_ = token;
			_tmp51_ = _tmp50_->type;
			if (_tmp51_ == LEXER_TOKEN_TYPE_ROOT) {
				LexerToken* _tmp52_;
				LexerToken* _tmp53_;
				LexerTokenType _tmp54_;
				guint _tmp55_ = 0U;
				LexerToken* _tmp56_;
				Associativity _tmp57_ = 0;
				LexerToken* _tmp58_;
				const gchar* _tmp59_;
				gint _tmp60_ = 0;
				RootNode* _tmp61_;
				RootNode* _tmp62_;
				gboolean _tmp63_ = FALSE;
				_tmp52_ = token;
				_tmp53_ = token;
				_tmp54_ = _tmp53_->type;
				_tmp55_ = parser_make_precedence_t (self, _tmp54_);
				_tmp56_ = token;
				_tmp57_ = parser_get_associativity (self, _tmp56_);
				_tmp58_ = token_old;
				_tmp59_ = _tmp58_->text;
				_tmp60_ = sub_atoi (_tmp59_);
				_tmp61_ = root_node_new (self, _tmp52_, _tmp55_, _tmp57_, _tmp60_);
				_tmp62_ = _tmp61_;
				parser_insert_into_tree_unary (self, (ParseNode*) _tmp62_);
				_parse_node_unref0 (_tmp62_);
				_tmp63_ = parser_expression (self);
				if (!_tmp63_) {
					result = FALSE;
					_lexer_token_unref0 (token_old);
					_lexer_token_unref0 (token);
					return result;
				}
				result = TRUE;
				_lexer_token_unref0 (token_old);
				_lexer_token_unref0 (token);
				return result;
			} else {
				result = FALSE;
				_lexer_token_unref0 (token_old);
				_lexer_token_unref0 (token);
				return result;
			}
			_lexer_token_unref0 (token_old);
		} else {
			LexerToken* _tmp64_;
			LexerTokenType _tmp65_;
			_tmp64_ = token;
			_tmp65_ = _tmp64_->type;
			if (_tmp65_ == LEXER_TOKEN_TYPE_ROOT) {
				LexerToken* _tmp66_;
				LexerToken* _tmp67_;
				LexerTokenType _tmp68_;
				guint _tmp69_ = 0U;
				LexerToken* _tmp70_;
				Associativity _tmp71_ = 0;
				RootNode* _tmp72_;
				RootNode* _tmp73_;
				gboolean _tmp74_ = FALSE;
				_tmp66_ = token;
				_tmp67_ = token;
				_tmp68_ = _tmp67_->type;
				_tmp69_ = parser_make_precedence_t (self, _tmp68_);
				_tmp70_ = token;
				_tmp71_ = parser_get_associativity (self, _tmp70_);
				_tmp72_ = root_node_new (self, _tmp66_, _tmp69_, _tmp71_, 2);
				_tmp73_ = _tmp72_;
				parser_insert_into_tree_unary (self, (ParseNode*) _tmp73_);
				_parse_node_unref0 (_tmp73_);
				_tmp74_ = parser_expression (self);
				if (!_tmp74_) {
					result = FALSE;
					_lexer_token_unref0 (token);
					return result;
				}
				result = TRUE;
				_lexer_token_unref0 (token);
				return result;
			} else {
				LexerToken* _tmp75_;
				LexerTokenType _tmp76_;
				_tmp75_ = token;
				_tmp76_ = _tmp75_->type;
				if (_tmp76_ == LEXER_TOKEN_TYPE_ROOT_3) {
					LexerToken* _tmp77_;
					LexerToken* _tmp78_;
					LexerTokenType _tmp79_;
					guint _tmp80_ = 0U;
					LexerToken* _tmp81_;
					Associativity _tmp82_ = 0;
					RootNode* _tmp83_;
					RootNode* _tmp84_;
					gboolean _tmp85_ = FALSE;
					_tmp77_ = token;
					_tmp78_ = token;
					_tmp79_ = _tmp78_->type;
					_tmp80_ = parser_make_precedence_t (self, _tmp79_);
					_tmp81_ = token;
					_tmp82_ = parser_get_associativity (self, _tmp81_);
					_tmp83_ = root_node_new (self, _tmp77_, _tmp80_, _tmp82_, 3);
					_tmp84_ = _tmp83_;
					parser_insert_into_tree_unary (self, (ParseNode*) _tmp84_);
					_parse_node_unref0 (_tmp84_);
					_tmp85_ = parser_expression (self);
					if (!_tmp85_) {
						result = FALSE;
						_lexer_token_unref0 (token);
						return result;
					}
					result = TRUE;
					_lexer_token_unref0 (token);
					return result;
				} else {
					LexerToken* _tmp86_;
					LexerTokenType _tmp87_;
					_tmp86_ = token;
					_tmp87_ = _tmp86_->type;
					if (_tmp87_ == LEXER_TOKEN_TYPE_ROOT_4) {
						LexerToken* _tmp88_;
						LexerToken* _tmp89_;
						LexerTokenType _tmp90_;
						guint _tmp91_ = 0U;
						LexerToken* _tmp92_;
						Associativity _tmp93_ = 0;
						RootNode* _tmp94_;
						RootNode* _tmp95_;
						gboolean _tmp96_ = FALSE;
						_tmp88_ = token;
						_tmp89_ = token;
						_tmp90_ = _tmp89_->type;
						_tmp91_ = parser_make_precedence_t (self, _tmp90_);
						_tmp92_ = token;
						_tmp93_ = parser_get_associativity (self, _tmp92_);
						_tmp94_ = root_node_new (self, _tmp88_, _tmp91_, _tmp93_, 4);
						_tmp95_ = _tmp94_;
						parser_insert_into_tree_unary (self, (ParseNode*) _tmp95_);
						_parse_node_unref0 (_tmp95_);
						_tmp96_ = parser_expression (self);
						if (!_tmp96_) {
							result = FALSE;
							_lexer_token_unref0 (token);
							return result;
						}
						result = TRUE;
						_lexer_token_unref0 (token);
						return result;
					} else {
						LexerToken* _tmp97_;
						LexerTokenType _tmp98_;
						_tmp97_ = token;
						_tmp98_ = _tmp97_->type;
						if (_tmp98_ == LEXER_TOKEN_TYPE_VARIABLE) {
							Lexer* _tmp99_;
							gboolean _tmp100_ = FALSE;
							_tmp99_ = self->priv->lexer;
							lexer_roll_back (_tmp99_);
							_tmp100_ = parser_term (self);
							if (!_tmp100_) {
								result = FALSE;
								_lexer_token_unref0 (token);
								return result;
							}
							result = TRUE;
							_lexer_token_unref0 (token);
							return result;
						} else {
							result = FALSE;
							_lexer_token_unref0 (token);
							return result;
						}
					}
				}
			}
		}
	}
	_lexer_token_unref0 (token);
}


static gboolean parser_term (Parser* self) {
	gboolean result = FALSE;
	Lexer* _tmp0_;
	LexerToken* _tmp1_ = NULL;
	LexerToken* token;
	LexerToken* _tmp2_;
	LexerTokenType _tmp3_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->lexer;
	_tmp1_ = lexer_get_next_token (_tmp0_);
	token = _tmp1_;
	_tmp2_ = token;
	_tmp3_ = _tmp2_->type;
	if (_tmp3_ == LEXER_TOKEN_TYPE_VARIABLE) {
		LexerToken* _tmp4_;
		LexerToken* _tmp5_;
		LexerToken* token_old;
		LexerToken* _tmp6_;
		const gchar* _tmp7_;
		gboolean _tmp8_ = FALSE;
		Lexer* _tmp15_;
		LexerToken* _tmp16_ = NULL;
		LexerToken* _tmp17_;
		LexerTokenType _tmp18_;
		gboolean _tmp38_ = FALSE;
		_tmp4_ = token;
		_tmp5_ = _lexer_token_ref0 (_tmp4_);
		token_old = _tmp5_;
		_tmp6_ = token;
		_tmp7_ = _tmp6_->text;
		_tmp8_ = parser_check_variable (self, _tmp7_);
		if (!_tmp8_) {
			LexerToken* _tmp9_;
			const gchar* _tmp10_;
			LexerToken* _tmp11_;
			guint _tmp12_;
			LexerToken* _tmp13_;
			guint _tmp14_;
			_tmp9_ = token;
			_tmp10_ = _tmp9_->text;
			_tmp11_ = token;
			_tmp12_ = _tmp11_->start_index;
			_tmp13_ = token;
			_tmp14_ = _tmp13_->end_index;
			parser_set_error (self, ERROR_CODE_UNKNOWN_VARIABLE, _tmp10_, _tmp12_, _tmp14_);
			result = FALSE;
			_lexer_token_unref0 (token_old);
			_lexer_token_unref0 (token);
			return result;
		}
		_tmp15_ = self->priv->lexer;
		_tmp16_ = lexer_get_next_token (_tmp15_);
		_lexer_token_unref0 (token);
		token = _tmp16_;
		_tmp17_ = token;
		_tmp18_ = _tmp17_->type;
		if (_tmp18_ == LEXER_TOKEN_TYPE_SUP_NUMBER) {
			LexerToken* _tmp19_;
			LexerToken* _tmp20_;
			LexerTokenType _tmp21_;
			guint _tmp22_ = 0U;
			LexerToken* _tmp23_;
			Associativity _tmp24_ = 0;
			LexerToken* _tmp25_;
			const gchar* _tmp26_;
			VariableWithPowerNode* _tmp27_;
			VariableWithPowerNode* _tmp28_;
			_tmp19_ = token_old;
			_tmp20_ = token_old;
			_tmp21_ = _tmp20_->type;
			_tmp22_ = parser_make_precedence_t (self, _tmp21_);
			_tmp23_ = token_old;
			_tmp24_ = parser_get_associativity (self, _tmp23_);
			_tmp25_ = token;
			_tmp26_ = _tmp25_->text;
			_tmp27_ = variable_with_power_node_new (self, _tmp19_, _tmp22_, _tmp24_, _tmp26_);
			_tmp28_ = _tmp27_;
			parser_insert_into_tree (self, (ParseNode*) _tmp28_);
			_parse_node_unref0 (_tmp28_);
		} else {
			Lexer* _tmp29_;
			LexerToken* _tmp30_;
			LexerToken* _tmp31_;
			LexerTokenType _tmp32_;
			guint _tmp33_ = 0U;
			LexerToken* _tmp34_;
			Associativity _tmp35_ = 0;
			VariableNode* _tmp36_;
			VariableNode* _tmp37_;
			_tmp29_ = self->priv->lexer;
			lexer_roll_back (_tmp29_);
			_tmp30_ = token_old;
			_tmp31_ = token_old;
			_tmp32_ = _tmp31_->type;
			_tmp33_ = parser_make_precedence_t (self, _tmp32_);
			_tmp34_ = token_old;
			_tmp35_ = parser_get_associativity (self, _tmp34_);
			_tmp36_ = variable_node_new (self, _tmp30_, _tmp33_, _tmp35_);
			_tmp37_ = _tmp36_;
			parser_insert_into_tree (self, (ParseNode*) _tmp37_);
			_parse_node_unref0 (_tmp37_);
		}
		_tmp38_ = parser_term_2 (self);
		if (!_tmp38_) {
			result = FALSE;
			_lexer_token_unref0 (token_old);
			_lexer_token_unref0 (token);
			return result;
		}
		result = TRUE;
		_lexer_token_unref0 (token_old);
		_lexer_token_unref0 (token);
		return result;
	} else {
		result = FALSE;
		_lexer_token_unref0 (token);
		return result;
	}
	_lexer_token_unref0 (token);
}


static gboolean parser_term_2 (Parser* self) {
	gboolean result = FALSE;
	Lexer* _tmp0_;
	LexerToken* _tmp1_ = NULL;
	LexerToken* token;
	Lexer* _tmp2_;
	gboolean _tmp3_ = FALSE;
	LexerToken* _tmp4_;
	LexerTokenType _tmp5_;
	gboolean _tmp8_;
	LexerToken* _tmp9_;
	LexerTokenType _tmp10_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->lexer;
	_tmp1_ = lexer_get_next_token (_tmp0_);
	token = _tmp1_;
	_tmp2_ = self->priv->lexer;
	lexer_roll_back (_tmp2_);
	_tmp4_ = token;
	_tmp5_ = _tmp4_->type;
	if (_tmp5_ == LEXER_TOKEN_TYPE_PL_EOS) {
		_tmp3_ = TRUE;
	} else {
		LexerToken* _tmp6_;
		LexerTokenType _tmp7_;
		_tmp6_ = token;
		_tmp7_ = _tmp6_->type;
		_tmp3_ = _tmp7_ == LEXER_TOKEN_TYPE_ASSIGN;
	}
	_tmp8_ = _tmp3_;
	if (_tmp8_) {
		result = TRUE;
		_lexer_token_unref0 (token);
		return result;
	}
	_tmp9_ = token;
	_tmp10_ = _tmp9_->type;
	if (_tmp10_ == LEXER_TOKEN_TYPE_VARIABLE) {
		guint _tmp11_ = 0U;
		Associativity _tmp12_ = 0;
		MultiplyNode* _tmp13_;
		MultiplyNode* _tmp14_;
		gboolean _tmp15_ = FALSE;
		_tmp11_ = parser_make_precedence_p (self, PRECEDENCE_MULTIPLY);
		_tmp12_ = parser_get_associativity_p (self, PRECEDENCE_MULTIPLY);
		_tmp13_ = multiply_node_new (self, NULL, _tmp11_, _tmp12_);
		_tmp14_ = _tmp13_;
		parser_insert_into_tree (self, (ParseNode*) _tmp14_);
		_parse_node_unref0 (_tmp14_);
		_tmp15_ = parser_term (self);
		if (!_tmp15_) {
			result = FALSE;
			_lexer_token_unref0 (token);
			return result;
		}
		result = TRUE;
		_lexer_token_unref0 (token);
		return result;
	} else {
		result = TRUE;
		_lexer_token_unref0 (token);
		return result;
	}
	_lexer_token_unref0 (token);
}


static void value_parser_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void value_parser_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		parser_unref (value->data[0].v_pointer);
	}
}


static void value_parser_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = parser_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer value_parser_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* value_parser_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		Parser* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = parser_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* value_parser_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	Parser** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = parser_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* param_spec_parser (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ParamSpecParser* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_PARSER), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer value_get_parser (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_PARSER), NULL);
	return value->data[0].v_pointer;
}


void value_set_parser (GValue* value, gpointer v_object) {
	Parser* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_PARSER));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_PARSER));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		parser_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		parser_unref (old);
	}
}


void value_take_parser (GValue* value, gpointer v_object) {
	Parser* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_PARSER));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_PARSER));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		parser_unref (old);
	}
}


static void parser_class_init (ParserClass * klass) {
	parser_parent_class = g_type_class_peek_parent (klass);
	PARSER_CLASS (klass)->finalize = parser_finalize;
	g_type_class_add_private (klass, sizeof (ParserPrivate));
	PARSER_CLASS (klass)->variable_is_defined = parser_real_variable_is_defined;
	PARSER_CLASS (klass)->get_variable = parser_real_get_variable;
	PARSER_CLASS (klass)->set_variable = parser_real_set_variable;
	PARSER_CLASS (klass)->function_is_defined = parser_real_function_is_defined;
	PARSER_CLASS (klass)->get_function = parser_real_get_function;
	PARSER_CLASS (klass)->convert = parser_real_convert;
}


static void parser_instance_init (Parser * self) {
	self->priv = PARSER_GET_PRIVATE (self);
	self->ref_count = 1;
}


static void parser_finalize (Parser* obj) {
	Parser * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_PARSER, Parser);
	_g_free0 (self->priv->input);
	_parse_node_unref0 (self->priv->root);
	_parse_node_unref0 (self->priv->right_most);
	_lexer_unref0 (self->priv->lexer);
	_g_free0 (self->priv->error_token);
}


GType parser_get_type (void) {
	static volatile gsize parser_type_id__volatile = 0;
	if (g_once_init_enter (&parser_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { value_parser_init, value_parser_free_value, value_parser_copy_value, value_parser_peek_pointer, "p", value_parser_collect_value, "p", value_parser_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (ParserClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) parser_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Parser), 0, (GInstanceInitFunc) parser_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType parser_type_id;
		parser_type_id = g_type_register_fundamental (g_type_fundamental_next (), "Parser", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&parser_type_id__volatile, parser_type_id);
	}
	return parser_type_id__volatile;
}


gpointer parser_ref (gpointer instance) {
	Parser* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void parser_unref (gpointer instance) {
	Parser* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		PARSER_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}



